<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Spring 中的注解：@Autowired、@Resource 和 @Inject - Coding Man</title><meta name="Description" content="在本文中，我们旨在更深入地了解每个注释的行为。了解每个注释的行为方式将有助于更好的整体应用程序设计和维护。"><meta property="og:title" content="Spring 中的注解：@Autowired、@Resource 和 @Inject" />
<meta property="og:description" content="在本文中，我们旨在更深入地了解每个注释的行为。了解每个注释的行为方式将有助于更好的整体应用程序设计和维护。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://itcodingman.github.io/spring_annotations_resource_inject_autowire/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-08T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-07-20T00:00:00+00:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring 中的注解：@Autowired、@Resource 和 @Inject"/>
<meta name="twitter:description" content="在本文中，我们旨在更深入地了解每个注释的行为。了解每个注释的行为方式将有助于更好的整体应用程序设计和维护。"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2168947316195146"
     crossorigin="anonymous"></script><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://itcodingman.github.io/spring_annotations_resource_inject_autowire/" /><link rel="prev" href="http://itcodingman.github.io/securing_a_restful_web_service_with_spring_security/" /><link rel="next" href="http://itcodingman.github.io/spring_autowired/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Spring 中的注解：@Autowired、@Resource 和 @Inject",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/itcodingman.github.io\/spring_annotations_resource_inject_autowire\/"
        },"genre": "posts","keywords": "Spring DI, Spring Core Basics","wordcount":  6936 ,
        "url": "http:\/\/itcodingman.github.io\/spring_annotations_resource_inject_autowire\/","datePublished": "2020-04-08T00:00:00+00:00","dateModified": "2022-07-20T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "codingman"
            },"description": "在本文中，我们旨在更深入地了解每个注释的行为。了解每个注释的行为方式将有助于更好的整体应用程序设计和维护。"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Coding Man"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.jpg"
        data-srcset="/logo.jpg, /logo.jpg 1.5x, /logo.jpg 2x"
        data-sizes="auto"
        alt="/logo.jpg"
        title="/logo.jpg" />Coding Man</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 
										</a><a class="menu-item" href="/tags/"> 标签 
										</a><a class="menu-item" href="/categories/"> 分类 
										</a><a class="menu-item" href="/search/"><i class='fas fa-fw fa-search'></i> 搜索 
										</a>
										<div class="dropdown">
											<a href="javascript:void(0);" class="menu-item menu-more dropbtn" title="" > 链接 
											</a>
											<div class="menu-more-content dropdown-content"><a href="https://space.bilibili.com/499533333" title="" target="_blank" rel="noopener"> BiliBili </a><a href="https://www.youtube.com/c/itcodingman" title="" target="_blank" rel="noopener"> YouTube </a></div>
										</div>
									<span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Coding Man"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.jpg"
        data-srcset="/logo.jpg, /logo.jpg 1.5x, /logo.jpg 2x"
        data-sizes="auto"
        alt="/logo.jpg"
        title="/logo.jpg" />Coding Man</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/"> 文章 
								</a><a class="menu-item" href="/tags/"> 标签 
								</a><a class="menu-item" href="/categories/"> 分类 
								</a><a class="menu-item" href="/search/"><i class='fas fa-fw fa-search'></i> 搜索 
								</a>
								<div class="dropdown">
									<a href="javascript:void(0);" class="menu-item menu-more dropbtn" title="" > 链接 
									</a>
									<div class="menu-more-content dropdown-content"><a href="https://space.bilibili.com/499533333" title="" target="_blank" rel="noopener"> BiliBili </a><a href="https://www.youtube.com/c/itcodingman" title="" target="_blank" rel="noopener"> YouTube </a></div>
								</div>
							<a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container">
                    <div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Spring 中的注解：@Autowired、@Resource 和 @Inject</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>codingman</a></span>&nbsp;<span class="post-category">included in <a href="/categories/spring/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Spring</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2020-04-08">2020-04-08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;6936 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;14 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-概述"><strong>1. 概述</strong></a></li>
    <li><a href="#2-resource注解"><strong>2. @Resource注解</strong></a>
      <ul>
        <li><a href="#21-现场注入"><strong>2.1 现场注入</strong></a></li>
        <li><a href="#22-setter注入"><strong>2.2 Setter注入</strong></a></li>
      </ul>
    </li>
    <li><a href="#3-inject注解"><strong>3. @Inject注解</strong></a>
      <ul>
        <li><a href="#31-现场注入"><strong>3.1 现场注入</strong></a></li>
        <li><a href="#32-setter注入"><strong>3.2 Setter注入</strong></a></li>
      </ul>
    </li>
    <li><a href="#4-autowired注解"><strong>4. @Autowired注解</strong></a>
      <ul>
        <li><a href="#41-现场注入"><strong>4.1 现场注入</strong></a></li>
        <li><a href="#42-setter注入"><strong>4.2. Setter注入</strong></a></li>
      </ul>
    </li>
    <li><a href="#5-应用这些注释"><strong>5. 应用这些注释</strong></a>
      <ul>
        <li><a href="#51-通过多态性在应用程序范围内使用单例"><strong>5.1 通过多态性在应用程序范围内使用单例</strong></a></li>
        <li><a href="#52-通过多态进行细粒度的应用程序行为配置"><strong>5.2 通过多态进行细粒度的应用程序行为配置</strong></a></li>
        <li><a href="#53-依赖注入应该由-jakarta-ee-平台单独处理"><strong>5.3 依赖注入应该由 Jakarta EE 平台单独处理</strong></a></li>
        <li><a href="#54-依赖注入应该由-spring-框架单独处理"><strong>5.4 依赖注入应该由 Spring 框架单独处理</strong></a></li>
        <li><a href="#55-讨论总结"><strong>5.5 讨论总结</strong></a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="1-概述"><strong>1. 概述</strong></h2>
<p>在本 Spring Framework 教程中，我们将演示如何使用与依赖注入相关的注解，即*@Resource*、<em>@Inject</em>和*@Autowired*注解。这些注解为类提供了一种声明性的方式来解决依赖关系：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Autowired</span> 
</span></span><span class="line"><span class="cl"><span class="n">ArbitraryClass</span> <span class="n">arbObject</span><span class="o">;</span>
</span></span></code></pre></div><p>与直接实例化它们相反（命令式）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ArbitraryClass</span> <span class="n">arbObject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArbitraryClass</span><span class="o">();</span>
</span></span></code></pre></div><p>三个注解中有两个属于 Java 扩展包：<em>javax.annotation.Resource</em>和<em>javax.inject.Inject</em>。<em>@Autowired</em>注解属于<em>org.springframework.beans.factory.annotation</em>包。</p>
<p>这些注解中的每一个都可以通过字段注入或 setter 注入来解决依赖关系。我们将使用一个简化但实用的示例来演示三个注释之间的区别，基于每个注释所采用的执行路径。</p>
<p>示例将重点介绍如何在集成测试期间使用三个注入注解。测试所需的依赖可以是任意文件或任意类。</p>
<h2 id="2-resource注解"><strong>2. @Resource注解</strong></h2>
<p><em>@Resource</em>注释是<a href="https://jcp.org/en/jsr/detail?id=250" target="_blank" rel="noopener noreffer">JSR-250</a>注释集合的一部分，并与 Jakarta EE 一起打包。此注解具有以下执行路径，按优先级列出：</p>
<ol>
<li>按名称匹配</li>
<li>按类型匹配</li>
<li>按限定词匹配</li>
</ol>
<p>这些执行路径适用于 setter 和 field 注入。</p>
<h3 id="21-现场注入"><strong>2.1 现场注入</strong></h3>
<p><em>我们可以通过使用@Resource</em>注释来注释实例变量来通过字段注入来解决依赖关系。</p>
<p><strong>2.1.1 按名称匹配</strong></p>
<p>我们将使用以下集成测试来演示按名称匹配字段注入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestResourceNameType</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldResourceInjectionIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Resource</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">File</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenResourceAnnotation_WhenOnField_ThenDependencyValid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">defaultFile</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;namedFile.txt&#34;</span><span class="o">,</span> <span class="n">defaultFile</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>让我们看一下代码。在<em>FieldResourceInjectionTest</em>集成测试中，在第 7 行，我们通过将 bean 名称作为属性值传递给*@Resource*注释来按名称解析依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Resource</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">File</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span></code></pre></div><p>此配置将使用按名称匹配执行路径解析依赖关系。我们必须在<em>ApplicationContextTestResourceNameType</em>应用程序上下文中定义 bean <em>namedFile 。</em></p>
<p>注意 bean id 和对应的引用属性值必须匹配：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestResourceNameType</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">File</span> <span class="nf">namedFile</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">File</span> <span class="n">namedFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;namedFile.txt&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">namedFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>如果我们未能在应用程序上下文中定义 bean，它将导致<em>org.springframework.beans.factory.NoSuchBeanDefinitionException</em>被抛出。我们可以通过更改<em>ApplicationContextTestResourceNameType应用程序上下文中传递给**@Bean</em>注解的属性值，或者更改<em>FieldResourceInjectionTest</em>集成测试中传递给*@Resource*注解的属性值来证明这一点。</p>
<h4 id="212-按类型匹配"><strong>2.1.2 按类型匹配</strong></h4>
<p>为了演示按类型匹配的执行路径，我们只删除<em>FieldResourceInjectionTest</em>集成测试第 7 行的属性值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">File</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span></code></pre></div><p>然后我们再次运行测试。</p>
<p>测试仍然会通过，因为如果*@Resource*注释没有接收到 bean 名称作为属性值，Spring 框架将继续进行下一级优先级，按类型匹配，以尝试解决依赖关系。</p>
<h4 id="213-按限定词匹配"><strong>2.1.3 按限定词匹配</strong></h4>
<p>为了演示 match-by-qualifier 执行路径，将修改集成测试场景，以便在<em>ApplicationContextTestResourceQualifier</em>应用程序上下文中定义两个 bean：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestResourceQualifier</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#34;defaultFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">File</span> <span class="nf">defaultFile</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">File</span> <span class="n">defaultFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;defaultFile.txt&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">File</span> <span class="nf">namedFile</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">File</span> <span class="n">namedFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;namedFile.txt&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">namedFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们将使用<em>QualifierResourceInjectionTest</em>集成测试来演示逐个匹配的依赖关系解析。在这种情况下，需要将特定的 bean 依赖注入到每个引用变量中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestResourceQualifier</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QualifierResourceInjectionIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">File</span> <span class="n">dependency1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">File</span> <span class="n">dependency2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenResourceAnnotation_WhenField_ThenDependency1Valid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">dependency1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;defaultFile.txt&#34;</span><span class="o">,</span> <span class="n">dependency1</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenResourceQualifier_WhenField_ThenDependency2Valid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">dependency2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;namedFile.txt&#34;</span><span class="o">,</span> <span class="n">dependency2</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当我们运行集成测试时，会抛出<em>org.springframework.beans.factory.NoUniqueBeanDefinitionException 。**这会发生，因为应用程序上下文将找到两个类型为File</em>的 bean 定义，并且不知道哪个 bean 应该解决依赖关系。</p>
<p>要解决这个问题，我们需要参考<em>QualifierResourceInjectionTest</em>集成测试的第 7 行到第 10 行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">File</span> <span class="n">dependency1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">File</span> <span class="n">dependency2</span><span class="o">;</span>
</span></span></code></pre></div><p>我们必须添加以下代码行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;defaultFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span></code></pre></div><p>使代码块如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;defaultFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">File</span> <span class="n">dependency1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">File</span> <span class="n">dependency2</span><span class="o">;</span>
</span></span></code></pre></div><p>当我们再次运行集成测试时，它应该会通过。我们的测试表明，即使我们在应用程序上下文中定义了多个 bean，我们也可以使用*@Qualifier*注释通过允许我们将特定的依赖项注入到一个类中来消除任何混淆。</p>
<h3 id="22-setter注入"><strong>2.2 Setter注入</strong></h3>
<p>在字段上注入依赖项时所采用的执行路径也适用于基于 setter 的注入。</p>
<h4 id="221-按名称匹配"><strong>2.2.1 按名称匹配</strong></h4>
<p>唯一的区别是<em>MethodResourceInjectionTest</em>集成测试有一个 setter 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestResourceNameType</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodResourceInjectionIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">File</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Resource</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">setDefaultFile</span><span class="o">(</span><span class="n">File</span> <span class="n">defaultFile</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">defaultFile</span> <span class="o">=</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenResourceAnnotation_WhenSetter_ThenDependencyValid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">defaultFile</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;namedFile.txt&#34;</span><span class="o">,</span> <span class="n">defaultFile</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们通过注解引用变量的相应 setter 方法，通过 setter 注入来解决依赖关系。然后我们将bean依赖的名称作为属性值传递给*@Resource*注解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">File</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Resource</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">setDefaultFile</span><span class="o">(</span><span class="n">File</span> <span class="n">defaultFile</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">.</span><span class="na">defaultFile</span> <span class="o">=</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在本例中，我们将重用<em>namedFile</em> bean 依赖项。bean 名称和相应的属性值必须匹配。</p>
<p>当我们运行集成测试时，它将通过。</p>
<p>为了让我们验证按名称匹配执行路径是否解决了依赖关系，我们需要将传递给*@Resource<em>注解的属性值更改为我们选择的值并再次运行测试。这一次，测试将失败并出现</em>NoSuchBeanDefinitionException*。</p>
<h4 id="222-按类型匹配"><strong>2.2.2 按类型匹配</strong></h4>
<p>为了演示基于 setter、按类型匹配的执行，我们将使用<em>MethodByTypeResourceTest</em>集成测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestResourceNameType</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodByTypeResourceIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">File</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">setDefaultFile</span><span class="o">(</span><span class="n">File</span> <span class="n">defaultFile</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">defaultFile</span> <span class="o">=</span> <span class="n">defaultFile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenResourceAnnotation_WhenSetter_ThenValidDependency</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">defaultFile</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;namedFile.txt&#34;</span><span class="o">,</span> <span class="n">defaultFile</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当我们运行这个测试时，它会通过。</p>
<p>为了让我们验证按类型匹配的执行路径是否解决了<em>File</em>依赖关系，我们需要将<em>defaultFile</em>变量的类类型更改为另一个类类型，如<em>String</em>。然后我们可以再次执行<em>MethodByTypeResourceTest</em>集成测试，这次会抛出<em>NoSuchBeanDefinitionException 。</em></p>
<p>该异常验证是否确实使用了按类型匹配来解决<em>文件</em>依赖关系。NoSuchBeanDefinitionException<em>确认</em>引用变量名称不需要与 bean 名称匹配。相反，依赖解析取决于 bean 的类类型与引用变量的类类型匹配。</p>
<h4 id="223-按限定词匹配"><strong>2.2.3 按限定词匹配</strong></h4>
<p>我们将使用<em>MethodByQualifierResourceTest</em>集成测试来演示 match-by-qualifier 执行路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestResourceQualifier</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodByQualifierResourceIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">File</span> <span class="n">arbDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">File</span> <span class="n">anotherArbDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenResourceQualifier_WhenSetter_ThenValidDependencies</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">      <span class="n">assertNotNull</span><span class="o">(</span><span class="n">arbDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;namedFile.txt&#34;</span><span class="o">,</span> <span class="n">arbDependency</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">anotherArbDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;defaultFile.txt&#34;</span><span class="o">,</span> <span class="n">anotherArbDependency</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setArbDependency</span><span class="o">(</span><span class="n">File</span> <span class="n">arbDependency</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">arbDependency</span> <span class="o">=</span> <span class="n">arbDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Resource</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;defaultFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAnotherArbDependency</span><span class="o">(</span><span class="n">File</span> <span class="n">anotherArbDependency</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">anotherArbDependency</span> <span class="o">=</span> <span class="n">anotherArbDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们的测试表明，即使我们在应用程序上下文中定义了特定类型的多个 bean 实现，我们也可以使用*@Qualifier<em>注释和</em>@Resource*注释来解决依赖关系。</p>
<p>类似于基于字段的依赖注入，如果我们在一个应用上下文中定义多个bean，我们必须使用 <em>@Qualifier</em> 注解来指定使用哪个bean来解析依赖，否则会抛出<em>NoUniqueBeanDefinitionException 。</em></p>
<h2 id="3-inject注解"><strong>3. @Inject注解</strong></h2>
<p>@Inject注解属于<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="noopener noreffer">JSR-330</a>注解集合。此注解具有以下执行路径，按优先级列出：</p>
<ol>
<li>按类型匹配</li>
<li>按预选赛匹配</li>
<li>按名称匹配</li>
</ol>
<p>这些执行路径适用于 setter 和 field 注入。为了让我们访问*@Inject<em>注解，我们必须将</em>javax.inject*库声明为 Gradle 或 Maven 依赖项。</p>
<p>对于 Gradle：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">testCompile group: &#39;javax.inject&#39;, name: &#39;javax.inject&#39;, version: &#39;1&#39;
</span></span></code></pre></div><p>对于 Maven：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>javax.inject<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>javax.inject<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><h3 id="31-现场注入"><strong>3.1 现场注入</strong></h3>
<h4 id="311-按类型匹配"><strong>3.1.1 按类型匹配</strong></h4>
<p>我们将修改集成测试示例以使用另一种类型的依赖项，即<em>ArbitraryDependency</em>类。<em>ArbitraryDependency</em>类依赖仅作为一个简单的依赖，并没有进一步的意义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArbitraryDependency</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#34;Arbitrary Dependency&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">label</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这是有问题的<em>FieldInjectTest</em>集成测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestInjectType</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldInjectIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">fieldInjectDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenInjectAnnotation_WhenOnField_ThenValidDependency</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">fieldInjectDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Arbitrary Dependency&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">fieldInjectDependency</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>与*@Resource注解首先按名称解析依赖关系不同，@* <em>Inject</em>注解的默认行为是按类型解析依赖关系。</p>
<p>这意味着即使类引用变量名称与 bean 名称不同，依赖关系仍然会被解析，前提是 bean 是在应用程序上下文中定义的。请注意以下测试中引用变量名称的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">fieldInjectDependency</span><span class="o">;</span>
</span></span></code></pre></div><p>与应用程序上下文中配置的 bean 名称不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">ArbitraryDependency</span> <span class="nf">injectDependency</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ArbitraryDependency</span> <span class="n">injectDependency</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArbitraryDependency</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">injectDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当我们执行测试时，我们能够解决依赖关系。</p>
<h4 id="312-按限定词匹配"><strong>3.1.2 按限定词匹配</strong></h4>
<p>如果一个特定的类类型有多个实现，并且某个类需要一个特定的 bean，该怎么办？让我们修改集成测试示例，使其需要另一个依赖项。</p>
<p>在此示例中，我们将<em>ArbitraryDependency</em>类（在按类型匹配示例中使用）进行子类化，以创建<em>AnotherArbitraryDependency</em>类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnotherArbitraryDependency</span> <span class="kd">extends</span> <span class="n">ArbitraryDependency</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#34;Another Arbitrary Dependency&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">label</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>每个测试用例的目标是确保我们将每个依赖项正确地注入每个引用变量中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">defaultDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">namedDependency</span><span class="o">;</span>
</span></span></code></pre></div><p>我们可以使用<em>FieldQualifierInjectTest</em>集成测试来演示限定符匹配：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestInjectQualifier</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldQualifierInjectIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">defaultDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">namedDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenInjectQualifier_WhenOnField_ThenDefaultFileValid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">defaultDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Arbitrary Dependency&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">defaultDependency</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenInjectQualifier_WhenOnField_ThenNamedFileValid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">defaultDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Another Arbitrary Dependency&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">namedDependency</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>如果我们在应用程序上下文中有多个特定类的实现，并且<em>FieldQualifierInjectTest</em>集成测试尝试以下面列出的方式注入依赖项，则会抛出<em>NoUniqueBeanDefinitionException ：</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Inject</span> 
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">defaultDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Inject</span> 
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">namedDependency</span><span class="o">;</span>
</span></span></code></pre></div><p>抛出这个异常是 Spring 框架指出某个类有多个实现的方式，它对使用哪一个感到困惑。为了阐明混淆，我们可以转到<em>FieldQualifierInjectTest</em>集成测试的第 7 行和第 10 行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">defaultDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">namedDependency</span><span class="o">;</span>
</span></span></code></pre></div><p>我们可以将所需的 bean 名称传递给*@Qualifier<em>注释，我们将其与</em>@Inject*注释一起使用。这就是代码块现在的样子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;defaultFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">defaultDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;namedFile&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">namedDependency</span><span class="o">;</span>
</span></span></code></pre></div><p><em>@Qualifier</em>注解在接收 bean 名称时要求严格匹配。我们必须确保将 bean 名称正确传递给<em>Qualifier</em>，否则将抛出*NoUniqueBeanDefinitionException 。*如果我们再次运行测试，它应该会通过。</p>
<h4 id="313-按名称匹配"><strong>3.1.3 按名称匹配</strong></h4>
<p>用于演示按名称匹配的<em>FieldByNameInjectTest</em>集成测试类似于按类型匹配执行路径。唯一的区别是现在我们需要一个特定的 bean，而不是一个特定的类型。在此示例中，我们再次对<em>ArbitraryDependency</em>类进行子类化以生成<em>YetAnotherArbitraryDependency</em>类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">YetAnotherArbitraryDependency</span> <span class="kd">extends</span> <span class="n">ArbitraryDependency</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#34;Yet Another Arbitrary Dependency&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">label</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>为了演示按名称匹配的执行路径，我们将使用以下集成测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestInjectName</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldByNameInjectIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Inject</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Named</span><span class="o">(</span><span class="s">&#34;yetAnotherFieldInjectDependency&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">yetAnotherFieldInjectDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenInjectQualifier_WhenSetOnField_ThenDependencyValid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">yetAnotherFieldInjectDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Yet Another Arbitrary Dependency&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">yetAnotherFieldInjectDependency</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们列出应用程序上下文：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestInjectName</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ArbitraryDependency</span> <span class="nf">yetAnotherFieldInjectDependency</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArbitraryDependency</span> <span class="n">yetAnotherFieldInjectDependency</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="k">new</span> <span class="n">YetAnotherArbitraryDependency</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">yetAnotherFieldInjectDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>如果我们运行集成测试，它将通过。</p>
<p>为了验证我们是否通过按名称匹配执行路径注入了依赖项，我们需要将传入*@Named注释的值**yetAnotherFieldInjectDependency<em>更改为我们选择的另一个名称。当我们再次运行测试时，会抛出</em>NoSuchBeanDefinitionException 。*</p>
<h3 id="32-setter注入"><strong>3.2 Setter注入</strong></h3>
<p><em>@Inject</em>注解的基于设置器的注入类似于用于基于*@Resource*设置器的注入的方法。我们不是注释引用变量，而是注释相应的 setter 方法。基于字段的依赖注入所遵循的执行路径也适用于基于 setter 的注入。</p>
<h2 id="4-autowired注解"><strong>4. @Autowired注解</strong></h2>
<p><em>@Autowired</em>注解的行为类似于*@Inject<em>注解。唯一的区别是</em>@Autowired*注解是 Spring 框架的一部分。<em>此注解与@Inject</em>注解具有相同的执行路径，按优先顺序列出：</p>
<ol>
<li>按类型匹配</li>
<li>按限定词匹配</li>
<li>按名称匹配</li>
</ol>
<p>这些执行路径适用于 setter 和 field 注入。</p>
<h3 id="41-现场注入"><strong>4.1 现场注入</strong></h3>
<h4 id="411-按类型匹配"><strong>4.1.1 按类型匹配</strong></h4>
<p>用于演示*@Autowired<em>按类型匹配执行路径的集成测试示例将类似于用于演示</em>@Inject<em>按类型匹配执行路径的测试。我们使用以下</em>FieldAutowiredTest<em>集成测试来演示使用</em>@Autowired*注释的按类型匹配：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestAutowiredType</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldAutowiredIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">fieldDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenAutowired_WhenSetOnField_ThenDependencyResolved</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">fieldDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Arbitrary Dependency&#34;</span><span class="o">,</span> <span class="n">fieldDependency</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们列出了此集成测试的应用程序上下文：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestAutowiredType</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ArbitraryDependency</span> <span class="nf">autowiredFieldDependency</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArbitraryDependency</span> <span class="n">autowiredFieldDependency</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="k">new</span> <span class="n">ArbitraryDependency</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">autowiredFieldDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们使用此集成测试来证明按类型匹配优先于其他执行路径。<em>注意FieldAutowiredTest</em>集成测试第 8 行的引用变量名称：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">fieldDependency</span><span class="o">;</span>
</span></span></code></pre></div><p>这与应用程序上下文中的 bean 名称不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">ArbitraryDependency</span> <span class="nf">autowiredFieldDependency</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ArbitraryDependency</span> <span class="n">autowiredFieldDependency</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="n">ArbitraryDependency</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">autowiredFieldDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当我们运行测试时，它应该通过了。</p>
<p>为了确认依赖确实是使用 match-by-type 执行路径解决的，我们需要更改<em>fieldDependency</em>引用变量的类型并再次运行集成测试。这一次，<em>FieldAutowiredTest</em>集成测试将失败，并引发<em>NoSuchBeanDefinitionException</em>。这验证了我们使用了按类型匹配来解决依赖关系。</p>
<h4 id="412-按限定词匹配"><strong>4.1.2 按限定词匹配</strong></h4>
<p>如果我们遇到在应用程序上下文中定义了多个 bean 实现的情况怎么办：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestAutowiredQualifier</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ArbitraryDependency</span> <span class="nf">autowiredFieldDependency</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArbitraryDependency</span> <span class="n">autowiredFieldDependency</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="k">new</span> <span class="n">ArbitraryDependency</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">autowiredFieldDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ArbitraryDependency</span> <span class="nf">anotherAutowiredFieldDependency</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArbitraryDependency</span> <span class="n">anotherAutowiredFieldDependency</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="k">new</span> <span class="n">AnotherArbitraryDependency</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">anotherAutowiredFieldDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>如果我们执行以下<em>FieldQualifierAutowiredTest</em>集成测试，将抛出<em>NoUniqueBeanDefinitionException ：</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestAutowiredQualifier</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldQualifierAutowiredIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">fieldDependency1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">fieldDependency2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenAutowiredQualifier_WhenOnField_ThenDep1Valid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">fieldDependency1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Arbitrary Dependency&#34;</span><span class="o">,</span> <span class="n">fieldDependency1</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenAutowiredQualifier_WhenOnField_ThenDep2Valid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">fieldDependency2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Another Arbitrary Dependency&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">fieldDependency2</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>异常是由于应用程序上下文中定义的两个 bean 引起的歧义。Spring 框架不知道哪个 bean 依赖项应该自动装配到哪个引用变量。我们可以通过在<em>FieldQualifierAutowiredTest</em>集成测试的第 7 行和第 10 行添加*@Qualifier*注释来解决此问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">FieldDependency</span> <span class="n">fieldDependency1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">FieldDependency</span> <span class="n">fieldDependency2</span><span class="o">;</span>
</span></span></code></pre></div><p>使代码块如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;autowiredFieldDependency&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">FieldDependency</span> <span class="n">fieldDependency1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;anotherAutowiredFieldDependency&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">FieldDependency</span> <span class="n">fieldDependency2</span><span class="o">;</span>
</span></span></code></pre></div><p>当我们再次运行测试时，它将通过。</p>
<h4 id="413-按名称匹配"><strong>4.1.3 按名称匹配</strong></h4>
<p><em>我们将使用相同的集成测试场景来演示使用@Autowired</em>注释注入字段依赖项的按名称匹配执行路径。当按名称自动装配依赖项时，<em>@ComponentScan</em>注释必须与应用程序上下文<em>ApplicationContextTestAutowiredName</em>一起使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ComponentScan</span><span class="o">(</span><span class="n">basePackages</span><span class="o">={</span><span class="s">&#34;com.codingman.dependency&#34;</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestAutowiredName</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们使用*@ComponentScan<em>注解在包中搜索已使用@Component 注解进行注解的Java</em>类*。例如，在应用程序上下文中，将扫描<em>com.codingman.dependency</em>包以查找已使用*@Component<em>注释进行注释的类。在这种情况下，Spring 框架必须检测带有</em>@Component<em>注解的</em>ArbitraryDependency*类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="o">(</span><span class="n">value</span><span class="o">=</span><span class="s">&#34;autowiredFieldDependency&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArbitraryDependency</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#34;Arbitrary Dependency&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">label</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>传递到*@Component<em>注释的属性值</em>autowiredFieldDependency<em>告诉 Spring 框架</em>ArbitraryDependency<em>类是一个名为</em>autowiredFieldDependency<em>的组件。为了让</em>@Autowired<em>注解通过名称解析依赖，组件名称必须与</em>FieldAutowiredNameTest*集成测试中定义的字段名称相对应；请参考第8行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringJUnit4ClassRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@ContextConfiguration</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">loader</span><span class="o">=</span><span class="n">AnnotationConfigContextLoader</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">classes</span><span class="o">=</span><span class="n">ApplicationContextTestAutowiredName</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldAutowiredNameIntegrationTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ArbitraryDependency</span> <span class="n">autowiredFieldDependency</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenAutowiredAnnotation_WhenOnField_ThenDepValid</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">autowiredFieldDependency</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&#34;Arbitrary Dependency&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">autowiredFieldDependency</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当我们运行<em>FieldAutowiredNameTest</em>集成测试时，它将通过。</p>
<p>但是我们怎么知道*@Autowired<em>注解确实调用了按名称匹配的执行路径呢？我们可以将引用变量</em>autowiredFieldDependency*的名称更改为我们选择的另一个名称，然后再次运行测试。</p>
<p>这一次，测试将失败并抛出<em>NoUniqueBeanDefinitionException</em>。类似的检查是将*@Component<em>属性值</em>autowiredFieldDependency<em>更改为我们选择的另一个值并再次运行测试。NoUniqueBeanDefinitionException</em>也会*被抛出。</p>
<p>这个异常证明如果我们使用不正确的 bean 名称，将找不到有效的 bean。这就是我们知道调用了按名称匹配执行路径的方式。</p>
<h3 id="42-setter注入"><strong>4.2. Setter注入</strong></h3>
<p><em>@Autowired</em>注解的基于设置器的注入类似于为基于*@Resource*设置器的注入演示的方法。<em>我们不是用@Inject</em>注解来注解引用变量，而是注解对应的setter。基于字段的依赖注入所遵循的执行路径也适用于基于 setter 的注入。</p>
<h2 id="5-应用这些注释"><strong>5. 应用这些注释</strong></h2>
<p>这就提出了应该使用哪种注释以及在什么情况下使用的问题。这些问题的答案取决于相关应用程序面临的设计场景，以及开发人员希望如何利用基于每个注释的默认执行路径的多态性。</p>
<h3 id="51-通过多态性在应用程序范围内使用单例"><strong>5.1 通过多态性在应用程序范围内使用单例</strong></h3>
<p>如果设计是这样的应用程序行为基于接口或抽象类的实现，并且这些行为在整个应用程序中使用，那么我们可以使用*@Inject<em>或</em>@Autowired*注解。</p>
<p>这种方法的好处是，当我们升级应用程序或应用补丁来修复错误时，可以将类换出，而对整体应用程序行为的负面影响最小。在这种情况下，主要的默认执行路径是按类型匹配。</p>
<h3 id="52-通过多态进行细粒度的应用程序行为配置"><strong>5.2 通过多态进行细粒度的应用程序行为配置</strong></h3>
<p>如果设计使得应用程序具有复杂的行为，每个行为都基于不同的接口/抽象类，并且这些实现中的每一个的使用因应用程序而异，那么我们可以使用*@Resource*注解。在这种情况下，主要的默认执行路径是按名称匹配。</p>
<h3 id="53-依赖注入应该由-jakarta-ee-平台单独处理"><strong>5.3 依赖注入应该由 Jakarta EE 平台单独处理</strong></h3>
<p>如果 Jakarta EE 平台而不是 Spring 注入所有依赖项的设计要求，那么选择是在*@Resource<em>注释和</em>@Inject*注释之间进行选择。我们应该根据需要哪个默认执行路径来缩小两个注释之间的最终决定。</p>
<h3 id="54-依赖注入应该由-spring-框架单独处理"><strong>5.4 依赖注入应该由 Spring 框架单独处理</strong></h3>
<p>如果要求所有依赖项都由 Spring 框架处理，则唯一的选择是*@Autowired*注释。</p>
<h3 id="55-讨论总结"><strong>5.5 讨论总结</strong></h3>
<p>下表总结了我们的讨论。</p>
<table>
<thead>
<tr>
<th style="text-align:left">场景</th>
<th>@Resource</th>
<th>@Inject</th>
<th>@Autowired</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">通过多态性在应用程序范围内使用单例</td>
<td>✗</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td style="text-align:left">通过多态进行细粒度的应用程序行为配置</td>
<td>✔</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td style="text-align:left">依赖注入由 Jakarta EE 平台单独处理</td>
<td>✔</td>
<td>✔</td>
<td>✗</td>
</tr>
<tr>
<td style="text-align:left">依赖注入由 Spring Framework 单独处理</td>
<td>✗</td>
<td>✗</td>
<td>✔</td>
</tr>
<tr>
<td style="text-align:left">&quot;</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-07-20</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="http://itcodingman.github.io/spring_annotations_resource_inject_autowire/" data-title="Spring 中的注解：@Autowired、@Resource 和 @Inject" data-hashtags="Spring DI,Spring Core Basics"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://itcodingman.github.io/spring_annotations_resource_inject_autowire/" data-hashtag="Spring DI"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="http://itcodingman.github.io/spring_annotations_resource_inject_autowire/" data-title="Spring 中的注解：@Autowired、@Resource 和 @Inject"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://itcodingman.github.io/spring_annotations_resource_inject_autowire/" data-title="Spring 中的注解：@Autowired、@Resource 和 @Inject"><i data-svg-src="/lib/simple-icons/icons/line.min.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://itcodingman.github.io/spring_annotations_resource_inject_autowire/" data-title="Spring 中的注解：@Autowired、@Resource 和 @Inject"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/spring-di/">Spring DI</a>,&nbsp;<a href="/tags/spring-core-basics/">Spring Core Basics</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/securing_a_restful_web_service_with_spring_security/" class="prev" rel="prev" title="Spring REST API &#43; OAuth2 &#43; Angular"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Spring REST API + OAuth2 + Angular</a>
            <a href="/spring_autowired/" class="next" rel="next" title="Spring @Autowired 指南">Spring @Autowired 指南<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">codingman</a></span></div>
        </div>
    </footer>
        </div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-XH3B2JPQ1K', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-XH3B2JPQ1K" async></script></body>
</html>
