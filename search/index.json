[{"categories":["Spring","Persistence"],"contents":"Grails 3 和 GORM 简介 1. 概述 这是对 Grails 3 和 GORM 的快速介绍。 我们当然会使用 Groovy，并且——隐含地——该框架还使用 Hibernate 来实现 ORM，Spring 框架用于依赖注入，SiteMash 用于布局和主题等。 2.数据源配置 我们无需指定任何显式数据源配置即可开始——默认情况下，Grails 使用 HSQLDB 数据库作为开发和测试环境。 但是如果你想改变这些默认值，你可以在application.yml中定义你选择的数据源： environments: development: dataSource: driverClassName : \u0026#34;com.mysql.jdbc.Driver\u0026#34; url : \u0026#34;jdbc:mysql://localhost:8080/test\u0026#34; dialect : org.hibernate.dialect.MySQL5InnoDBDialect 同样，我们可以在这里创建多个环境，如果需要，可以在开发旁边。 3. Domain Grails 能够基于数据库配置中的dbCreate属性为我们的域类创建数据库结构。 让我们在这里定义这些域类之一： Class User { String userName String password String email String age static constraints = { userName blank: false, unique: true password size: 5..10, blank: false email email: true, blank: true } } 请注意我们如何在模型中指定我们的验证约束，这使事情变得干净整洁，并且没有注释。 当实体被持久化时，这些约束将由 Grails 自动检查，如果这些约束中的任何一个被破坏，框架将抛出适当的验证异常。 我们还可以在模型的映射属性中指定 GORM 映射： static mapping = { sort \u0026#34;userName\u0026#34; } 现在，如果我们调用User.list() - 我们将返回按*用户名*****排序的结果。 我们当然可以通过将排序传递给列表 API 来实现相同的结果： User.list(sort: \u0026#34;userName\u0026#34;) 4. CRUD 操作 当我们看 API 操作时，脚手架在开始时扮演着非常有趣的角色；它允许您为域类生成基本的 CRUD API，包括：  必要的视图 标准 CRUD 操作的控制器操作 两种类型：动态和静态  以下是动态脚手架的工作原理： class UserController { static scaffold = true } 只需编写这一行代码，框架就会在运行时生成 7 个方法：显示、编辑、删除、创建、保存和更新。这些将作为该特定域实体的 API 发布。 静态脚手架示例：  使用脚手架创建视图：“ grails generate-views User ” 使用脚手架创建控制器和视图：“ grails generate-controller User ” 要在单个命令中创建所有内容，请使用：“ grails generate-all User ”  这些命令将为该特定域对象自动生成必要的管道。 现在让我们快速了解如何使用这些操作——例如，对于我们的用户域对象。 **创建新的“用户”**记录： def user = new User(username: \u0026#34;test\u0026#34;, password: \u0026#34;test123\u0026#34;, email: \u0026#34;a@a.com\u0026#34;, age: 14) user.save() 要获取单个记录： def user = User.get(1) 此获取API 将以可编辑模式检索域对象。对于只读模式，我们可以使用read API： def user = User.read(1) 要更新现有记录： def user = User.get(1) user.userName = \u0026#34;testUpdate\u0026#34; user.age = 20 user.save() 以及对现有记录的简单删除操作： def user = User.get(1) user.delete() 5. GORM 查询 5.1 find 让我们从find API 开始： def user = User.find(\u0026#34;from User as u where u.username = \u0026#39;test\u0026#39; \u0026#34;) 我们还可以使用不同的语法来传递参数： def user = User.find(\u0026#34;from User as u where u.username?\u0026#34;, [\u0026#39;test\u0026#39;]) 我们还可以使用命名参数： def user = User.find(\u0026#34;from User as u where u.username=?\u0026#34;, [username: \u0026#39;test\u0026#39;]) 5.2. findBy Grails 提供了一个动态查找工具，它使用域属性在运行时执行查询并返回第一个匹配记录： def user = User.findByUsername(\u0026#34;test\u0026#34;) user = User.findByUsernameAndAge(\u0026#34;test\u0026#34;, 20) user = User.findByUsernameLike(\u0026#34;tes\u0026#34;) user = User.findByUsernameAndAgeNotEquals(\u0026#34;test\u0026#34;, \u0026#34;100\u0026#34;) 你可以在这里找到更多的表达方式。 5.3. Criteria 我们还可以使用一些灵活的标准检索数据： def user = User.find { username == \u0026#34;test\u0026#34;} def user = User.createCriteria() def results = user.list { like (\u0026#34;userName\u0026#34;, \u0026#34;te%\u0026#34;) and { between(\u0026#34;age\u0026#34;, 10, 20) } order(\u0026#34;userName\u0026#34;, \u0026#34;desc\u0026#34;) } 这里有一个说明——当使用条件查询时，使用“{}”而不是“()”。 5.4. 执行查询/更新 GORM 还支持 HQL 查询语法——用于读取操作： def user = User.executeQuery( \u0026#34;select u.userName from User u where u.userName = ?\u0026#34;, [\u0026#39;test\u0026#39;]) 以及写操作： def user = User.executeUpdate(\u0026#34;delete User u where u.username =?\u0026#34;, [\u0026#39;test\u0026#39;]) ","permalink":"http://itcodingman.github.io/grails-gorm-tutorial/","tags":[],"title":"Grails 3 和 GORM 简介"},{"categories":["Spring"],"contents":"Spring Batch 简介 1. 概述 在本教程中，我们将看一个实用的、以代码为中心的 Spring Batch 介绍。Spring Batch 是一个处理框架，专为作业的稳健执行而设计。 它的当前版本 4.3 支持 Spring 5 和 Java 8。它还适应 JSR-352，这是用于批处理的新 Java 规范。 以下是该框架的一些有趣且实用的用例。 2. 工作流程基础 Spring Batch 遵循传统的批处理架构，其中作业存储库执行调度和与作业交互的工作。 一个作业可以有多个步骤。每个步骤通常遵循读取数据、处理数据和写入数据的顺序。 当然，这里的框架将为我们完成大部分繁重的工作——尤其是在处理作业的低级持久性工作时——使用sqlite作为作业存储库。 2.1 示例用例 我们将在这里处理的简单用例是将一些金融交易数据从 CSV 迁移到 XML。 输入文件的结构非常简单。 它包含每行的交易，由用户名、用户 ID、交易日期和金额组成： username, userid, transaction_date, transaction_amount ann, 1234, 31/10/2015, 10000 bob, 2134, 3/12/2015, 12321 robin, 3134, 2/02/2015, 23411 3. Maven POM 本项目需要的依赖有spring core、spring batch和sqlite jdbc connector： \u0026lt;!-- SQLite database driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.xerial\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sqlite-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-oxm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.batch\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-batch-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4. Spring批处理配置 我们要做的第一件事是使用 XML 配置 Spring Batch： \u0026lt;!-- connect to SQLite database --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;org.sqlite.JDBC\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:sqlite:repository.sqlite\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- create job-meta tables automatically --\u0026gt; \u0026lt;jdbc:initialize-database data-source=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;jdbc:script location=\u0026#34;org/springframework/batch/core/schema-drop-sqlite.sql\u0026#34; /\u0026gt; \u0026lt;jdbc:script location=\u0026#34;org/springframework/batch/core/schema-sqlite.sql\u0026#34; /\u0026gt; \u0026lt;/jdbc:initialize-database\u0026gt; \u0026lt;!-- stored job-meta in memory --\u0026gt; \u0026lt;!-- \u0026lt;bean id=\u0026#34;jobRepository\u0026#34; class=\u0026#34;org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- stored job-meta in database --\u0026gt; \u0026lt;bean id=\u0026#34;jobRepository\u0026#34; class=\u0026#34;org.springframework.batch.core.repository.support.JobRepositoryFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;databaseType\u0026#34; value=\u0026#34;sqlite\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class= \u0026#34;org.springframework.batch.support.transaction.ResourcelessTransactionManager\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;jobLauncher\u0026#34; class=\u0026#34;org.springframework.batch.core.launch.support.SimpleJobLauncher\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;jobRepository\u0026#34; ref=\u0026#34;jobRepository\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 当然，也可以使用 Java 配置： @Configuration @EnableBatchProcessing public class SpringConfig { @Value(\u0026#34;org/springframework/batch/core/schema-drop-sqlite.sql\u0026#34;) private Resource dropReopsitoryTables; @Value(\u0026#34;org/springframework/batch/core/schema-sqlite.sql\u0026#34;) private Resource dataReopsitorySchema; @Bean public DataSource dataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\u0026#34;org.sqlite.JDBC\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:sqlite:repository.sqlite\u0026#34;); return dataSource; } @Bean public DataSourceInitializer dataSourceInitializer(DataSource dataSource) throws MalformedURLException { ResourceDatabasePopulator databasePopulator = new ResourceDatabasePopulator(); databasePopulator.addScript(dropReopsitoryTables); databasePopulator.addScript(dataReopsitorySchema); databasePopulator.setIgnoreFailedDrops(true); DataSourceInitializer initializer = new DataSourceInitializer(); initializer.setDataSource(dataSource); initializer.setDatabasePopulator(databasePopulator); return initializer; } private JobRepository getJobRepository() throws Exception { JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean(); factory.setDataSource(dataSource()); factory.setTransactionManager(getTransactionManager()); factory.afterPropertiesSet(); return (JobRepository) factory.getObject(); } private PlatformTransactionManager getTransactionManager() { return new ResourcelessTransactionManager(); } public JobLauncher getJobLauncher() throws Exception { SimpleJobLauncher jobLauncher = new SimpleJobLauncher(); jobLauncher.setJobRepository(getJobRepository()); jobLauncher.afterPropertiesSet(); return jobLauncher; } } 5. Spring Batch 作业配置 现在让我们为 CSV 到 XML 工作编写工作描述： \u0026lt;import resource=\u0026#34;spring.xml\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;record\u0026#34; class=\u0026#34;com.codingman.spring_batch_intro.model.Transaction\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemReader\u0026#34; class=\u0026#34;org.springframework.batch.item.file.FlatFileItemReader\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;input/record.csv\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;lineMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.batch.item.file.mapping.DefaultLineMapper\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lineTokenizer\u0026#34;\u0026gt; \u0026lt;bean class= \u0026#34;org.springframework.batch.item.file.transform.DelimitedLineTokenizer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;names\u0026#34; value=\u0026#34;username,userid,transactiondate,amount\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;fieldSetMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.codingman.spring_batch_intro.service.RecordFieldSetMapper\u0026#34; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemProcessor\u0026#34; class=\u0026#34;com.codingman.spring_batch_intro.service.CustomItemProcessor\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;itemWriter\u0026#34; class=\u0026#34;org.springframework.batch.item.xml.StaxEventItemWriter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;file:xml/output.xml\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;marshaller\u0026#34; ref=\u0026#34;recordMarshaller\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;rootTagName\u0026#34; value=\u0026#34;transactionRecord\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;recordMarshaller\u0026#34; class=\u0026#34;org.springframework.oxm.jaxb.Jaxb2Marshaller\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;classesToBeBound\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;com.codingman.spring_batch_intro.model.Transaction\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;batch:job id=\u0026#34;firstBatchJob\u0026#34;\u0026gt; \u0026lt;batch:step id=\u0026#34;step1\u0026#34;\u0026gt; \u0026lt;batch:tasklet\u0026gt; \u0026lt;batch:chunk reader=\u0026#34;itemReader\u0026#34; writer=\u0026#34;itemWriter\u0026#34; processor=\u0026#34;itemProcessor\u0026#34; commit-interval=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;/batch:chunk\u0026gt; \u0026lt;/batch:tasklet\u0026gt; \u0026lt;/batch:step\u0026gt; \u0026lt;/batch:job\u0026gt; 这是类似的基于 Java 的作业配置： public class SpringBatchConfig { @Autowired private JobBuilderFactory jobs; @Autowired private StepBuilderFactory steps; @Value(\u0026#34;input/record.csv\u0026#34;) private Resource inputCsv; @Value(\u0026#34;file:xml/output.xml\u0026#34;) private Resource outputXml; @Bean public ItemReader\u0026lt;Transaction\u0026gt; itemReader() throws UnexpectedInputException, ParseException { FlatFileItemReader\u0026lt;Transaction\u0026gt; reader = new FlatFileItemReader\u0026lt;Transaction\u0026gt;(); DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer(); String[] tokens = { \u0026#34;username\u0026#34;, \u0026#34;userid\u0026#34;, \u0026#34;transactiondate\u0026#34;, \u0026#34;amount\u0026#34; }; tokenizer.setNames(tokens); reader.setResource(inputCsv); DefaultLineMapper\u0026lt;Transaction\u0026gt; lineMapper = new DefaultLineMapper\u0026lt;Transaction\u0026gt;(); lineMapper.setLineTokenizer(tokenizer); lineMapper.setFieldSetMapper(new RecordFieldSetMapper()); reader.setLineMapper(lineMapper); return reader; } @Bean public ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; itemProcessor() { return new CustomItemProcessor(); } @Bean public ItemWriter\u0026lt;Transaction\u0026gt; itemWriter(Marshaller marshaller) throws MalformedURLException { StaxEventItemWriter\u0026lt;Transaction\u0026gt; itemWriter = new StaxEventItemWriter\u0026lt;Transaction\u0026gt;(); itemWriter.setMarshaller(marshaller); itemWriter.setRootTagName(\u0026#34;transactionRecord\u0026#34;); itemWriter.setResource(outputXml); return itemWriter; } @Bean public Marshaller marshaller() { Jaxb2Marshaller marshaller = new Jaxb2Marshaller(); marshaller.setClassesToBeBound(new Class[] { Transaction.class }); return marshaller; } @Bean protected Step step1(ItemReader\u0026lt;Transaction\u0026gt; reader, ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; processor, ItemWriter\u0026lt;Transaction\u0026gt; writer) { return steps.get(\u0026#34;step1\u0026#34;).\u0026lt;Transaction, Transaction\u0026gt; chunk(10) .reader(reader).processor(processor).writer(writer).build(); } @Bean(name = \u0026#34;firstBatchJob\u0026#34;) public Job job(@Qualifier(\u0026#34;step1\u0026#34;) Step step1) { return jobs.get(\u0026#34;firstBatchJob\u0026#34;).start(step1).build(); } } 现在我们有了整个配置，让我们分解它并开始讨论它。 5.1 使用ItemReader读取数据并创建对象 首先，我们配置了cvsFileItemReader ，它将从record.csv中读取数据并将其转换为Transaction对象： @SuppressWarnings(\u0026#34;restriction\u0026#34;) @XmlRootElement(name = \u0026#34;transactionRecord\u0026#34;) public class Transaction { private String username; private int userId; private LocalDateTime transactionDate; private double amount; /* getters and setters for the attributes */ @Override public String toString() { return \u0026#34;Transaction [username=\u0026#34; + username + \u0026#34;, userId=\u0026#34; + userId + \u0026#34;, transactionDate=\u0026#34; + transactionDate + \u0026#34;, amount=\u0026#34; + amount + \u0026#34;]\u0026#34;; } } 为此，它使用自定义映射器： public class RecordFieldSetMapper implements FieldSetMapper\u0026lt;Transaction\u0026gt; { public Transaction mapFieldSet(FieldSet fieldSet) throws BindException { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;d/M/yyy\u0026#34;); Transaction transaction = new Transaction(); transaction.setUsername(fieldSet.readString(\u0026#34;username\u0026#34;)); transaction.setUserId(fieldSet.readInt(1)); transaction.setAmount(fieldSet.readDouble(3)); String dateString = fieldSet.readString(2); transaction.setTransactionDate(LocalDate.parse(dateString, formatter).atStartOfDay()); return transaction; } } 5.2 使用ItemProcessor处理数据 我们创建了自己的项目处理器CustomItemProcessor。这不会处理与事务对象相关的任何内容。 它所做的只是将来自 reader 的原始对象传递给 writer： public class CustomItemProcessor implements ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; { public Transaction process(Transaction item) { return item; } } 5.3 使用ItemWriter将对象写入 FS 最后，我们将此事务存储到位于xml/output.xml的 XML 文件中： \u0026lt;bean id=\u0026#34;itemWriter\u0026#34; class=\u0026#34;org.springframework.batch.item.xml.StaxEventItemWriter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;file:xml/output.xml\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;marshaller\u0026#34; ref=\u0026#34;recordMarshaller\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;rootTagName\u0026#34; value=\u0026#34;transactionRecord\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 5.4 配置批处理作业 因此，我们所要做的就是使用batch:job语法将这些点与作业连接起来。 注意提交间隔。这是在将批次提交给itemWriter之前要保存在内存中的事务数。 它将在内存中保存事务直到该点（或直到遇到输入数据的结尾）： \u0026lt;batch:job id=\u0026#34;firstBatchJob\u0026#34;\u0026gt; \u0026lt;batch:step id=\u0026#34;step1\u0026#34;\u0026gt; \u0026lt;batch:tasklet\u0026gt; \u0026lt;batch:chunk reader=\u0026#34;itemReader\u0026#34; writer=\u0026#34;itemWriter\u0026#34; processor=\u0026#34;itemProcessor\u0026#34; commit-interval=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;/batch:chunk\u0026gt; \u0026lt;/batch:tasklet\u0026gt; \u0026lt;/batch:step\u0026gt; \u0026lt;/batch:job\u0026gt; 5.5 运行批处理作业 现在让我们设置并运行所有内容： public class App { public static void main(String[] args) { // Spring Java config  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(SpringConfig.class); context.register(SpringBatchConfig.class); context.refresh(); JobLauncher jobLauncher = (JobLauncher) context.getBean(\u0026#34;jobLauncher\u0026#34;); Job job = (Job) context.getBean(\u0026#34;firstBatchJob\u0026#34;); System.out.println(\u0026#34;Starting the batch job\u0026#34;); try { JobExecution execution = jobLauncher.run(job, new JobParameters()); System.out.println(\u0026#34;Job Status : \u0026#34; + execution.getStatus()); System.out.println(\u0026#34;Job completed\u0026#34;); } catch (Exception e) { e.printStackTrace(); System.out.println(\u0026#34;Job failed\u0026#34;); } } } ","permalink":"http://itcodingman.github.io/introduction-to-spring-batch/","tags":["Spring Batch"],"title":"Spring Batch 简介"},{"categories":["REST","Spring"],"contents":"使用 Spring 的 REST 错误处理 1. 概述 本教程将说明**如何使用 Spring 为 REST API 实现异常处理。**我们还将获得一些历史概览，并查看不同版本引入了哪些新选项。 *在 Spring 3.2 之前，在 Spring MVC 应用程序中处理异常的两种主要方法是HandlerExceptionResolver或@ExceptionHandler*注解。**两者都有一些明显的缺点。 从 3.2 开始，我们有了@ControllerAdvice*注解*来解决前两个解决方案的局限性，并在整个应用程序中促进统一的异常处理。 现在Spring 5 引入了ResponseStatusException 类——一种在我们的 REST API 中进行基本错误处理的快速方法。 所有这些都有一个共同点：它们很好地处理了**关注点的分离。**该应用程序可以正常抛出异常以指示某种失败，然后将单独处理。 最后，我们将看到 Spring Boot 带来了什么，以及我们如何配置它以满足我们的需求。 2.方案一：Controller级@ExceptionHandler 第一个解决方案适用于*@Controller级别。我们将定义一个方法来处理异常并使用@ExceptionHandler* 对其进行注释： public class FooController{ //...  @ExceptionHandler({ CustomException1.class, CustomException2.class }) public void handleException() { //  } } 这种方法有一个主要缺点：**@ExceptionHandler注释方法仅对特定的 Controller 有效，**而不是对整个应用程序全局有效。当然，将它添加到每个控制器使其不太适合一般的异常处理机制。 我们可以通过让所有控制器扩展一个基本控制器类来解决这个限制。 然而，这种解决方案对于应用程序来说可能是个问题，无论出于何种原因，这是不可能的。例如，控制器可能已经从另一个基类扩展而来，该基类可能在另一个 jar 中或不可直接修改，或者它们本身可能不可直接修改。 接下来，我们将研究另一种解决异常处理问题的方法——一种全局的并且不包括对现有工件（例如控制器）的任何更改。 3. 解决方案2：HandlerExceptionResolver 第二种解决方案是定义一个HandlerExceptionResolver。这将解决应用程序抛出的任何异常。它还将允许我们在 REST API 中实现统一的异常处理机制。 在使用自定义解析器之前，让我们回顾一下现有的实现。 3.1 ExceptionHandlerExceptionResolver 这个解析器是在 Spring 3.1 中引入的，默认情况下在DispatcherServlet中启用。这实际上是前面介绍的*@ExceptionHandler*机制如何工作的核心组件。 3.2. DefaultHandlerExceptionResolver 这个解析器是在 Spring 3.0 中引入的，默认情况下它在DispatcherServlet中启用。 它用于解决相应的HTTP 状态代码的标准 Spring 异常，即客户端错误4xx和服务器错误5xx状态代码。这是它处理的 Spring 异常的完整列表以及它们如何映射到状态代码。 虽然它确实正确设置了响应的状态代码，但一个**限制是它没有为响应的正文设置任何内容。**对于 REST API——状态码实际上不足以呈现给客户端——响应也必须有一个主体，以允许应用程序提供有关失败的附加信息。 这可以通过ModelAndView配置视图分辨率和渲染错误内容来解决，但该解决方案显然不是最优的。这就是为什么 Spring 3.2 引入了一个更好的选项，我们将在后面的部分讨论。 3.3. ResponseStatusExceptionResolver 这个解析器也在 Spring 3.0 中引入，默认情况下在DispatcherServlet中启用。 它的主要职责是使用自定义异常上可用的*@ResponseStatus*注释并将这些异常映射到 HTTP 状态代码。 这样的自定义异常可能如下所示： @ResponseStatus(value = HttpStatus.NOT_FOUND) public class MyResourceNotFoundException extends RuntimeException { public MyResourceNotFoundException() { super(); } public MyResourceNotFoundException(String message, Throwable cause) { super(message, cause); } public MyResourceNotFoundException(String message) { super(message); } public MyResourceNotFoundException(Throwable cause) { super(cause); } } 与DefaultHandlerExceptionResolver相同，此解析器在处理响应主体的方式上受到限制——它确实将状态代码映射到响应上，但主体仍然为空。 3.4 自定义HandlerExceptionResolver DefaultHandlerExceptionResolver和ResponseStatusExceptionResolver的组合在为 Spring RESTful 服务提供良好的错误处理机制方面大有帮助。如前所述，缺点是无法控制响应的主体。 理想情况下，我们希望能够输出 JSON 或 XML，具体取决于客户端要求的格式（通过Accept标头）。 仅此一项就证明了创建一个新的自定义异常解析器是合理的： @Component public class RestResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver { @Override protected ModelAndView doResolveException( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { try { if (ex instanceof IllegalArgumentException) { return handleIllegalArgument( (IllegalArgumentException) ex, response, handler); } ... } catch (Exception handlerException) { logger.warn(\u0026#34;Handling of [\u0026#34; + ex.getClass().getName() + \u0026#34;] resulted in Exception\u0026#34;, handlerException); } return null; } private ModelAndView handleIllegalArgument(IllegalArgumentException ex, HttpServletResponse response) throws IOException { response.sendError(HttpServletResponse.SC_CONFLICT); String accept = request.getHeader(HttpHeaders.ACCEPT); ... return new ModelAndView(); } } 这里要注意的一个细节是我们可以访问请求本身，因此我们可以考虑客户端发送的Accept标头的值。 例如，如果客户端请求application/json，那么在出现错误情况的情况下，我们希望确保返回一个使用application/json编码的响应正文。 另一个重要的实现细节是我们返回一个 ModelAndView——这是响应的主体，它允许我们在上面设置任何必要的东西。 这种方法是一种一致且易于配置的机制，用于 Spring REST 服务的错误处理。 但是，它确实有局限性：它与低级HtttpServletResponse 交互并适合使用ModelAndView的旧 MVC 模型，因此仍有改进的空间。 4. 解决方案3：@ControllerAdvice Spring 3.2通过@ControllerAdvice注释支持全局@ExceptionHandler。 这启用了一种脱离旧 MVC 模型并利用ResponseEntity以及@ExceptionHandler的类型安全性和灵活性的机制： @ControllerAdvice public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(value = { IllegalArgumentException.class, IllegalStateException.class }) protected ResponseEntity\u0026lt;Object\u0026gt; handleConflict( RuntimeException ex, WebRequest request) { String bodyOfResponse = \u0026#34;This should be application specific\u0026#34;; return handleExceptionInternal(ex, bodyOfResponse, new HttpHeaders(), HttpStatus.CONFLICT, request); } } @ControllerAdvice注解允许我们将之前的多个分散的@ExceptionHandler整合到一个单一的全局错误处理组件中。 实际的机制非常简单，但也非常灵活：  它使我们可以完全控制响应的主体以及状态代码。 它提供了多个异常到同一方法的映射，以便一起处理。 它充分利用了较新的 RESTful ResposeEntity响应。  这里要记住的一件事是将使用@ExceptionHandler声明的异常与用作方法参数的异常相匹配。 如果这些不匹配，编译器不会抱怨——没有理由应该抱怨——Spring 也不会抱怨。 但是，当在运行时实际抛出异常时，异常解析机制将失败，并显示： java.lang.IllegalStateException: No suitable resolver for argument [0] [type=...] HandlerMethod details: ... 5. 解决方案4：ResponseStatusException（Spring 5及以上） Spring 5 引入了ResponseStatusException类。 我们可以创建它的一个实例，提供一个HttpStatus以及一个可选的reason和cause： @GetMapping(value = \u0026#34;/{id}\u0026#34;) public Foo findById(@PathVariable(\u0026#34;id\u0026#34;) Long id, HttpServletResponse response) { try { Foo resourceById = RestPreconditions.checkFound(service.findOne(id)); eventPublisher.publishEvent(new SingleResourceRetrievedEvent(this, response)); return resourceById; } catch (MyResourceNotFoundException exc) { throw new ResponseStatusException( HttpStatus.NOT_FOUND, \u0026#34;Foo Not Found\u0026#34;, exc); } } 使用ResponseStatusException有什么好处？  非常适合原型设计：我们可以非常快速地实施基本解决方案。 一种类型，多种状态码：一种异常类型可能导致多种不同的响应。与@ExceptionHandler相比，这减少了紧密耦合。 我们不必创建尽可能多的自定义异常类。 我们可以更好地控制异常处理，因为可以通过编程方式创建异常。  那么权衡呢？  没有统一的异常处理方式：与提供全局方法的@ControllerAdvice相比，执行一些应用程序范围的约定更加困难。 代码复制：我们可能会发现自己在多个控制器中复制代码。  我们还应该注意到，可以在一个应用程序中组合不同的方法。 例如，我们可以 全局 实现@ControllerAdvice ，也可以在本地实现ResponseStatusException 。 但是，我们需要小心：如果可以以多种方式处理同一个异常，我们可能会注意到一些令人惊讶的行为。一种可能的约定是始终以一种方式处理一种特定类型的异常。 有关更多详细信息和更多示例，请参阅我们的ResponseStatusException教程。 6. 处理Spring Security中的访问被拒绝 当经过身份验证的用户尝试访问他没有足够权限访问的资源时，会发生访问被拒绝。 6.1 REST 和方法级安全性 最后，让我们看看如何处理由方法级安全注解（@PreAuthorize、@PostAuthorize和@Secure ）引发的 Access Denied 异常。 当然，我们也会使用前面讨论过的全局异常处理机制来处理AccessDeniedException： @ControllerAdvice public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler({ AccessDeniedException.class }) public ResponseEntity\u0026lt;Object\u0026gt; handleAccessDeniedException( Exception ex, WebRequest request) { return new ResponseEntity\u0026lt;Object\u0026gt;( \u0026#34;Access denied message here\u0026#34;, new HttpHeaders(), HttpStatus.FORBIDDEN); } ... } 7. Spring Boot 支持 Spring Boot 提供了一个 ErrorController实现以合理的方式处理错误。 简而言之，它为浏览器提供后备错误页面（又名 Whitelabel 错误页面），并为 RESTful、非 HTML 请求提供 JSON 响应： { \u0026#34;timestamp\u0026#34;: \u0026#34;2019-01-17T16:12:45.977+0000\u0026#34;, \u0026#34;status\u0026#34;: 500, \u0026#34;error\u0026#34;: \u0026#34;Internal Server Error\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Error processing the request!\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/my-endpoint-with-exceptions\u0026#34; } 像往常一样，Spring Boot 允许使用属性配置这些功能：  server.error.whitelabel.enabled：可用于禁用 Whitelabel 错误页面并依赖 servlet 容器提供 HTML 错误消息 server.error.include-stacktrace：始终 具有值；在 HTML 和 JSON 默认响应中包含堆栈跟踪 server.error.include-message： 从 2.3 版本开始，Spring Boot 在响应中隐藏了message字段，以避免泄露敏感信息；我们可以使用这个属性和一个 always 值来启用它  除了这些属性之外，我们还可以为 /error 提供我们自己的视图解析器映射，覆盖 Whitelabel 页面。 我们还可以通过在上下文中包含一个ErrorAttributes bean 来自定义我们想要在响应中显示的属性 。我们可以扩展 Spring Boot 提供的 DefaultErrorAttributes类以使事情变得更简单： @Component public class MyCustomErrorAttributes extends DefaultErrorAttributes { @Override public Map\u0026lt;String, Object\u0026gt; getErrorAttributes( WebRequest webRequest, ErrorAttributeOptions options) { Map\u0026lt;String, Object\u0026gt; errorAttributes = super.getErrorAttributes(webRequest, options); errorAttributes.put(\u0026#34;locale\u0026#34;, webRequest.getLocale() .toString()); errorAttributes.remove(\u0026#34;error\u0026#34;); //...  return errorAttributes; } } 如果我们想进一步定义（或覆盖）应用程序将如何处理特定内容类型的错误，我们可以注册一个 ErrorController bean。 同样，我们可以利用 Spring Boot 提供的默认 BasicErrorController 来帮助我们。 例如，假设我们想要自定义我们的应用程序如何处理在 XML 端点中触发的错误。我们所要做的就是使用 @RequestMapping定义一个公共方法，并声明它产生application/xml媒体类型： @Component public class MyErrorController extends BasicErrorController { public MyErrorController( ErrorAttributes errorAttributes, ServerProperties serverProperties) { super(errorAttributes, serverProperties.getError()); } @RequestMapping(produces = MediaType.APPLICATION_XML_VALUE) public ResponseEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; xmlError(HttpServletRequest request) { // ...  } } 注意：这里我们仍然依赖于server.error.我们可能已经在项目中定义的引导属性，这些属性绑定到ServerProperties bean。 ","permalink":"http://itcodingman.github.io/exception-handling-for-rest-with-spring/","tags":[],"title":"使用 Spring 的 REST 错误处理"},{"categories":["Spring"],"contents":"Spring中的构造函数依赖注入 1. 简介 可以说，现代软件设计最重要的开发原则之一是*依赖注入 (DI)，*它很自然地源于另一个至关重要的原则：模块化。 这个快速教程将探讨 Spring 中一种特定类型的 DI 技术，称为基于构造函数的依赖注入， 简单地说，意味着我们在实例化时将所需的组件传递给一个类。 首先，我们需要在pom.xml中导入spring-context依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后我们需要设置一个配置文件。根据偏好，该文件可以是 POJO 或 XML 文件。 2. 基于注解的配置 Java 配置文件看起来类似于带有一些附加注释的 Java 对象： @Configuration @ComponentScan(\u0026#34;com.codingman.constructordi\u0026#34;) public class Config { @Bean public Engine engine() { return new Engine(\u0026#34;v8\u0026#34;, 5); } @Bean public Transmission transmission() { return new Transmission(\u0026#34;sliding\u0026#34;); } } 在这里，我们使用注解来通知 Spring 运行时这个类提供了 bean 定义（@Bean注解），并且包com.codingman.spring需要执行上下文扫描以查找其他 bean。接下来，我们定义一个Car类： @Component public class Car { @Autowired public Car(Engine engine, Transmission transmission) { this.engine = engine; this.transmission = transmission; } } Spring在进行包扫描时会遇到我们的Car类，并会通过调用@Autowired带注释的构造函数来初始化它的实例。 通过调用Config类的@Bean注解方法，我们将获得Engine 和 Transmission的实例。最后，我们需要使用我们的 POJO 配置来引导ApplicationContext： ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); Car car = context.getBean(Car.class); 3. 隐式构造函数注入 从 Spring 4.3 开始，具有单个构造函数的类可以省略@Autowired注释。这是一个很好的便利和样板删除。 最重要的是，同样从 4.3 开始，我们可以在@Configuration注释类中利用基于构造函数的注入。另外，如果这样的类只有一个构造函数，我们也可以省略@Autowired注解。 4. 基于 XML 的配置 使用基于构造函数的依赖注入配置 Spring 运行时的另一种方法是使用 XML 配置文件： \u0026lt;bean id=\u0026#34;toyota\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Car\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;engine\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; ref=\u0026#34;transmission\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;engine\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Engine\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;v4\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transmission\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Transmission\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;sliding\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 请注意，constructor-arg可以接受文字值或对另一个 bean 的引用，并且可以提供可选的显式索引和类型。我们可以使用Type和index属性来解决歧义（例如，如果构造函数采用相同类型的多个参数）。  name属性也可以用于 xml 到 java 变量的匹配，但是你的代码必须在编译时使用调试标志。  在这种情况下，我们需要使用ClassPathXmlApplicationContext引导我们的 Spring 应用程序上下文： ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;codingman.xml\u0026#34;); Car car = context.getBean(Car.class); 5. 优点和缺点 与字段注入相比，构造函数注入有一些优点。 第一个好处是可测试性。假设我们要对一个使用字段注入的 Spring bean 进行单元测试： public class UserService { @Autowired private UserRepository userRepository; } 在UserService 实例的构建过程中，我们无法初始化userRepository 状态。实现这一点的唯一方法是通过完全打破封装的反射 API此外，与简单的构造函数调用相比，生成的代码将不太安全。 此外，使用字段注入，我们无法强制执行类级别的不变量，因此可能会在没有正确初始化userRepository的情况下拥有 UserService 实例。因此，我们可能会在这里和那里遇到随机 的NullPointerException 。此外，使用构造函数注入，更容易构建不可变组件。 此外，从 OOP 的角度来看，使用构造函数创建对象实例更为自然。 另一方面，构造函数注入的主要缺点是其冗长，尤其是当 bean 具有少量依赖项时。有时这可能是因祸得福，因为我们可能会更加努力地将依赖项的数量保持在最低限度。 ","permalink":"http://itcodingman.github.io/constructor-injection-in-spring/","tags":["Spring Core Basics","Spring DI"],"title":"Spring中的构造函数依赖注入"},{"categories":["Spring"],"contents":"Spring 控制反转和依赖注入简介 1. 概述 在本教程中，我们将介绍 IoC（控制反转）和 DI（依赖注入）的概念，并了解它们在 Spring 框架中是如何实现的。 2. 什么是控制反转？ 控制反转是软件工程中的一项原则，它将对象或程序部分的控制转移到容器或框架中。我们最常在面向对象编程的上下文中使用它。 与我们的自定义代码调用库的传统编程相比，IoC 使框架能够控制程序的流程并调用我们的自定义代码。为了实现这一点，框架使用内置附加行为的抽象。如果我们想添加自己的行为，我们需要扩展框架的类或插入我们自己的类。 这种架构的优点是：  将任务的执行与其实现分离 更容易在不同的实现之间切换 程序的更大模块化 通过隔离组件或模拟其依赖关系并允许组件通过合约进行通信，从而更轻松地测试程序  我们可以通过各种机制来实现控制反转，例如：策略设计模式、服务定位器模式、工厂模式和依赖注入（DI）。 接下来我们将研究 DI。 3. 什么是依赖注入？ 依赖注入是我们可以用来实现 IoC 的一种模式，其中被反转的控制是设置对象的依赖关系。 将对象与其他对象连接起来，或将对象“注入”到其他对象中，是由汇编程序完成的，而不是由对象本身完成的。 以下是我们如何在传统编程中创建对象依赖项： public class Store { private Item item; public Store() { item = new ItemImpl1(); } } 在上面的示例中，我们需要在Store类本身中实例化Item接口的实现。 通过使用 DI，我们可以重写示例，而无需指定我们想要的Item的实现： public class Store { private Item item; public Store(Item item) { this.item = item; } } 在接下来的部分中，我们将了解如何通过元数据提供Item的实现。 IoC 和 DI 都是简单的概念，但它们对我们构建系统的方式有着深远的影响，因此它们非常值得充分理解。 4. Spring IoC 容器 IoC 容器是实现 IoC 的框架的共同特征。 在 Spring 框架中，接口 ApplicationContext代表 IoC 容器。Spring 容器负责实例化、配置和组装称为bean的对象，以及管理它们的生命周期。 Spring 框架提供了ApplicationContext接口的几种实现：ClassPathXmlApplicationContext和FileSystemXmlApplicationContext用于独立应用程序，WebApplicationContext用于 Web 应用程序。 为了组装 bean，容器使用配置元数据，它可以是 XML 配置或注解的形式。 这是手动实例化容器的一种方法： ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); 要在上面的示例中设置项目属性，我们可以使用元数据。然后容器将读取此元数据并在运行时使用它来组装 bean。 Spring 中的依赖注入可以通过构造函数、setter 或字段来完成。 5. 基于构造函数的依赖注入 在基于构造函数的依赖注入的情况下，容器将调用带有参数的构造函数，每个参数代表我们要设置的依赖项。 Spring 主要按类型解析每个参数，然后是属性名称，以及用于消歧的索引。让我们使用注解查看 bean 的配置及其依赖项： @Configuration public class AppConfig { @Bean public Item item1() { return new ItemImpl1(); } @Bean public Store store() { return new Store(item1()); } } @Configuration注解表明该类是 bean 定义的来源。我们还可以将它添加到多个配置类中。 我们在方法上使用*@Bean*注解来定义一个 bean。如果我们不指定自定义名称，那么 bean 名称将默认为方法名称。 对于具有默认单例范围的 bean，Spring 首先检查 bean 的缓存实例是否已经存在，如果不存在则只创建一个新实例。如果我们使用原型作用域，容器会为每个方法调用返回一个新的 bean 实例。 创建 bean 配置的另一种方法是通过 XML 配置： \u0026lt;bean id=\u0026#34;item1\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;ItemImpl1\u0026#34; index=\u0026#34;0\u0026#34; name=\u0026#34;item\u0026#34; ref=\u0026#34;item1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 6. 基于 Setter 的依赖注入 对于基于 setter 的 DI，容器会在调用无参数构造函数或无参数静态工厂方法实例化 bean 后调用我们类的 setter 方法。让我们使用注解创建这个配置： @Bean public Store store() { Store store = new Store(); store.setItem(item1()); return store; } 我们还可以将 XML 用于相同的 bean 配置： \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;item\u0026#34; ref=\u0026#34;item1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 我们可以为同一个 bean 组合基于构造函数和基于 setter 的注入类型。Spring 文档建议对强制依赖项使用基于构造函数的注入，对可选依赖项使用基于 setter 的注入。 7. 基于字段的依赖注入 对于基于字段的 DI，我们可以通过使用*@Autowired*注释标记依赖项来注入依赖项： public class Store { @Autowired private Item item; } 在构造Store对象时，如果没有构造函数或 setter 方法来注入Item bean，容器将使用反射将Item注入Store。 我们也可以使用XML 配置来实现这一点。 这种方法可能看起来更简单、更干净，但我们不建议使用它，因为它有一些缺点，例如：  该方法使用反射来注入依赖项，这比基于构造函数或基于 setter 的注入成本更高。 使用这种方法继续添加多个依赖项真的很容易。如果我们使用构造函数注入，具有多个参数会让我们认为该类做了不止一件事，这可能违反单一职责原则。  更多关于*@Autowired*注解的信息可以在Wiring In Spring文章中找到。 8. 自动装配依赖 Wiring允许 Spring 容器通过检查已定义的 bean 来自动解决协作 bean 之间的依赖关系。 使用 XML 配置自动装配 bean 有四种模式：  no：默认值——这意味着 bean 不使用自动装配，我们必须显式命名依赖项。 byName：自动装配是基于属性的名称完成的，因此 Spring 将查找与需要设置的属性名称相同的 bean。 byType：类似于byName自动装配，仅基于属性的类型。这意味着 Spring 将寻找具有相同类型属性的 bean 来设置。如果该类型的 bean 不止一个，框架会抛出异常。 constructor：自动装配是基于构造函数参数完成的，这意味着 Spring 将寻找与构造函数参数具有相同类型的 bean。  例如，让我们将上面定义的item1 bean 按类型自动装配到store bean 中： @Bean(autowire = Autowire.BY_TYPE) public class Store { private Item item; public setItem(Item item){ this.item = item; } } 我们还可以使用*@Autowired*注解注入 bean，以便按类型自动装配： public class Store { @Autowired private Item item; } 如果有多个相同类型的 bean，我们可以使用*@Qualifier*注解按名称引用一个 bean： public class Store { @Autowired @Qualifier(\u0026#34;item1\u0026#34;) private Item item; } 现在让我们通过 XML 配置按类型自动装配 bean： \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 接下来，让我们通过 XML将一个名为item的 bean 按名称注入到store bean 的**item属性中： \u0026lt;bean id=\u0026#34;item\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 我们还可以通过构造函数参数或设置器显式定义依赖项来覆盖自动装配。 9. 延迟初始化 Bean 默认情况下，容器在初始化期间创建和配置所有单例 bean。为了避免这种情况，我们可以在 bean 配置中使用值为true的延迟初始化属性： \u0026lt;bean id=\u0026#34;item1\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; lazy-init=\u0026#34;true\u0026#34; /\u0026gt; 因此，item1 bean 只会在第一次被请求时被初始化，而不是在启动时被初始化。这样做的好处是更快的初始化时间，但代价是在请求 bean 之前我们不会发现任何配置错误，这可能是应用程序已经运行后的几个小时甚至几天。 ","permalink":"http://itcodingman.github.io/inversion-control-and-dependency-injection-in-spring/","tags":["Spring Core Basics","Spring DI"],"title":"Spring 控制反转和依赖注入简介"},{"categories":["Spring Security","REST"],"contents":"使用 Spring Security 的 REST 服务的基本和摘要式身份验证 1. 概述 本文讨论如何在REST API 的相同 URI 结构上设置基本身份验证和摘要式身份验证。在之前的文章中，我们讨论了另一种保护 REST 服务的方法——基于表单的身份验证，因此基本和摘要式身份验证是自然的选择，也是更 RESTful 的一种。 2. 基本认证的配置 基于表单的身份验证不适合 RESTful 服务的主要原因是 Spring Security 将使用 Sessions——这当然是服务器上的状态，因此REST 中的无状态约束实际上被忽略了。 我们将从设置基本身份验证开始——首先我们从主**安全元素中删除旧的自定义入口点和过滤器： \u0026lt;http create-session=\u0026#34;stateless\u0026#34;\u0026gt; \u0026lt;intercept-url pattern=\u0026#34;/api/admin/**\u0026#34; access=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;http-basic /\u0026gt; \u0026lt;/http\u0026gt; 请注意如何使用单个配置行添加对基本身份验证的支持 -  - 它处理BasicAuthenticationFilter和BasicAuthenticationEntryPoint的创建和连接。 2.1 满足无状态约束——摆脱会话 RESTful 架构风格的主要限制之一是客户端-服务器通信是完全无状态的，正如原始论文所述：  5.1.3 无状态 我们接下来为客户端-服务器交互添加一个约束：通信本质上必须是无状态的，如第 3.4.3 节（图 5-3）中的客户端-无状态-服务器（CSS）样式，这样从客户端到的每个请求服务器必须包含理解请求所需的所有信息，并且不能利用服务器上存储的任何上下文。因此，会话状态完全保留在客户端上。  服务端Session的概念在 Spring Security 中是一个由来已久的概念，直到现在完全移除它一直很困难，尤其是在使用命名空间进行配置的情况下。 然而，Spring Security为命名空间配置增加了一个用于创建会话的新无状态选项，这有效地保证了 Spring 不会创建或使用任何会话。这个新选项的作用是完全从安全过滤器链中删除所有与会话相关的过滤器，确保为每个请求执行身份验证。 3. 摘要认证的配置 从前面的配置开始，设置摘要认证所需的过滤器和入口点将被定义为 bean。然后，摘要入口点将覆盖由\u0026lt;http-basic\u0026gt;在幕后创建的入口点。最后，自定义摘要过滤器将被引入安全过滤器链中，使用安全命名空间的after语义将其直接定位在基本身份验证过滤器之后。 \u0026lt;http create-session=\u0026#34;stateless\u0026#34; entry-point-ref=\u0026#34;digestEntryPoint\u0026#34;\u0026gt; \u0026lt;intercept-url pattern=\u0026#34;/api/admin/**\u0026#34; access=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;http-basic /\u0026gt; \u0026lt;custom-filter ref=\u0026#34;digestFilter\u0026#34; after=\u0026#34;BASIC_AUTH_FILTER\u0026#34; /\u0026gt; \u0026lt;/http\u0026gt; \u0026lt;beans:bean id=\u0026#34;digestFilter\u0026#34; class= \u0026#34;org.springframework.security.web.authentication.www.DigestAuthenticationFilter\u0026#34;\u0026gt; \u0026lt;beans:property name=\u0026#34;userDetailsService\u0026#34; ref=\u0026#34;userService\u0026#34; /\u0026gt; \u0026lt;beans:property name=\u0026#34;authenticationEntryPoint\u0026#34; ref=\u0026#34;digestEntryPoint\u0026#34; /\u0026gt; \u0026lt;/beans:bean\u0026gt; \u0026lt;beans:bean id=\u0026#34;digestEntryPoint\u0026#34; class= \u0026#34;org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint\u0026#34;\u0026gt; \u0026lt;beans:property name=\u0026#34;realmName\u0026#34; value=\u0026#34;Contacts Realm via Digest Authentication\u0026#34;/\u0026gt; \u0026lt;beans:property name=\u0026#34;key\u0026#34; value=\u0026#34;acegi\u0026#34; /\u0026gt; \u0026lt;/beans:bean\u0026gt; \u0026lt;authentication-manager\u0026gt; \u0026lt;authentication-provider\u0026gt; \u0026lt;user-service id=\u0026#34;userService\u0026#34;\u0026gt; \u0026lt;user name=\u0026#34;eparaschiv\u0026#34; password=\u0026#34;eparaschiv\u0026#34; authorities=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;user name=\u0026#34;user\u0026#34; password=\u0026#34;user\u0026#34; authorities=\u0026#34;ROLE_USER\u0026#34; /\u0026gt; \u0026lt;/user-service\u0026gt; \u0026lt;/authentication-provider\u0026gt; \u0026lt;/authentication-manager\u0026gt; 不幸的是，安全命名空间中不支持自动配置摘要式身份验证，就像可以使用\u0026lt;http-basic\u0026gt;配置基本身份验证一样。因此，必须手动定义必要的 bean 并将其连接到安全配置中。 4. 在同一个Restful服务中同时支持两种认证协议 单独的 Basic 或 Digest 身份验证可以在 Spring Security 中轻松实现；它在相同的 URI 映射上为相同的 RESTful Web 服务支持它们，这为服务的配置和测试引入了新的复杂性。 4.1 匿名请求 使用安全链中的基本过滤器和摘要过滤器，Spring Security 处理匿名请求（不包含身份验证凭据（授权HTTP 标头）的请求）的方式是，两个身份验证过滤器将找不到凭据并继续执行过滤链。然后，查看请求是如何未经过身份验证的，会抛出AccessDeniedException并在ExceptionTranslationFilter中捕获，它会启动摘要入口点，提示客户端输入凭据。 基本过滤器和摘要过滤器的职责都非常狭窄——如果它们无法识别请求中身份验证凭据的类型，它们将继续执行安全过滤器链。正因为如此，Spring Security 可以灵活地配置为支持同一 URI 上的多个身份验证协议。 当请求包含正确的身份验证凭据（基本或摘要）时，将正确使用该协议。但是，对于匿名请求，客户端只会收到摘要式身份验证凭据的提示。这是因为摘要入口点被配置为 Spring Security 链的主要和单一入口点；因此可以将摘要身份验证视为默认设置。 4.2 带有身份验证凭据的请求 带有 Basic 身份验证凭据的请求将由Authorization标头标识，该标头以前缀Basic开头。处理此类请求时，凭据将在基本身份验证过滤器中解码，并且请求将被授权。同样，带有摘要身份验证凭据的请求将使用前缀摘要作为其授权标头。 5. 测试两种场景 在使用基本或摘要进行身份验证后，测试将通过创建新资源来使用 REST 服务： @Test public void givenAuthenticatedByBasicAuth_whenAResourceIsCreated_then201IsReceived(){ // Given  // When  Response response = given() .auth().preemptive().basic( ADMIN_USERNAME, ADMIN_PASSWORD ) .contentType( HttpConstants.MIME_JSON ).body( new Foo( randomAlphabetic( 6 ) ) ) .post( paths.getFooURL() ); // Then  assertThat( response.getStatusCode(), is( 201 ) ); } @Test public void givenAuthenticatedByDigestAuth_whenAResourceIsCreated_then201IsReceived(){ // Given  // When  Response response = given() .auth().digest( ADMIN_USERNAME, ADMIN_PASSWORD ) .contentType( HttpConstants.MIME_JSON ).body( new Foo( randomAlphabetic( 6 ) ) ) .post( paths.getFooURL() ); // Then  assertThat( response.getStatusCode(), is( 201 ) ); } 请注意，使用基本身份验证的测试会抢先将凭据添加到请求中，无论服务器是否已对身份验证提出质疑。这是为了确保服务器不需要向客户端质询凭据，因为如果需要，质询将针对 Digest 凭据，因为这是默认设置。 ","permalink":"http://itcodingman.github.io/basic-and-digest-authentication-for-a-rest-api-with-spring-security/","tags":["Authentication"],"title":"使用 Spring Security 的 REST 服务的基本和摘要式身份验证"},{"categories":["Spring","REST"],"contents":"Spring中的REST分页 1. 概述 本教程将重点介绍使用 Spring MVC 和 Spring Data 在 REST API 中实现分页。 2. 页面作为资源与页面作为表示 在 RESTful 架构的上下文中设计分页时的第一个问题是，是否将页面视为实际资源或只是资源的表示。 将页面本身视为资源会带来许多问题，例如不再能够在调用之间唯一标识资源。这一点，再加上在持久层中，页面不是一个适当的实体，而是一个在必要时构建的持有者，这使得选择变得简单；页面是表示的一部分。 REST 上下文中分页设计的下一个问题是在哪里包含分页信息：  在 URI 路径中：/foo/page/1 URI 查询：/foo?page=1  请记住，页面不是 Resource，因此无法在 URI 中对页面信息进行编码。 我们将使用标准方法通过在 URI 查询中编码分页信息来解决这个问题。 3. 控制器 现在进行实施用于分页的 Spring MVC 控制器很简单： @GetMapping(params = { \u0026#34;page\u0026#34;, \u0026#34;size\u0026#34; }) public List\u0026lt;Foo\u0026gt; findPaginated(@RequestParam(\u0026#34;page\u0026#34;) int page, @RequestParam(\u0026#34;size\u0026#34;) int size, UriComponentsBuilder uriBuilder, HttpServletResponse response) { Page\u0026lt;Foo\u0026gt; resultPage = service.findPaginated(page, size); if (page \u0026gt; resultPage.getTotalPages()) { throw new MyResourceNotFoundException(); } eventPublisher.publishEvent(new PaginatedResultsRetrievedEvent\u0026lt;Foo\u0026gt;( Foo.class, uriBuilder, response, page, resultPage.getTotalPages(), size)); return resultPage.getContent(); } 在此示例中，我们 通过@RequestParam在 Controller 方法中注入两个查询参数size和page。 或者，我们可以使用Pageable对象，它自动映射page、 size和sort参数。此外，PagingAndSortingRepository实体提供了开箱即用的方法，支持使用Pageable作为参数。 我们还注入了 Http Response 和UriComponentsBuilder来帮助实现可发现性，我们通过自定义事件将其解耦。如果这不是 API 的目标，我们可以简单地删除自定义事件。 最后，注意本文的重点只是REST和web层；要深入了解分页的数据访问部分，我们可以查看这篇关于使用 Spring Data 进行分页的文章。 4. REST 分页的可发现性 在分页范围内，满足REST 的 HATEOAS 约束意味着 API 的客户端能够根据导航中的当前页面发现下一页和上一页。为此，我们将使用Link HTTP 标头，以及“下一个”、 “上一个”、“第一个”和“最后一个”链接关系类型。 在 REST 中，可发现性是一个横切关注点，不仅适用于特定操作，还适用于操作类型。例如，每次创建资源时，客户端应该可以发现该资源的 URI。由于此要求与 ANY Resource 的创建相关，因此我们将单独处理它。 正如我们在上一篇文章中讨论的那样，我们将使用事件来解耦这些关注点，重点是 REST 服务的可发现性。在分页的情况下，事件PaginatedResultsRetrievedEvent在控制器层中触发。然后，我们将使用此事件的自定义侦听器实现可发现性。 简而言之，监听器将检查导航是否允许下一页、 上一页、 第一页 和 最后一页。如果是这样，它会将相关的 URI 作为“链接”HTTP Header 添加到响应中。 现在让我们一步一步来。从控制器传递的UriComponentsBuilder仅包含基本 URL（主机、端口和上下文路径）。因此，我们必须添加其余部分： void addLinkHeaderOnPagedResourceRetrieval( UriComponentsBuilder uriBuilder, HttpServletResponse response, Class clazz, int page, int totalPages, int size ){ String resourceName = clazz.getSimpleName().toString().toLowerCase(); uriBuilder.path( \u0026#34;/admin/\u0026#34; + resourceName ); // ...  } 接下来，我们将使用StringJoiner 连接每个链接。我们将使用uriBuilder来生成 URI。让我们看看我们如何处理到下一页的链接： StringJoiner linkHeader = new StringJoiner(\u0026#34;, \u0026#34;); if (hasNextPage(page, totalPages)){ String uriForNextPage = constructNextPageUri(uriBuilder, page, size); linkHeader.add(createLinkHeader(uriForNextPage, \u0026#34;next\u0026#34;)); } 我们看一下 constructNextPageUri方法的逻辑： String constructNextPageUri(UriComponentsBuilder uriBuilder, int page, int size) { return uriBuilder.replaceQueryParam(PAGE, page + 1) .replaceQueryParam(\u0026#34;size\u0026#34;, size) .build() .encode() .toUriString(); } 我们将对我们想要包含的其余 URI 进行类似的处理。 最后，我们将输出添加为响应标头： response.addHeader(\u0026#34;Link\u0026#34;, linkHeader.toString()); 请注意，为简洁起见，仅包含部分代码示例。 5. 分页 分页和可发现性的主要逻辑都包含在小型、集中的集成测试中。与上一篇文章一样，我们将使用 REST-assured 库来使用 REST 服务并验证结果。 这些是分页集成测试的一些示例： @Test public void whenResourcesAreRetrievedPaged_then200IsReceived(){ Response response = RestAssured.get(paths.getFooURL() + \u0026#34;?page=0\u0026amp;size=2\u0026#34;); assertThat(response.getStatusCode(), is(200)); } @Test public void whenPageOfResourcesAreRetrievedOutOfBounds_then404IsReceived(){ String url = getFooURL() + \u0026#34;?page=\u0026#34; + randomNumeric(5) + \u0026#34;\u0026amp;size=2\u0026#34;; Response response = RestAssured.get.get(url); assertThat(response.getStatusCode(), is(404)); } @Test public void givenResourcesExist_whenFirstPageIsRetrieved_thenPageContainsResources(){ createResource(); Response response = RestAssured.get(paths.getFooURL() + \u0026#34;?page=0\u0026amp;size=2\u0026#34;); assertFalse(response.body().as(List.class).isEmpty()); } 6. 分页可发现性 测试分页是否可以被客户发现是相对简单的，尽管有很多内容需要覆盖。 测试将关注当前页面在导航中的位置，以及应该从每个位置发现的不同 URI： @Test public void whenFirstPageOfResourcesAreRetrieved_thenSecondPageIsNext(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToNextPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;next\u0026#34;); assertEquals(getFooURL()+\u0026#34;?page=1\u0026amp;size=2\u0026#34;, uriToNextPage); } @Test public void whenFirstPageOfResourcesAreRetrieved_thenNoPreviousPage(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToPrevPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;prev\u0026#34;); assertNull(uriToPrevPage ); } @Test public void whenSecondPageOfResourcesAreRetrieved_thenFirstPageIsPrevious(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=1\u0026amp;size=2\u0026#34;); String uriToPrevPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;prev\u0026#34;); assertEquals(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;, uriToPrevPage); } @Test public void whenLastPageOfResourcesIsRetrieved_thenNoNextPageIsDiscoverable(){ Response first = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToLastPage = extractURIByRel(first.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;last\u0026#34;); Response response = RestAssured.get(uriToLastPage); String uriToNextPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;next\u0026#34;); assertNull(uriToNextPage); } 7. 获取所有资源 在分页和可发现性的同一主题上，必须做出选择，是允许客户端一次检索系统中的所有资源，还是客户端必须分页请求它们。 如果确定客户端无法通过单个请求检索所有资源，并且需要分页，那么有几个选项可用于响应以获取请求。一种选择是返回 404 ( Not Found ) 并使用Link标头使第一页可发现：  链接=http://localhost:8080/rest/api/admin/foo?page=0\u0026size=2; rel=”first”, http://localhost:8080/rest/api/admin/foo?page=103\u0026size=2; 相对=“最后”  另一种选择是将重定向 303 （请参阅其他）返回到第一页。更保守的方法是简单地为 GET 请求返回 405（不允许的方法）给客户端。 8. 带有Range HTTP 标头的 REST 分页 实现分页的一种相对不同的方式是使用HTTP Range标头、 Range、Content-Range、If-Range、Accept-Ranges和HTTP 状态代码、 206（部分内容）、413（请求实体太大）和416（请求的范围不可满足）。 这种方法的一种观点是，HTTP Range 扩展不用于分页，它们应该由服务器管理，而不是由应用程序管理。基于 HTTP Range 标头扩展实现分页在技术上是可行的，尽管不像本文中讨论的实现那样普遍。 9. Spring Data REST 分页 在 Spring Data 中，如果我们需要从完整的数据集中返回一些结果，我们可以使用任何Pageable存储库方法，因为它总是返回一个Page。将根据页码、页面大小和排序方向返回结果。 Spring Data REST自动识别page, size, sort等URL 参数。 要使用任何存储库的分页方法，我们需要扩展PagingAndSortingRepository： public interface SubjectRepository extends PagingAndSortingRepository\u0026lt;Subject, Long\u0026gt;{} 如果我们调用 http://localhost:8080/subjects， Spring 会自动通过 API添加page, size, sort参数建议： \u0026#34;_links\u0026#34; : { \u0026#34;self\u0026#34; : { \u0026#34;href\u0026#34; : \u0026#34;http://localhost:8080/subjects{?page,size,sort}\u0026#34;, \u0026#34;templated\u0026#34; : true } } 默认情况下，页面大小为 20，但我们可以通过调用类似http://localhost:8080/subjects?page=10 的方法来更改它。 如果我们想在我们自己的自定义存储库 API 中实现分页，我们需要传递一个额外的Pageable参数并确保 API 返回一个Page： @RestResource(path = \u0026#34;nameContains\u0026#34;) public Page\u0026lt;Subject\u0026gt; findByNameContaining(@Param(\u0026#34;name\u0026#34;) String name, Pageable p); 每当我们添加自定义 API 时，都会将/search端点添加到生成的链接中。因此，如果我们调用 http://localhost:8080/subjects/search，我们将看到一个支持分页的端点： \u0026#34;findByNameContaining\u0026#34; : { \u0026#34;href\u0026#34; : \u0026#34;http://localhost:8080/subjects/search/nameContains{?name,page,size,sort}\u0026#34;, \u0026#34;templated\u0026#34; : true } 所有实现 PagingAndSortingRepository的 API都会返回一个Page。如果我们需要从Page返回结果列表， Page的getContent() API提供了作为 Spring Data REST API 结果获取的记录列表。 10. 将List转换为Page 假设我们有一个Pageable对象作为输入，但是我们需要检索的信息包含在一个列表而不是PagingAndSortingRepository中。在这些情况下，我们可能需要将List转换为Page。 例如，假设我们有一个SOAP服务的结果列表： List\u0026lt;Foo\u0026gt; list = getListOfFooFromSoapService(); 我们需要访问发送给我们的Pageable对象指定的特定位置的列表。所以让我们定义开始索引： int start = (int) pageable.getOffset(); 和结束索引： int end = (int) ((start + pageable.getPageSize()) \u0026gt; fooList.size() ? fooList.size() : (start + pageable.getPageSize())); 有了这两个，我们可以创建一个Page来获取它们之间的元素列表： Page\u0026lt;Foo\u0026gt; page = new PageImpl\u0026lt;Foo\u0026gt;(fooList.subList(start, end), pageable, fooList.size()); 而已！我们现在可以将page作为有效结果返回。 请注意，如果我们还想支持排序，我们需要在子列表之前对列表进行排序。 ","permalink":"http://itcodingman.github.io/rest-api-pagination-in-spring/","tags":["Pagination"],"title":"Spring中的REST分页"},{"categories":["Spring","REST"],"contents":"使用 Spring 5 创建 Web 应用程序 1. 概述 本教程说明了如何使用 Spring 创建 Web 应用程序。 我们将研究用于构建应用程序的 Spring Boot 解决方案，并查看非 Spring Boot 方法。 我们将主要使用 Java 配置，但也会看看它们等效的 XML 配置。 2. 使用 Spring Boot 进行设置 2.1 Maven 依赖 首先，我们需要spring-boot-starter-web 依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 该启动器包括：  spring-web和 Spring Web 应用程序所需的spring-webmvc模块 一个 Tomcat 启动器，这样我们就可以直接运行我们的 Web 应用程序，而无需显式安装任何服务器  2.2. 创建一个 Spring Boot 应用程序 开始使用 Spring Boot 最直接的方法是创建一个主类并使用 @SpringBootApplication对其进行注释： @SpringBootApplication public class SpringBootRestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootRestApplication.class, args); } } 此单个注解等效于使用@Configuration、@EnableAutoConfiguration和@ComponentScan。 默认情况下，它将扫描同一包或以下的所有组件。 接下来，对于 Spring beans 的基于 Java 的配置，我们需要创建一个配置类并使用@Configuration注解对其进行注解： @Configuration public class WebConfig { } 这个注解是基于 Java 的 Spring 配置使用的主要工件；它本身使用@Component进行元注释，这使得带注释的类成为标准 bean，因此也是组件扫描的候选对象。 @Configuration类的主要目的是作为 Spring IoC 容器的 bean 定义的来源。更详细的描述请参见官方文档。 让我们也看看使用核心spring-webmvc库的解决方案。 3. 使用 spring-webmvc 进行设置 3.1 Maven 依赖项 首先，我们需要spring-webmvc依赖： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3.2 基于 Java 的 Web 配置 接下来，我们将添加具有@Configuration注解的配置类： @Configuration @EnableWebMvc @ComponentScan(basePackages = \u0026#34;com.codingman.controller\u0026#34;) public class WebConfig { } 在这里，与 Spring Boot 解决方案不同，我们必须显式定义@EnableWebMvc以设置默认 Spring MVC 配置和@ComponentScan以指定要扫描组件的包。 @EnableWebMvc注解提供Spring Web MVC配置，例如设置调度程序 servlet、启用@Controller和@RequestMapping注解以及设置其他默认值。 @ComponentScan配置组件扫描指令，指定要扫描的包。 3.3 初始化器类 接下来，我们需要添加一个实现 WebApplicationInitializer接口的类： public class AppInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext container) throws ServletException { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.scan(\u0026#34;com.codingman\u0026#34;); container.addListener(new ContextLoaderListener(context)); ServletRegistration.Dynamic dispatcher = container.addServlet(\u0026#34;mvc\u0026#34;, new DispatcherServlet(context)); dispatcher.setLoadOnStartup(1); dispatcher.addMapping(\u0026#34;/\u0026#34;); } } 在这里，我们使用 AnnotationConfigWebApplicationContext类创建一个 Spring 上下文，这意味着我们只使用基于注释的配置。然后，我们指定要扫描组件和配置类的包。 最后，我们定义了 Web 应用程序的入口点——DispatcherServlet。 此类可以完全替换Servlet 3.0版本的web.xml文件。 4. XML 配置 让我们快速看一下等效的 XML Web 配置： \u0026lt;context:component-scan base-package=\u0026#34;com.codingman.controller\u0026#34; /\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; 我们可以用上面的WebConfig类替换这个 XML 文件。 要启动应用程序，我们可以使用加载 XML 配置或 web.xml 文件的 Initializer 类。有关这两种方法的更多详细信息，请查看之前的文章。 ","permalink":"http://itcodingman.github.io/bootstraping-a-web-application-with-spring-and-java-based-configuration/","tags":["Spring 5"],"title":"使用 Spring 5 创建 Web 应用程序"},{"categories":["Spring Persistence"],"contents":"使用 Spring 引导 Hibernate 5 1. 概述 在本文中，我们将讨论如何使用 Spring 引导 Hibernate 5，同时使用 Java 和 XML 配置。 文章 Spring Boot with Hibernate 描述了如何在 Spring Boot 中使用 Hibernate。 2. Spring集成 使用本机 Hibernate API引导SessionFactory有点复杂，需要我们编写好几行代码（请查看官方文档）。 幸运的是，Spring支持引导SessionFactory因此我们只需要几行 Java 代码或 XML 配置。 3. Maven依赖 让我们首先将必要的依赖项添加到我们的pom.xml中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.2.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring-orm 模块提供了 Spring 与 Hibernate 的集成： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-orm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为简单起见，我们将使用H2作为我们的数据库： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.197\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 最后，我们将使用Tomcat JDBC 连接池，它比Spring 提供的DriverManagerDataSource更适合生产目的： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-dbcp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4.配置 如前所述，Spring 支持我们引导 Hibernate SessionFactory。 我们所要做的就是定义一些 bean 以及一些参数。 使用 Spring，我们为这些配置提供了两种选择，一种基于 Java 的方式，一种基于 XML 的方式。 4.1。使用 Java 配置 对于将 Hibernate 5 与 Spring 一起使用，自Hibernate 4以来几乎没有变化：我们必须使用包org.springframework.orm.hibernate5中的LocalSessionFactoryBean而不是org.springframework.orm.hibernate4。 与之前的 Hibernate 4 一样，我们必须为LocalSessionFactoryBean、DataSource和PlatformTransactionManager定义 bean ，以及一些 Hibernate 特定的属性。 让我们创建HibernateConfig类来使用 Spring 配置 Hibernate 5： @Configuration @EnableTransactionManagement public class HibernateConf { @Bean public LocalSessionFactoryBean sessionFactory() { LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); sessionFactory.setPackagesToScan( {\u0026#34;com.codingman.hibernate.bootstrap.model\u0026#34; }); sessionFactory.setHibernateProperties(hibernateProperties()); return sessionFactory; } @Bean public DataSource dataSource() { BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\u0026#34;org.h2.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:h2:mem:db;DB_CLOSE_DELAY=-1\u0026#34;); dataSource.setUsername(\u0026#34;sa\u0026#34;); dataSource.setPassword(\u0026#34;sa\u0026#34;); return dataSource; } @Bean public PlatformTransactionManager hibernateTransactionManager() { HibernateTransactionManager transactionManager = new HibernateTransactionManager(); transactionManager.setSessionFactory(sessionFactory().getObject()); return transactionManager; } private final Properties hibernateProperties() { Properties hibernateProperties = new Properties(); hibernateProperties.setProperty( \u0026#34;hibernate.hbm2ddl.auto\u0026#34;, \u0026#34;create-drop\u0026#34;); hibernateProperties.setProperty( \u0026#34;hibernate.dialect\u0026#34;, \u0026#34;org.hibernate.dialect.H2Dialect\u0026#34;); return hibernateProperties; } } 4.2. 使用 XML 配置 作为次要选项，我们还可以使用基于 XML 的配置来配置 Hibernate 5： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;sessionFactory\u0026#34; class=\u0026#34;org.springframework.orm.hibernate5.LocalSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packagesToScan\u0026#34; value=\u0026#34;com.codingman.hibernate.bootstrap.model\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;hibernateProperties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.hbm2ddl.auto\u0026#34;\u0026gt; create-drop \u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.dialect\u0026#34;\u0026gt; org.hibernate.dialect.H2Dialect \u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;org.h2.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:h2:mem:db;DB_CLOSE_DELAY=-1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.orm.hibernate5.HibernateTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sessionFactory\u0026#34; ref=\u0026#34;sessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 正如我们很容易看到的那样，我们定义的 bean 和参数与前面基于 Java 的配置完全相同。 要将 XML 引导到 Spring 上下文中，如果应用程序配置了 Java 配置，我们可以使用一个简单的 Java 配置文件： @Configuration @EnableTransactionManagement @ImportResource({\u0026#34;classpath:hibernate5Configuration.xml\u0026#34;}) public class HibernateXMLConf { // } 或者，如果整体配置是纯 XML，我们可以简单地将 XML 文件提供给 Spring 上下文。 5. 用法 至此，Hibernate 5 完全配置了 Spring，我们可以在需要时直接注入原始的 Hibernate SessionFactory ： public abstract class BarHibernateDAO { @Autowired private SessionFactory sessionFactory; // ... } 6. 支持的数据库 不幸的是，Hibernate 项目并没有完全提供支持数据库的官方列表。 话虽如此，很容易看出是否支持特定的数据库类型，我们可以查看支持的方言列表。 ","permalink":"http://itcodingman.github.io/hibernate-5-spring/","tags":["Hibernate"],"title":"使用 Spring 引导 Hibernate 5"},{"categories":null,"contents":"","permalink":"http://itcodingman.github.io/search/","tags":null,"title":"Search"}]