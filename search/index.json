[{"categories":["Spring","Persistence"],"contents":"Grails 3 和 GORM 简介 1. 概述 这是对 Grails 3 和 GORM 的快速介绍。 我们当然会使用 Groovy，并且——隐含地——该框架还使用 Hibernate 来实现 ORM，Spring 框架用于依赖注入，SiteMash 用于布局和主题等。 2.数据源配置 我们无需指定任何显式数据源配置即可开始——默认情况下，Grails 使用 HSQLDB 数据库作为开发和测试环境。 但是如果你想改变这些默认值，你可以在application.yml中定义你选择的数据源： environments: development: dataSource: driverClassName : \u0026#34;com.mysql.jdbc.Driver\u0026#34; url : \u0026#34;jdbc:mysql://localhost:8080/test\u0026#34; dialect : org.hibernate.dialect.MySQL5InnoDBDialect 同样，我们可以在这里创建多个环境，如果需要，可以在开发旁边。 3. Domain Grails 能够基于数据库配置中的dbCreate属性为我们的域类创建数据库结构。 让我们在这里定义这些域类之一： Class User { String userName String password String email String age static constraints = { userName blank: false, unique: true password size: 5..10, blank: false email email: true, blank: true } } 请注意我们如何在模型中指定我们的验证约束，这使事情变得干净整洁，并且没有注释。 当实体被持久化时，这些约束将由 Grails 自动检查，如果这些约束中的任何一个被破坏，框架将抛出适当的验证异常。 我们还可以在模型的映射属性中指定 GORM 映射： static mapping = { sort \u0026#34;userName\u0026#34; } 现在，如果我们调用User.list() - 我们将返回按*用户名*****排序的结果。 我们当然可以通过将排序传递给列表 API 来实现相同的结果： User.list(sort: \u0026#34;userName\u0026#34;) 4. CRUD 操作 当我们看 API 操作时，脚手架在开始时扮演着非常有趣的角色；它允许您为域类生成基本的 CRUD API，包括：  必要的视图 标准 CRUD 操作的控制器操作 两种类型：动态和静态  以下是动态脚手架的工作原理： class UserController { static scaffold = true } 只需编写这一行代码，框架就会在运行时生成 7 个方法：显示、编辑、删除、创建、保存和更新。这些将作为该特定域实体的 API 发布。 静态脚手架示例：  使用脚手架创建视图：“ grails generate-views User ” 使用脚手架创建控制器和视图：“ grails generate-controller User ” 要在单个命令中创建所有内容，请使用：“ grails generate-all User ”  这些命令将为该特定域对象自动生成必要的管道。 现在让我们快速了解如何使用这些操作——例如，对于我们的用户域对象。 **创建新的“用户”**记录： def user = new User(username: \u0026#34;test\u0026#34;, password: \u0026#34;test123\u0026#34;, email: \u0026#34;a@a.com\u0026#34;, age: 14) user.save() 要获取单个记录： def user = User.get(1) 此获取API 将以可编辑模式检索域对象。对于只读模式，我们可以使用read API： def user = User.read(1) 要更新现有记录： def user = User.get(1) user.userName = \u0026#34;testUpdate\u0026#34; user.age = 20 user.save() 以及对现有记录的简单删除操作： def user = User.get(1) user.delete() 5. GORM 查询 5.1 find 让我们从find API 开始： def user = User.find(\u0026#34;from User as u where u.username = \u0026#39;test\u0026#39; \u0026#34;) 我们还可以使用不同的语法来传递参数： def user = User.find(\u0026#34;from User as u where u.username?\u0026#34;, [\u0026#39;test\u0026#39;]) 我们还可以使用命名参数： def user = User.find(\u0026#34;from User as u where u.username=?\u0026#34;, [username: \u0026#39;test\u0026#39;]) 5.2. findBy Grails 提供了一个动态查找工具，它使用域属性在运行时执行查询并返回第一个匹配记录： def user = User.findByUsername(\u0026#34;test\u0026#34;) user = User.findByUsernameAndAge(\u0026#34;test\u0026#34;, 20) user = User.findByUsernameLike(\u0026#34;tes\u0026#34;) user = User.findByUsernameAndAgeNotEquals(\u0026#34;test\u0026#34;, \u0026#34;100\u0026#34;) 你可以在这里找到更多的表达方式。 5.3. Criteria 我们还可以使用一些灵活的标准检索数据： def user = User.find { username == \u0026#34;test\u0026#34;} def user = User.createCriteria() def results = user.list { like (\u0026#34;userName\u0026#34;, \u0026#34;te%\u0026#34;) and { between(\u0026#34;age\u0026#34;, 10, 20) } order(\u0026#34;userName\u0026#34;, \u0026#34;desc\u0026#34;) } 这里有一个说明——当使用条件查询时，使用“{}”而不是“()”。 5.4. 执行查询/更新 GORM 还支持 HQL 查询语法——用于读取操作： def user = User.executeQuery( \u0026#34;select u.userName from User u where u.userName = ?\u0026#34;, [\u0026#39;test\u0026#39;]) 以及写操作： def user = User.executeUpdate(\u0026#34;delete User u where u.username =?\u0026#34;, [\u0026#39;test\u0026#39;]) ","permalink":"http://itcodingman.github.io/grails-gorm-tutorial/","tags":[],"title":"Grails 3 和 GORM 简介"},{"categories":["Spring"],"contents":"Spring Batch 简介 1. 概述 在本教程中，我们将看一个实用的、以代码为中心的 Spring Batch 介绍。Spring Batch 是一个处理框架，专为作业的稳健执行而设计。 它的当前版本 4.3 支持 Spring 5 和 Java 8。它还适应 JSR-352，这是用于批处理的新 Java 规范。 以下是该框架的一些有趣且实用的用例。 2. 工作流程基础 Spring Batch 遵循传统的批处理架构，其中作业存储库执行调度和与作业交互的工作。 一个作业可以有多个步骤。每个步骤通常遵循读取数据、处理数据和写入数据的顺序。 当然，这里的框架将为我们完成大部分繁重的工作——尤其是在处理作业的低级持久性工作时——使用sqlite作为作业存储库。 2.1 示例用例 我们将在这里处理的简单用例是将一些金融交易数据从 CSV 迁移到 XML。 输入文件的结构非常简单。 它包含每行的交易，由用户名、用户 ID、交易日期和金额组成： username, userid, transaction_date, transaction_amount ann, 1234, 31/10/2015, 10000 bob, 2134, 3/12/2015, 12321 robin, 3134, 2/02/2015, 23411 3. Maven POM 本项目需要的依赖有spring core、spring batch和sqlite jdbc connector： \u0026lt;!-- SQLite database driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.xerial\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sqlite-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-oxm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.batch\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-batch-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4. Spring批处理配置 我们要做的第一件事是使用 XML 配置 Spring Batch： \u0026lt;!-- connect to SQLite database --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;org.sqlite.JDBC\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:sqlite:repository.sqlite\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- create job-meta tables automatically --\u0026gt; \u0026lt;jdbc:initialize-database data-source=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;jdbc:script location=\u0026#34;org/springframework/batch/core/schema-drop-sqlite.sql\u0026#34; /\u0026gt; \u0026lt;jdbc:script location=\u0026#34;org/springframework/batch/core/schema-sqlite.sql\u0026#34; /\u0026gt; \u0026lt;/jdbc:initialize-database\u0026gt; \u0026lt;!-- stored job-meta in memory --\u0026gt; \u0026lt;!-- \u0026lt;bean id=\u0026#34;jobRepository\u0026#34; class=\u0026#34;org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- stored job-meta in database --\u0026gt; \u0026lt;bean id=\u0026#34;jobRepository\u0026#34; class=\u0026#34;org.springframework.batch.core.repository.support.JobRepositoryFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;databaseType\u0026#34; value=\u0026#34;sqlite\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class= \u0026#34;org.springframework.batch.support.transaction.ResourcelessTransactionManager\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;jobLauncher\u0026#34; class=\u0026#34;org.springframework.batch.core.launch.support.SimpleJobLauncher\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;jobRepository\u0026#34; ref=\u0026#34;jobRepository\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 当然，也可以使用 Java 配置： @Configuration @EnableBatchProcessing public class SpringConfig { @Value(\u0026#34;org/springframework/batch/core/schema-drop-sqlite.sql\u0026#34;) private Resource dropReopsitoryTables; @Value(\u0026#34;org/springframework/batch/core/schema-sqlite.sql\u0026#34;) private Resource dataReopsitorySchema; @Bean public DataSource dataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\u0026#34;org.sqlite.JDBC\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:sqlite:repository.sqlite\u0026#34;); return dataSource; } @Bean public DataSourceInitializer dataSourceInitializer(DataSource dataSource) throws MalformedURLException { ResourceDatabasePopulator databasePopulator = new ResourceDatabasePopulator(); databasePopulator.addScript(dropReopsitoryTables); databasePopulator.addScript(dataReopsitorySchema); databasePopulator.setIgnoreFailedDrops(true); DataSourceInitializer initializer = new DataSourceInitializer(); initializer.setDataSource(dataSource); initializer.setDatabasePopulator(databasePopulator); return initializer; } private JobRepository getJobRepository() throws Exception { JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean(); factory.setDataSource(dataSource()); factory.setTransactionManager(getTransactionManager()); factory.afterPropertiesSet(); return (JobRepository) factory.getObject(); } private PlatformTransactionManager getTransactionManager() { return new ResourcelessTransactionManager(); } public JobLauncher getJobLauncher() throws Exception { SimpleJobLauncher jobLauncher = new SimpleJobLauncher(); jobLauncher.setJobRepository(getJobRepository()); jobLauncher.afterPropertiesSet(); return jobLauncher; } } 5. Spring Batch 作业配置 现在让我们为 CSV 到 XML 工作编写工作描述： \u0026lt;import resource=\u0026#34;spring.xml\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;record\u0026#34; class=\u0026#34;com.codingman.spring_batch_intro.model.Transaction\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemReader\u0026#34; class=\u0026#34;org.springframework.batch.item.file.FlatFileItemReader\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;input/record.csv\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;lineMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.batch.item.file.mapping.DefaultLineMapper\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lineTokenizer\u0026#34;\u0026gt; \u0026lt;bean class= \u0026#34;org.springframework.batch.item.file.transform.DelimitedLineTokenizer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;names\u0026#34; value=\u0026#34;username,userid,transactiondate,amount\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;fieldSetMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.codingman.spring_batch_intro.service.RecordFieldSetMapper\u0026#34; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemProcessor\u0026#34; class=\u0026#34;com.codingman.spring_batch_intro.service.CustomItemProcessor\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;itemWriter\u0026#34; class=\u0026#34;org.springframework.batch.item.xml.StaxEventItemWriter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;file:xml/output.xml\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;marshaller\u0026#34; ref=\u0026#34;recordMarshaller\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;rootTagName\u0026#34; value=\u0026#34;transactionRecord\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;recordMarshaller\u0026#34; class=\u0026#34;org.springframework.oxm.jaxb.Jaxb2Marshaller\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;classesToBeBound\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;com.codingman.spring_batch_intro.model.Transaction\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;batch:job id=\u0026#34;firstBatchJob\u0026#34;\u0026gt; \u0026lt;batch:step id=\u0026#34;step1\u0026#34;\u0026gt; \u0026lt;batch:tasklet\u0026gt; \u0026lt;batch:chunk reader=\u0026#34;itemReader\u0026#34; writer=\u0026#34;itemWriter\u0026#34; processor=\u0026#34;itemProcessor\u0026#34; commit-interval=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;/batch:chunk\u0026gt; \u0026lt;/batch:tasklet\u0026gt; \u0026lt;/batch:step\u0026gt; \u0026lt;/batch:job\u0026gt; 这是类似的基于 Java 的作业配置： public class SpringBatchConfig { @Autowired private JobBuilderFactory jobs; @Autowired private StepBuilderFactory steps; @Value(\u0026#34;input/record.csv\u0026#34;) private Resource inputCsv; @Value(\u0026#34;file:xml/output.xml\u0026#34;) private Resource outputXml; @Bean public ItemReader\u0026lt;Transaction\u0026gt; itemReader() throws UnexpectedInputException, ParseException { FlatFileItemReader\u0026lt;Transaction\u0026gt; reader = new FlatFileItemReader\u0026lt;Transaction\u0026gt;(); DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer(); String[] tokens = { \u0026#34;username\u0026#34;, \u0026#34;userid\u0026#34;, \u0026#34;transactiondate\u0026#34;, \u0026#34;amount\u0026#34; }; tokenizer.setNames(tokens); reader.setResource(inputCsv); DefaultLineMapper\u0026lt;Transaction\u0026gt; lineMapper = new DefaultLineMapper\u0026lt;Transaction\u0026gt;(); lineMapper.setLineTokenizer(tokenizer); lineMapper.setFieldSetMapper(new RecordFieldSetMapper()); reader.setLineMapper(lineMapper); return reader; } @Bean public ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; itemProcessor() { return new CustomItemProcessor(); } @Bean public ItemWriter\u0026lt;Transaction\u0026gt; itemWriter(Marshaller marshaller) throws MalformedURLException { StaxEventItemWriter\u0026lt;Transaction\u0026gt; itemWriter = new StaxEventItemWriter\u0026lt;Transaction\u0026gt;(); itemWriter.setMarshaller(marshaller); itemWriter.setRootTagName(\u0026#34;transactionRecord\u0026#34;); itemWriter.setResource(outputXml); return itemWriter; } @Bean public Marshaller marshaller() { Jaxb2Marshaller marshaller = new Jaxb2Marshaller(); marshaller.setClassesToBeBound(new Class[] { Transaction.class }); return marshaller; } @Bean protected Step step1(ItemReader\u0026lt;Transaction\u0026gt; reader, ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; processor, ItemWriter\u0026lt;Transaction\u0026gt; writer) { return steps.get(\u0026#34;step1\u0026#34;).\u0026lt;Transaction, Transaction\u0026gt; chunk(10) .reader(reader).processor(processor).writer(writer).build(); } @Bean(name = \u0026#34;firstBatchJob\u0026#34;) public Job job(@Qualifier(\u0026#34;step1\u0026#34;) Step step1) { return jobs.get(\u0026#34;firstBatchJob\u0026#34;).start(step1).build(); } } 现在我们有了整个配置，让我们分解它并开始讨论它。 5.1 使用ItemReader读取数据并创建对象 首先，我们配置了cvsFileItemReader ，它将从record.csv中读取数据并将其转换为Transaction对象： @SuppressWarnings(\u0026#34;restriction\u0026#34;) @XmlRootElement(name = \u0026#34;transactionRecord\u0026#34;) public class Transaction { private String username; private int userId; private LocalDateTime transactionDate; private double amount; /* getters and setters for the attributes */ @Override public String toString() { return \u0026#34;Transaction [username=\u0026#34; + username + \u0026#34;, userId=\u0026#34; + userId + \u0026#34;, transactionDate=\u0026#34; + transactionDate + \u0026#34;, amount=\u0026#34; + amount + \u0026#34;]\u0026#34;; } } 为此，它使用自定义映射器： public class RecordFieldSetMapper implements FieldSetMapper\u0026lt;Transaction\u0026gt; { public Transaction mapFieldSet(FieldSet fieldSet) throws BindException { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;d/M/yyy\u0026#34;); Transaction transaction = new Transaction(); transaction.setUsername(fieldSet.readString(\u0026#34;username\u0026#34;)); transaction.setUserId(fieldSet.readInt(1)); transaction.setAmount(fieldSet.readDouble(3)); String dateString = fieldSet.readString(2); transaction.setTransactionDate(LocalDate.parse(dateString, formatter).atStartOfDay()); return transaction; } } 5.2 使用ItemProcessor处理数据 我们创建了自己的项目处理器CustomItemProcessor。这不会处理与事务对象相关的任何内容。 它所做的只是将来自 reader 的原始对象传递给 writer： public class CustomItemProcessor implements ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; { public Transaction process(Transaction item) { return item; } } 5.3 使用ItemWriter将对象写入 FS 最后，我们将此事务存储到位于xml/output.xml的 XML 文件中： \u0026lt;bean id=\u0026#34;itemWriter\u0026#34; class=\u0026#34;org.springframework.batch.item.xml.StaxEventItemWriter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;file:xml/output.xml\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;marshaller\u0026#34; ref=\u0026#34;recordMarshaller\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;rootTagName\u0026#34; value=\u0026#34;transactionRecord\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 5.4 配置批处理作业 因此，我们所要做的就是使用batch:job语法将这些点与作业连接起来。 注意提交间隔。这是在将批次提交给itemWriter之前要保存在内存中的事务数。 它将在内存中保存事务直到该点（或直到遇到输入数据的结尾）： \u0026lt;batch:job id=\u0026#34;firstBatchJob\u0026#34;\u0026gt; \u0026lt;batch:step id=\u0026#34;step1\u0026#34;\u0026gt; \u0026lt;batch:tasklet\u0026gt; \u0026lt;batch:chunk reader=\u0026#34;itemReader\u0026#34; writer=\u0026#34;itemWriter\u0026#34; processor=\u0026#34;itemProcessor\u0026#34; commit-interval=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;/batch:chunk\u0026gt; \u0026lt;/batch:tasklet\u0026gt; \u0026lt;/batch:step\u0026gt; \u0026lt;/batch:job\u0026gt; 5.5 运行批处理作业 现在让我们设置并运行所有内容： public class App { public static void main(String[] args) { // Spring Java config  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(SpringConfig.class); context.register(SpringBatchConfig.class); context.refresh(); JobLauncher jobLauncher = (JobLauncher) context.getBean(\u0026#34;jobLauncher\u0026#34;); Job job = (Job) context.getBean(\u0026#34;firstBatchJob\u0026#34;); System.out.println(\u0026#34;Starting the batch job\u0026#34;); try { JobExecution execution = jobLauncher.run(job, new JobParameters()); System.out.println(\u0026#34;Job Status : \u0026#34; + execution.getStatus()); System.out.println(\u0026#34;Job completed\u0026#34;); } catch (Exception e) { e.printStackTrace(); System.out.println(\u0026#34;Job failed\u0026#34;); } } } ","permalink":"http://itcodingman.github.io/introduction-to-spring-batch/","tags":["Spring Batch"],"title":"Spring Batch 简介"},{"categories":["REST","Spring"],"contents":"使用 Spring 的 REST 错误处理 1. 概述 本教程将说明**如何使用 Spring 为 REST API 实现异常处理。**我们还将获得一些历史概览，并查看不同版本引入了哪些新选项。 *在 Spring 3.2 之前，在 Spring MVC 应用程序中处理异常的两种主要方法是HandlerExceptionResolver或@ExceptionHandler*注解。**两者都有一些明显的缺点。 从 3.2 开始，我们有了@ControllerAdvice*注解*来解决前两个解决方案的局限性，并在整个应用程序中促进统一的异常处理。 现在Spring 5 引入了ResponseStatusException 类——一种在我们的 REST API 中进行基本错误处理的快速方法。 所有这些都有一个共同点：它们很好地处理了**关注点的分离。**该应用程序可以正常抛出异常以指示某种失败，然后将单独处理。 最后，我们将看到 Spring Boot 带来了什么，以及我们如何配置它以满足我们的需求。 2.方案一：Controller级@ExceptionHandler 第一个解决方案适用于*@Controller级别。我们将定义一个方法来处理异常并使用@ExceptionHandler* 对其进行注释： public class FooController{ //...  @ExceptionHandler({ CustomException1.class, CustomException2.class }) public void handleException() { //  } } 这种方法有一个主要缺点：**@ExceptionHandler注释方法仅对特定的 Controller 有效，**而不是对整个应用程序全局有效。当然，将它添加到每个控制器使其不太适合一般的异常处理机制。 我们可以通过让所有控制器扩展一个基本控制器类来解决这个限制。 然而，这种解决方案对于应用程序来说可能是个问题，无论出于何种原因，这是不可能的。例如，控制器可能已经从另一个基类扩展而来，该基类可能在另一个 jar 中或不可直接修改，或者它们本身可能不可直接修改。 接下来，我们将研究另一种解决异常处理问题的方法——一种全局的并且不包括对现有工件（例如控制器）的任何更改。 3. 解决方案2：HandlerExceptionResolver 第二种解决方案是定义一个HandlerExceptionResolver。这将解决应用程序抛出的任何异常。它还将允许我们在 REST API 中实现统一的异常处理机制。 在使用自定义解析器之前，让我们回顾一下现有的实现。 3.1 ExceptionHandlerExceptionResolver 这个解析器是在 Spring 3.1 中引入的，默认情况下在DispatcherServlet中启用。这实际上是前面介绍的*@ExceptionHandler*机制如何工作的核心组件。 3.2. DefaultHandlerExceptionResolver 这个解析器是在 Spring 3.0 中引入的，默认情况下它在DispatcherServlet中启用。 它用于解决相应的HTTP 状态代码的标准 Spring 异常，即客户端错误4xx和服务器错误5xx状态代码。这是它处理的 Spring 异常的完整列表以及它们如何映射到状态代码。 虽然它确实正确设置了响应的状态代码，但一个**限制是它没有为响应的正文设置任何内容。**对于 REST API——状态码实际上不足以呈现给客户端——响应也必须有一个主体，以允许应用程序提供有关失败的附加信息。 这可以通过ModelAndView配置视图分辨率和渲染错误内容来解决，但该解决方案显然不是最优的。这就是为什么 Spring 3.2 引入了一个更好的选项，我们将在后面的部分讨论。 3.3. ResponseStatusExceptionResolver 这个解析器也在 Spring 3.0 中引入，默认情况下在DispatcherServlet中启用。 它的主要职责是使用自定义异常上可用的*@ResponseStatus*注释并将这些异常映射到 HTTP 状态代码。 这样的自定义异常可能如下所示： @ResponseStatus(value = HttpStatus.NOT_FOUND) public class MyResourceNotFoundException extends RuntimeException { public MyResourceNotFoundException() { super(); } public MyResourceNotFoundException(String message, Throwable cause) { super(message, cause); } public MyResourceNotFoundException(String message) { super(message); } public MyResourceNotFoundException(Throwable cause) { super(cause); } } 与DefaultHandlerExceptionResolver相同，此解析器在处理响应主体的方式上受到限制——它确实将状态代码映射到响应上，但主体仍然为空。 3.4 自定义HandlerExceptionResolver DefaultHandlerExceptionResolver和ResponseStatusExceptionResolver的组合在为 Spring RESTful 服务提供良好的错误处理机制方面大有帮助。如前所述，缺点是无法控制响应的主体。 理想情况下，我们希望能够输出 JSON 或 XML，具体取决于客户端要求的格式（通过Accept标头）。 仅此一项就证明了创建一个新的自定义异常解析器是合理的： @Component public class RestResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver { @Override protected ModelAndView doResolveException( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { try { if (ex instanceof IllegalArgumentException) { return handleIllegalArgument( (IllegalArgumentException) ex, response, handler); } ... } catch (Exception handlerException) { logger.warn(\u0026#34;Handling of [\u0026#34; + ex.getClass().getName() + \u0026#34;] resulted in Exception\u0026#34;, handlerException); } return null; } private ModelAndView handleIllegalArgument(IllegalArgumentException ex, HttpServletResponse response) throws IOException { response.sendError(HttpServletResponse.SC_CONFLICT); String accept = request.getHeader(HttpHeaders.ACCEPT); ... return new ModelAndView(); } } 这里要注意的一个细节是我们可以访问请求本身，因此我们可以考虑客户端发送的Accept标头的值。 例如，如果客户端请求application/json，那么在出现错误情况的情况下，我们希望确保返回一个使用application/json编码的响应正文。 另一个重要的实现细节是我们返回一个 ModelAndView——这是响应的主体，它允许我们在上面设置任何必要的东西。 这种方法是一种一致且易于配置的机制，用于 Spring REST 服务的错误处理。 但是，它确实有局限性：它与低级HtttpServletResponse 交互并适合使用ModelAndView的旧 MVC 模型，因此仍有改进的空间。 4. 解决方案3：@ControllerAdvice Spring 3.2通过@ControllerAdvice注释支持全局@ExceptionHandler。 这启用了一种脱离旧 MVC 模型并利用ResponseEntity以及@ExceptionHandler的类型安全性和灵活性的机制： @ControllerAdvice public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(value = { IllegalArgumentException.class, IllegalStateException.class }) protected ResponseEntity\u0026lt;Object\u0026gt; handleConflict( RuntimeException ex, WebRequest request) { String bodyOfResponse = \u0026#34;This should be application specific\u0026#34;; return handleExceptionInternal(ex, bodyOfResponse, new HttpHeaders(), HttpStatus.CONFLICT, request); } } @ControllerAdvice注解允许我们将之前的多个分散的@ExceptionHandler整合到一个单一的全局错误处理组件中。 实际的机制非常简单，但也非常灵活：  它使我们可以完全控制响应的主体以及状态代码。 它提供了多个异常到同一方法的映射，以便一起处理。 它充分利用了较新的 RESTful ResposeEntity响应。  这里要记住的一件事是将使用@ExceptionHandler声明的异常与用作方法参数的异常相匹配。 如果这些不匹配，编译器不会抱怨——没有理由应该抱怨——Spring 也不会抱怨。 但是，当在运行时实际抛出异常时，异常解析机制将失败，并显示： java.lang.IllegalStateException: No suitable resolver for argument [0] [type=...] HandlerMethod details: ... 5. 解决方案4：ResponseStatusException（Spring 5及以上） Spring 5 引入了ResponseStatusException类。 我们可以创建它的一个实例，提供一个HttpStatus以及一个可选的reason和cause： @GetMapping(value = \u0026#34;/{id}\u0026#34;) public Foo findById(@PathVariable(\u0026#34;id\u0026#34;) Long id, HttpServletResponse response) { try { Foo resourceById = RestPreconditions.checkFound(service.findOne(id)); eventPublisher.publishEvent(new SingleResourceRetrievedEvent(this, response)); return resourceById; } catch (MyResourceNotFoundException exc) { throw new ResponseStatusException( HttpStatus.NOT_FOUND, \u0026#34;Foo Not Found\u0026#34;, exc); } } 使用ResponseStatusException有什么好处？  非常适合原型设计：我们可以非常快速地实施基本解决方案。 一种类型，多种状态码：一种异常类型可能导致多种不同的响应。与@ExceptionHandler相比，这减少了紧密耦合。 我们不必创建尽可能多的自定义异常类。 我们可以更好地控制异常处理，因为可以通过编程方式创建异常。  那么权衡呢？  没有统一的异常处理方式：与提供全局方法的@ControllerAdvice相比，执行一些应用程序范围的约定更加困难。 代码复制：我们可能会发现自己在多个控制器中复制代码。  我们还应该注意到，可以在一个应用程序中组合不同的方法。 例如，我们可以 全局 实现@ControllerAdvice ，也可以在本地实现ResponseStatusException 。 但是，我们需要小心：如果可以以多种方式处理同一个异常，我们可能会注意到一些令人惊讶的行为。一种可能的约定是始终以一种方式处理一种特定类型的异常。 有关更多详细信息和更多示例，请参阅我们的ResponseStatusException教程。 6. 处理Spring Security中的访问被拒绝 当经过身份验证的用户尝试访问他没有足够权限访问的资源时，会发生访问被拒绝。 6.1 REST 和方法级安全性 最后，让我们看看如何处理由方法级安全注解（@PreAuthorize、@PostAuthorize和@Secure ）引发的 Access Denied 异常。 当然，我们也会使用前面讨论过的全局异常处理机制来处理AccessDeniedException： @ControllerAdvice public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler({ AccessDeniedException.class }) public ResponseEntity\u0026lt;Object\u0026gt; handleAccessDeniedException( Exception ex, WebRequest request) { return new ResponseEntity\u0026lt;Object\u0026gt;( \u0026#34;Access denied message here\u0026#34;, new HttpHeaders(), HttpStatus.FORBIDDEN); } ... } 7. Spring Boot 支持 Spring Boot 提供了一个 ErrorController实现以合理的方式处理错误。 简而言之，它为浏览器提供后备错误页面（又名 Whitelabel 错误页面），并为 RESTful、非 HTML 请求提供 JSON 响应： { \u0026#34;timestamp\u0026#34;: \u0026#34;2019-01-17T16:12:45.977+0000\u0026#34;, \u0026#34;status\u0026#34;: 500, \u0026#34;error\u0026#34;: \u0026#34;Internal Server Error\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Error processing the request!\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/my-endpoint-with-exceptions\u0026#34; } 像往常一样，Spring Boot 允许使用属性配置这些功能：  server.error.whitelabel.enabled：可用于禁用 Whitelabel 错误页面并依赖 servlet 容器提供 HTML 错误消息 server.error.include-stacktrace：始终 具有值；在 HTML 和 JSON 默认响应中包含堆栈跟踪 server.error.include-message： 从 2.3 版本开始，Spring Boot 在响应中隐藏了message字段，以避免泄露敏感信息；我们可以使用这个属性和一个 always 值来启用它  除了这些属性之外，我们还可以为 /error 提供我们自己的视图解析器映射，覆盖 Whitelabel 页面。 我们还可以通过在上下文中包含一个ErrorAttributes bean 来自定义我们想要在响应中显示的属性 。我们可以扩展 Spring Boot 提供的 DefaultErrorAttributes类以使事情变得更简单： @Component public class MyCustomErrorAttributes extends DefaultErrorAttributes { @Override public Map\u0026lt;String, Object\u0026gt; getErrorAttributes( WebRequest webRequest, ErrorAttributeOptions options) { Map\u0026lt;String, Object\u0026gt; errorAttributes = super.getErrorAttributes(webRequest, options); errorAttributes.put(\u0026#34;locale\u0026#34;, webRequest.getLocale() .toString()); errorAttributes.remove(\u0026#34;error\u0026#34;); //...  return errorAttributes; } } 如果我们想进一步定义（或覆盖）应用程序将如何处理特定内容类型的错误，我们可以注册一个 ErrorController bean。 同样，我们可以利用 Spring Boot 提供的默认 BasicErrorController 来帮助我们。 例如，假设我们想要自定义我们的应用程序如何处理在 XML 端点中触发的错误。我们所要做的就是使用 @RequestMapping定义一个公共方法，并声明它产生application/xml媒体类型： @Component public class MyErrorController extends BasicErrorController { public MyErrorController( ErrorAttributes errorAttributes, ServerProperties serverProperties) { super(errorAttributes, serverProperties.getError()); } @RequestMapping(produces = MediaType.APPLICATION_XML_VALUE) public ResponseEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; xmlError(HttpServletRequest request) { // ...  } } 注意：这里我们仍然依赖于server.error.我们可能已经在项目中定义的引导属性，这些属性绑定到ServerProperties bean。 ","permalink":"http://itcodingman.github.io/exception-handling-for-rest-with-spring/","tags":[],"title":"使用 Spring 的 REST 错误处理"},{"categories":["Spring"],"contents":"Spring中的构造函数依赖注入 1. 简介 可以说，现代软件设计最重要的开发原则之一是*依赖注入 (DI)，*它很自然地源于另一个至关重要的原则：模块化。 这个快速教程将探讨 Spring 中一种特定类型的 DI 技术，称为基于构造函数的依赖注入， 简单地说，意味着我们在实例化时将所需的组件传递给一个类。 首先，我们需要在pom.xml中导入spring-context依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后我们需要设置一个配置文件。根据偏好，该文件可以是 POJO 或 XML 文件。 2. 基于注解的配置 Java 配置文件看起来类似于带有一些附加注释的 Java 对象： @Configuration @ComponentScan(\u0026#34;com.codingman.constructordi\u0026#34;) public class Config { @Bean public Engine engine() { return new Engine(\u0026#34;v8\u0026#34;, 5); } @Bean public Transmission transmission() { return new Transmission(\u0026#34;sliding\u0026#34;); } } 在这里，我们使用注解来通知 Spring 运行时这个类提供了 bean 定义（@Bean注解），并且包com.codingman.spring需要执行上下文扫描以查找其他 bean。接下来，我们定义一个Car类： @Component public class Car { @Autowired public Car(Engine engine, Transmission transmission) { this.engine = engine; this.transmission = transmission; } } Spring在进行包扫描时会遇到我们的Car类，并会通过调用@Autowired带注释的构造函数来初始化它的实例。 通过调用Config类的@Bean注解方法，我们将获得Engine 和 Transmission的实例。最后，我们需要使用我们的 POJO 配置来引导ApplicationContext： ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); Car car = context.getBean(Car.class); 3. 隐式构造函数注入 从 Spring 4.3 开始，具有单个构造函数的类可以省略@Autowired注释。这是一个很好的便利和样板删除。 最重要的是，同样从 4.3 开始，我们可以在@Configuration注释类中利用基于构造函数的注入。另外，如果这样的类只有一个构造函数，我们也可以省略@Autowired注解。 4. 基于 XML 的配置 使用基于构造函数的依赖注入配置 Spring 运行时的另一种方法是使用 XML 配置文件： \u0026lt;bean id=\u0026#34;toyota\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Car\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;engine\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; ref=\u0026#34;transmission\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;engine\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Engine\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;v4\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transmission\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Transmission\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;sliding\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 请注意，constructor-arg可以接受文字值或对另一个 bean 的引用，并且可以提供可选的显式索引和类型。我们可以使用Type和index属性来解决歧义（例如，如果构造函数采用相同类型的多个参数）。  name属性也可以用于 xml 到 java 变量的匹配，但是你的代码必须在编译时使用调试标志。  在这种情况下，我们需要使用ClassPathXmlApplicationContext引导我们的 Spring 应用程序上下文： ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;codingman.xml\u0026#34;); Car car = context.getBean(Car.class); 5. 优点和缺点 与字段注入相比，构造函数注入有一些优点。 第一个好处是可测试性。假设我们要对一个使用字段注入的 Spring bean 进行单元测试： public class UserService { @Autowired private UserRepository userRepository; } 在UserService 实例的构建过程中，我们无法初始化userRepository 状态。实现这一点的唯一方法是通过完全打破封装的反射 API此外，与简单的构造函数调用相比，生成的代码将不太安全。 此外，使用字段注入，我们无法强制执行类级别的不变量，因此可能会在没有正确初始化userRepository的情况下拥有 UserService 实例。因此，我们可能会在这里和那里遇到随机 的NullPointerException 。此外，使用构造函数注入，更容易构建不可变组件。 此外，从 OOP 的角度来看，使用构造函数创建对象实例更为自然。 另一方面，构造函数注入的主要缺点是其冗长，尤其是当 bean 具有少量依赖项时。有时这可能是因祸得福，因为我们可能会更加努力地将依赖项的数量保持在最低限度。 ","permalink":"http://itcodingman.github.io/constructor-injection-in-spring/","tags":["Spring Core Basics","Spring DI"],"title":"Spring中的构造函数依赖注入"},{"categories":["Spring"],"contents":"Spring 控制反转和依赖注入简介 1. 概述 在本教程中，我们将介绍 IoC（控制反转）和 DI（依赖注入）的概念，并了解它们在 Spring 框架中是如何实现的。 2. 什么是控制反转？ 控制反转是软件工程中的一项原则，它将对象或程序部分的控制转移到容器或框架中。我们最常在面向对象编程的上下文中使用它。 与我们的自定义代码调用库的传统编程相比，IoC 使框架能够控制程序的流程并调用我们的自定义代码。为了实现这一点，框架使用内置附加行为的抽象。如果我们想添加自己的行为，我们需要扩展框架的类或插入我们自己的类。 这种架构的优点是：  将任务的执行与其实现分离 更容易在不同的实现之间切换 程序的更大模块化 通过隔离组件或模拟其依赖关系并允许组件通过合约进行通信，从而更轻松地测试程序  我们可以通过各种机制来实现控制反转，例如：策略设计模式、服务定位器模式、工厂模式和依赖注入（DI）。 接下来我们将研究 DI。 3. 什么是依赖注入？ 依赖注入是我们可以用来实现 IoC 的一种模式，其中被反转的控制是设置对象的依赖关系。 将对象与其他对象连接起来，或将对象“注入”到其他对象中，是由汇编程序完成的，而不是由对象本身完成的。 以下是我们如何在传统编程中创建对象依赖项： public class Store { private Item item; public Store() { item = new ItemImpl1(); } } 在上面的示例中，我们需要在Store类本身中实例化Item接口的实现。 通过使用 DI，我们可以重写示例，而无需指定我们想要的Item的实现： public class Store { private Item item; public Store(Item item) { this.item = item; } } 在接下来的部分中，我们将了解如何通过元数据提供Item的实现。 IoC 和 DI 都是简单的概念，但它们对我们构建系统的方式有着深远的影响，因此它们非常值得充分理解。 4. Spring IoC 容器 IoC 容器是实现 IoC 的框架的共同特征。 在 Spring 框架中，接口 ApplicationContext代表 IoC 容器。Spring 容器负责实例化、配置和组装称为bean的对象，以及管理它们的生命周期。 Spring 框架提供了ApplicationContext接口的几种实现：ClassPathXmlApplicationContext和FileSystemXmlApplicationContext用于独立应用程序，WebApplicationContext用于 Web 应用程序。 为了组装 bean，容器使用配置元数据，它可以是 XML 配置或注解的形式。 这是手动实例化容器的一种方法： ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); 要在上面的示例中设置项目属性，我们可以使用元数据。然后容器将读取此元数据并在运行时使用它来组装 bean。 Spring 中的依赖注入可以通过构造函数、setter 或字段来完成。 5. 基于构造函数的依赖注入 在基于构造函数的依赖注入的情况下，容器将调用带有参数的构造函数，每个参数代表我们要设置的依赖项。 Spring 主要按类型解析每个参数，然后是属性名称，以及用于消歧的索引。让我们使用注解查看 bean 的配置及其依赖项： @Configuration public class AppConfig { @Bean public Item item1() { return new ItemImpl1(); } @Bean public Store store() { return new Store(item1()); } } @Configuration注解表明该类是 bean 定义的来源。我们还可以将它添加到多个配置类中。 我们在方法上使用*@Bean*注解来定义一个 bean。如果我们不指定自定义名称，那么 bean 名称将默认为方法名称。 对于具有默认单例范围的 bean，Spring 首先检查 bean 的缓存实例是否已经存在，如果不存在则只创建一个新实例。如果我们使用原型作用域，容器会为每个方法调用返回一个新的 bean 实例。 创建 bean 配置的另一种方法是通过 XML 配置： \u0026lt;bean id=\u0026#34;item1\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;ItemImpl1\u0026#34; index=\u0026#34;0\u0026#34; name=\u0026#34;item\u0026#34; ref=\u0026#34;item1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 6. 基于 Setter 的依赖注入 对于基于 setter 的 DI，容器会在调用无参数构造函数或无参数静态工厂方法实例化 bean 后调用我们类的 setter 方法。让我们使用注解创建这个配置： @Bean public Store store() { Store store = new Store(); store.setItem(item1()); return store; } 我们还可以将 XML 用于相同的 bean 配置： \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;item\u0026#34; ref=\u0026#34;item1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 我们可以为同一个 bean 组合基于构造函数和基于 setter 的注入类型。Spring 文档建议对强制依赖项使用基于构造函数的注入，对可选依赖项使用基于 setter 的注入。 7. 基于字段的依赖注入 对于基于字段的 DI，我们可以通过使用*@Autowired*注释标记依赖项来注入依赖项： public class Store { @Autowired private Item item; } 在构造Store对象时，如果没有构造函数或 setter 方法来注入Item bean，容器将使用反射将Item注入Store。 我们也可以使用XML 配置来实现这一点。 这种方法可能看起来更简单、更干净，但我们不建议使用它，因为它有一些缺点，例如：  该方法使用反射来注入依赖项，这比基于构造函数或基于 setter 的注入成本更高。 使用这种方法继续添加多个依赖项真的很容易。如果我们使用构造函数注入，具有多个参数会让我们认为该类做了不止一件事，这可能违反单一职责原则。  更多关于*@Autowired*注解的信息可以在Wiring In Spring文章中找到。 8. 自动装配依赖 Wiring允许 Spring 容器通过检查已定义的 bean 来自动解决协作 bean 之间的依赖关系。 使用 XML 配置自动装配 bean 有四种模式：  no：默认值——这意味着 bean 不使用自动装配，我们必须显式命名依赖项。 byName：自动装配是基于属性的名称完成的，因此 Spring 将查找与需要设置的属性名称相同的 bean。 byType：类似于byName自动装配，仅基于属性的类型。这意味着 Spring 将寻找具有相同类型属性的 bean 来设置。如果该类型的 bean 不止一个，框架会抛出异常。 constructor：自动装配是基于构造函数参数完成的，这意味着 Spring 将寻找与构造函数参数具有相同类型的 bean。  例如，让我们将上面定义的item1 bean 按类型自动装配到store bean 中： @Bean(autowire = Autowire.BY_TYPE) public class Store { private Item item; public setItem(Item item){ this.item = item; } } 我们还可以使用*@Autowired*注解注入 bean，以便按类型自动装配： public class Store { @Autowired private Item item; } 如果有多个相同类型的 bean，我们可以使用*@Qualifier*注解按名称引用一个 bean： public class Store { @Autowired @Qualifier(\u0026#34;item1\u0026#34;) private Item item; } 现在让我们通过 XML 配置按类型自动装配 bean： \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 接下来，让我们通过 XML将一个名为item的 bean 按名称注入到store bean 的**item属性中： \u0026lt;bean id=\u0026#34;item\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 我们还可以通过构造函数参数或设置器显式定义依赖项来覆盖自动装配。 9. 延迟初始化 Bean 默认情况下，容器在初始化期间创建和配置所有单例 bean。为了避免这种情况，我们可以在 bean 配置中使用值为true的延迟初始化属性： \u0026lt;bean id=\u0026#34;item1\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; lazy-init=\u0026#34;true\u0026#34; /\u0026gt; 因此，item1 bean 只会在第一次被请求时被初始化，而不是在启动时被初始化。这样做的好处是更快的初始化时间，但代价是在请求 bean 之前我们不会发现任何配置错误，这可能是应用程序已经运行后的几个小时甚至几天。 ","permalink":"http://itcodingman.github.io/inversion-control-and-dependency-injection-in-spring/","tags":["Spring Core Basics","Spring DI"],"title":"Spring 控制反转和依赖注入简介"},{"categories":["Spring Security","REST"],"contents":"使用 Spring Security 的 REST 服务的基本和摘要式身份验证 1. 概述 本文讨论如何在REST API 的相同 URI 结构上设置基本身份验证和摘要式身份验证。在之前的文章中，我们讨论了另一种保护 REST 服务的方法——基于表单的身份验证，因此基本和摘要式身份验证是自然的选择，也是更 RESTful 的一种。 2. 基本认证的配置 基于表单的身份验证不适合 RESTful 服务的主要原因是 Spring Security 将使用 Sessions——这当然是服务器上的状态，因此REST 中的无状态约束实际上被忽略了。 我们将从设置基本身份验证开始——首先我们从主**安全元素中删除旧的自定义入口点和过滤器： \u0026lt;http create-session=\u0026#34;stateless\u0026#34;\u0026gt; \u0026lt;intercept-url pattern=\u0026#34;/api/admin/**\u0026#34; access=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;http-basic /\u0026gt; \u0026lt;/http\u0026gt; 请注意如何使用单个配置行添加对基本身份验证的支持 -  - 它处理BasicAuthenticationFilter和BasicAuthenticationEntryPoint的创建和连接。 2.1 满足无状态约束——摆脱会话 RESTful 架构风格的主要限制之一是客户端-服务器通信是完全无状态的，正如原始论文所述：  5.1.3 无状态 我们接下来为客户端-服务器交互添加一个约束：通信本质上必须是无状态的，如第 3.4.3 节（图 5-3）中的客户端-无状态-服务器（CSS）样式，这样从客户端到的每个请求服务器必须包含理解请求所需的所有信息，并且不能利用服务器上存储的任何上下文。因此，会话状态完全保留在客户端上。  服务端Session的概念在 Spring Security 中是一个由来已久的概念，直到现在完全移除它一直很困难，尤其是在使用命名空间进行配置的情况下。 然而，Spring Security为命名空间配置增加了一个用于创建会话的新无状态选项，这有效地保证了 Spring 不会创建或使用任何会话。这个新选项的作用是完全从安全过滤器链中删除所有与会话相关的过滤器，确保为每个请求执行身份验证。 3. 摘要认证的配置 从前面的配置开始，设置摘要认证所需的过滤器和入口点将被定义为 bean。然后，摘要入口点将覆盖由\u0026lt;http-basic\u0026gt;在幕后创建的入口点。最后，自定义摘要过滤器将被引入安全过滤器链中，使用安全命名空间的after语义将其直接定位在基本身份验证过滤器之后。 \u0026lt;http create-session=\u0026#34;stateless\u0026#34; entry-point-ref=\u0026#34;digestEntryPoint\u0026#34;\u0026gt; \u0026lt;intercept-url pattern=\u0026#34;/api/admin/**\u0026#34; access=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;http-basic /\u0026gt; \u0026lt;custom-filter ref=\u0026#34;digestFilter\u0026#34; after=\u0026#34;BASIC_AUTH_FILTER\u0026#34; /\u0026gt; \u0026lt;/http\u0026gt; \u0026lt;beans:bean id=\u0026#34;digestFilter\u0026#34; class= \u0026#34;org.springframework.security.web.authentication.www.DigestAuthenticationFilter\u0026#34;\u0026gt; \u0026lt;beans:property name=\u0026#34;userDetailsService\u0026#34; ref=\u0026#34;userService\u0026#34; /\u0026gt; \u0026lt;beans:property name=\u0026#34;authenticationEntryPoint\u0026#34; ref=\u0026#34;digestEntryPoint\u0026#34; /\u0026gt; \u0026lt;/beans:bean\u0026gt; \u0026lt;beans:bean id=\u0026#34;digestEntryPoint\u0026#34; class= \u0026#34;org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint\u0026#34;\u0026gt; \u0026lt;beans:property name=\u0026#34;realmName\u0026#34; value=\u0026#34;Contacts Realm via Digest Authentication\u0026#34;/\u0026gt; \u0026lt;beans:property name=\u0026#34;key\u0026#34; value=\u0026#34;acegi\u0026#34; /\u0026gt; \u0026lt;/beans:bean\u0026gt; \u0026lt;authentication-manager\u0026gt; \u0026lt;authentication-provider\u0026gt; \u0026lt;user-service id=\u0026#34;userService\u0026#34;\u0026gt; \u0026lt;user name=\u0026#34;eparaschiv\u0026#34; password=\u0026#34;eparaschiv\u0026#34; authorities=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;user name=\u0026#34;user\u0026#34; password=\u0026#34;user\u0026#34; authorities=\u0026#34;ROLE_USER\u0026#34; /\u0026gt; \u0026lt;/user-service\u0026gt; \u0026lt;/authentication-provider\u0026gt; \u0026lt;/authentication-manager\u0026gt; 不幸的是，安全命名空间中不支持自动配置摘要式身份验证，就像可以使用\u0026lt;http-basic\u0026gt;配置基本身份验证一样。因此，必须手动定义必要的 bean 并将其连接到安全配置中。 4. 在同一个Restful服务中同时支持两种认证协议 单独的 Basic 或 Digest 身份验证可以在 Spring Security 中轻松实现；它在相同的 URI 映射上为相同的 RESTful Web 服务支持它们，这为服务的配置和测试引入了新的复杂性。 4.1 匿名请求 使用安全链中的基本过滤器和摘要过滤器，Spring Security 处理匿名请求（不包含身份验证凭据（授权HTTP 标头）的请求）的方式是，两个身份验证过滤器将找不到凭据并继续执行过滤链。然后，查看请求是如何未经过身份验证的，会抛出AccessDeniedException并在ExceptionTranslationFilter中捕获，它会启动摘要入口点，提示客户端输入凭据。 基本过滤器和摘要过滤器的职责都非常狭窄——如果它们无法识别请求中身份验证凭据的类型，它们将继续执行安全过滤器链。正因为如此，Spring Security 可以灵活地配置为支持同一 URI 上的多个身份验证协议。 当请求包含正确的身份验证凭据（基本或摘要）时，将正确使用该协议。但是，对于匿名请求，客户端只会收到摘要式身份验证凭据的提示。这是因为摘要入口点被配置为 Spring Security 链的主要和单一入口点；因此可以将摘要身份验证视为默认设置。 4.2 带有身份验证凭据的请求 带有 Basic 身份验证凭据的请求将由Authorization标头标识，该标头以前缀Basic开头。处理此类请求时，凭据将在基本身份验证过滤器中解码，并且请求将被授权。同样，带有摘要身份验证凭据的请求将使用前缀摘要作为其授权标头。 5. 测试两种场景 在使用基本或摘要进行身份验证后，测试将通过创建新资源来使用 REST 服务： @Test public void givenAuthenticatedByBasicAuth_whenAResourceIsCreated_then201IsReceived(){ // Given  // When  Response response = given() .auth().preemptive().basic( ADMIN_USERNAME, ADMIN_PASSWORD ) .contentType( HttpConstants.MIME_JSON ).body( new Foo( randomAlphabetic( 6 ) ) ) .post( paths.getFooURL() ); // Then  assertThat( response.getStatusCode(), is( 201 ) ); } @Test public void givenAuthenticatedByDigestAuth_whenAResourceIsCreated_then201IsReceived(){ // Given  // When  Response response = given() .auth().digest( ADMIN_USERNAME, ADMIN_PASSWORD ) .contentType( HttpConstants.MIME_JSON ).body( new Foo( randomAlphabetic( 6 ) ) ) .post( paths.getFooURL() ); // Then  assertThat( response.getStatusCode(), is( 201 ) ); } 请注意，使用基本身份验证的测试会抢先将凭据添加到请求中，无论服务器是否已对身份验证提出质疑。这是为了确保服务器不需要向客户端质询凭据，因为如果需要，质询将针对 Digest 凭据，因为这是默认设置。 ","permalink":"http://itcodingman.github.io/basic-and-digest-authentication-for-a-rest-api-with-spring-security/","tags":["Authentication"],"title":"使用 Spring Security 的 REST 服务的基本和摘要式身份验证"},{"categories":[],"contents":"扫雷——pygame项目实战   ","permalink":"http://itcodingman.github.io/pygame_minesweeper/","tags":[],"title":"扫雷——pygame项目实战"},{"categories":["Spring","REST"],"contents":"Spring中的REST分页 1. 概述 本教程将重点介绍使用 Spring MVC 和 Spring Data 在 REST API 中实现分页。 2. 页面作为资源与页面作为表示 在 RESTful 架构的上下文中设计分页时的第一个问题是，是否将页面视为实际资源或只是资源的表示。 将页面本身视为资源会带来许多问题，例如不再能够在调用之间唯一标识资源。这一点，再加上在持久层中，页面不是一个适当的实体，而是一个在必要时构建的持有者，这使得选择变得简单；页面是表示的一部分。 REST 上下文中分页设计的下一个问题是在哪里包含分页信息：  在 URI 路径中：/foo/page/1 URI 查询：/foo?page=1  请记住，页面不是 Resource，因此无法在 URI 中对页面信息进行编码。 我们将使用标准方法通过在 URI 查询中编码分页信息来解决这个问题。 3. 控制器 现在进行实施用于分页的 Spring MVC 控制器很简单： @GetMapping(params = { \u0026#34;page\u0026#34;, \u0026#34;size\u0026#34; }) public List\u0026lt;Foo\u0026gt; findPaginated(@RequestParam(\u0026#34;page\u0026#34;) int page, @RequestParam(\u0026#34;size\u0026#34;) int size, UriComponentsBuilder uriBuilder, HttpServletResponse response) { Page\u0026lt;Foo\u0026gt; resultPage = service.findPaginated(page, size); if (page \u0026gt; resultPage.getTotalPages()) { throw new MyResourceNotFoundException(); } eventPublisher.publishEvent(new PaginatedResultsRetrievedEvent\u0026lt;Foo\u0026gt;( Foo.class, uriBuilder, response, page, resultPage.getTotalPages(), size)); return resultPage.getContent(); } 在此示例中，我们 通过@RequestParam在 Controller 方法中注入两个查询参数size和page。 或者，我们可以使用Pageable对象，它自动映射page、 size和sort参数。此外，PagingAndSortingRepository实体提供了开箱即用的方法，支持使用Pageable作为参数。 我们还注入了 Http Response 和UriComponentsBuilder来帮助实现可发现性，我们通过自定义事件将其解耦。如果这不是 API 的目标，我们可以简单地删除自定义事件。 最后，注意本文的重点只是REST和web层；要深入了解分页的数据访问部分，我们可以查看这篇关于使用 Spring Data 进行分页的文章。 4. REST 分页的可发现性 在分页范围内，满足REST 的 HATEOAS 约束意味着 API 的客户端能够根据导航中的当前页面发现下一页和上一页。为此，我们将使用Link HTTP 标头，以及“下一个”、 “上一个”、“第一个”和“最后一个”链接关系类型。 在 REST 中，可发现性是一个横切关注点，不仅适用于特定操作，还适用于操作类型。例如，每次创建资源时，客户端应该可以发现该资源的 URI。由于此要求与 ANY Resource 的创建相关，因此我们将单独处理它。 正如我们在上一篇文章中讨论的那样，我们将使用事件来解耦这些关注点，重点是 REST 服务的可发现性。在分页的情况下，事件PaginatedResultsRetrievedEvent在控制器层中触发。然后，我们将使用此事件的自定义侦听器实现可发现性。 简而言之，监听器将检查导航是否允许下一页、 上一页、 第一页 和 最后一页。如果是这样，它会将相关的 URI 作为“链接”HTTP Header 添加到响应中。 现在让我们一步一步来。从控制器传递的UriComponentsBuilder仅包含基本 URL（主机、端口和上下文路径）。因此，我们必须添加其余部分： void addLinkHeaderOnPagedResourceRetrieval( UriComponentsBuilder uriBuilder, HttpServletResponse response, Class clazz, int page, int totalPages, int size ){ String resourceName = clazz.getSimpleName().toString().toLowerCase(); uriBuilder.path( \u0026#34;/admin/\u0026#34; + resourceName ); // ...  } 接下来，我们将使用StringJoiner 连接每个链接。我们将使用uriBuilder来生成 URI。让我们看看我们如何处理到下一页的链接： StringJoiner linkHeader = new StringJoiner(\u0026#34;, \u0026#34;); if (hasNextPage(page, totalPages)){ String uriForNextPage = constructNextPageUri(uriBuilder, page, size); linkHeader.add(createLinkHeader(uriForNextPage, \u0026#34;next\u0026#34;)); } 我们看一下 constructNextPageUri方法的逻辑： String constructNextPageUri(UriComponentsBuilder uriBuilder, int page, int size) { return uriBuilder.replaceQueryParam(PAGE, page + 1) .replaceQueryParam(\u0026#34;size\u0026#34;, size) .build() .encode() .toUriString(); } 我们将对我们想要包含的其余 URI 进行类似的处理。 最后，我们将输出添加为响应标头： response.addHeader(\u0026#34;Link\u0026#34;, linkHeader.toString()); 请注意，为简洁起见，仅包含部分代码示例。 5. 分页 分页和可发现性的主要逻辑都包含在小型、集中的集成测试中。与上一篇文章一样，我们将使用 REST-assured 库来使用 REST 服务并验证结果。 这些是分页集成测试的一些示例： @Test public void whenResourcesAreRetrievedPaged_then200IsReceived(){ Response response = RestAssured.get(paths.getFooURL() + \u0026#34;?page=0\u0026amp;size=2\u0026#34;); assertThat(response.getStatusCode(), is(200)); } @Test public void whenPageOfResourcesAreRetrievedOutOfBounds_then404IsReceived(){ String url = getFooURL() + \u0026#34;?page=\u0026#34; + randomNumeric(5) + \u0026#34;\u0026amp;size=2\u0026#34;; Response response = RestAssured.get.get(url); assertThat(response.getStatusCode(), is(404)); } @Test public void givenResourcesExist_whenFirstPageIsRetrieved_thenPageContainsResources(){ createResource(); Response response = RestAssured.get(paths.getFooURL() + \u0026#34;?page=0\u0026amp;size=2\u0026#34;); assertFalse(response.body().as(List.class).isEmpty()); } 6. 分页可发现性 测试分页是否可以被客户发现是相对简单的，尽管有很多内容需要覆盖。 测试将关注当前页面在导航中的位置，以及应该从每个位置发现的不同 URI： @Test public void whenFirstPageOfResourcesAreRetrieved_thenSecondPageIsNext(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToNextPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;next\u0026#34;); assertEquals(getFooURL()+\u0026#34;?page=1\u0026amp;size=2\u0026#34;, uriToNextPage); } @Test public void whenFirstPageOfResourcesAreRetrieved_thenNoPreviousPage(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToPrevPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;prev\u0026#34;); assertNull(uriToPrevPage ); } @Test public void whenSecondPageOfResourcesAreRetrieved_thenFirstPageIsPrevious(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=1\u0026amp;size=2\u0026#34;); String uriToPrevPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;prev\u0026#34;); assertEquals(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;, uriToPrevPage); } @Test public void whenLastPageOfResourcesIsRetrieved_thenNoNextPageIsDiscoverable(){ Response first = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToLastPage = extractURIByRel(first.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;last\u0026#34;); Response response = RestAssured.get(uriToLastPage); String uriToNextPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;next\u0026#34;); assertNull(uriToNextPage); } 7. 获取所有资源 在分页和可发现性的同一主题上，必须做出选择，是允许客户端一次检索系统中的所有资源，还是客户端必须分页请求它们。 如果确定客户端无法通过单个请求检索所有资源，并且需要分页，那么有几个选项可用于响应以获取请求。一种选择是返回 404 ( Not Found ) 并使用Link标头使第一页可发现：  链接=http://localhost:8080/rest/api/admin/foo?page=0\u0026size=2; rel=”first”, http://localhost:8080/rest/api/admin/foo?page=103\u0026size=2; 相对=“最后”  另一种选择是将重定向 303 （请参阅其他）返回到第一页。更保守的方法是简单地为 GET 请求返回 405（不允许的方法）给客户端。 8. 带有Range HTTP 标头的 REST 分页 实现分页的一种相对不同的方式是使用HTTP Range标头、 Range、Content-Range、If-Range、Accept-Ranges和HTTP 状态代码、 206（部分内容）、413（请求实体太大）和416（请求的范围不可满足）。 这种方法的一种观点是，HTTP Range 扩展不用于分页，它们应该由服务器管理，而不是由应用程序管理。基于 HTTP Range 标头扩展实现分页在技术上是可行的，尽管不像本文中讨论的实现那样普遍。 9. Spring Data REST 分页 在 Spring Data 中，如果我们需要从完整的数据集中返回一些结果，我们可以使用任何Pageable存储库方法，因为它总是返回一个Page。将根据页码、页面大小和排序方向返回结果。 Spring Data REST自动识别page, size, sort等URL 参数。 要使用任何存储库的分页方法，我们需要扩展PagingAndSortingRepository： public interface SubjectRepository extends PagingAndSortingRepository\u0026lt;Subject, Long\u0026gt;{} 如果我们调用 http://localhost:8080/subjects， Spring 会自动通过 API添加page, size, sort参数建议： \u0026#34;_links\u0026#34; : { \u0026#34;self\u0026#34; : { \u0026#34;href\u0026#34; : \u0026#34;http://localhost:8080/subjects{?page,size,sort}\u0026#34;, \u0026#34;templated\u0026#34; : true } } 默认情况下，页面大小为 20，但我们可以通过调用类似http://localhost:8080/subjects?page=10 的方法来更改它。 如果我们想在我们自己的自定义存储库 API 中实现分页，我们需要传递一个额外的Pageable参数并确保 API 返回一个Page： @RestResource(path = \u0026#34;nameContains\u0026#34;) public Page\u0026lt;Subject\u0026gt; findByNameContaining(@Param(\u0026#34;name\u0026#34;) String name, Pageable p); 每当我们添加自定义 API 时，都会将/search端点添加到生成的链接中。因此，如果我们调用 http://localhost:8080/subjects/search，我们将看到一个支持分页的端点： \u0026#34;findByNameContaining\u0026#34; : { \u0026#34;href\u0026#34; : \u0026#34;http://localhost:8080/subjects/search/nameContains{?name,page,size,sort}\u0026#34;, \u0026#34;templated\u0026#34; : true } 所有实现 PagingAndSortingRepository的 API都会返回一个Page。如果我们需要从Page返回结果列表， Page的getContent() API提供了作为 Spring Data REST API 结果获取的记录列表。 10. 将List转换为Page 假设我们有一个Pageable对象作为输入，但是我们需要检索的信息包含在一个列表而不是PagingAndSortingRepository中。在这些情况下，我们可能需要将List转换为Page。 例如，假设我们有一个SOAP服务的结果列表： List\u0026lt;Foo\u0026gt; list = getListOfFooFromSoapService(); 我们需要访问发送给我们的Pageable对象指定的特定位置的列表。所以让我们定义开始索引： int start = (int) pageable.getOffset(); 和结束索引： int end = (int) ((start + pageable.getPageSize()) \u0026gt; fooList.size() ? fooList.size() : (start + pageable.getPageSize())); 有了这两个，我们可以创建一个Page来获取它们之间的元素列表： Page\u0026lt;Foo\u0026gt; page = new PageImpl\u0026lt;Foo\u0026gt;(fooList.subList(start, end), pageable, fooList.size()); 而已！我们现在可以将page作为有效结果返回。 请注意，如果我们还想支持排序，我们需要在子列表之前对列表进行排序。 ","permalink":"http://itcodingman.github.io/rest-api-pagination-in-spring/","tags":["Pagination"],"title":"Spring中的REST分页"},{"categories":["Spring","REST"],"contents":"使用 Spring 5 创建 Web 应用程序 1. 概述 本教程说明了如何使用 Spring 创建 Web 应用程序。 我们将研究用于构建应用程序的 Spring Boot 解决方案，并查看非 Spring Boot 方法。 我们将主要使用 Java 配置，但也会看看它们等效的 XML 配置。 2. 使用 Spring Boot 进行设置 2.1 Maven 依赖 首先，我们需要spring-boot-starter-web 依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 该启动器包括：  spring-web和 Spring Web 应用程序所需的spring-webmvc模块 一个 Tomcat 启动器，这样我们就可以直接运行我们的 Web 应用程序，而无需显式安装任何服务器  2.2. 创建一个 Spring Boot 应用程序 开始使用 Spring Boot 最直接的方法是创建一个主类并使用 @SpringBootApplication对其进行注释： @SpringBootApplication public class SpringBootRestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootRestApplication.class, args); } } 此单个注解等效于使用@Configuration、@EnableAutoConfiguration和@ComponentScan。 默认情况下，它将扫描同一包或以下的所有组件。 接下来，对于 Spring beans 的基于 Java 的配置，我们需要创建一个配置类并使用@Configuration注解对其进行注解： @Configuration public class WebConfig { } 这个注解是基于 Java 的 Spring 配置使用的主要工件；它本身使用@Component进行元注释，这使得带注释的类成为标准 bean，因此也是组件扫描的候选对象。 @Configuration类的主要目的是作为 Spring IoC 容器的 bean 定义的来源。更详细的描述请参见官方文档。 让我们也看看使用核心spring-webmvc库的解决方案。 3. 使用 spring-webmvc 进行设置 3.1 Maven 依赖项 首先，我们需要spring-webmvc依赖： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3.2 基于 Java 的 Web 配置 接下来，我们将添加具有@Configuration注解的配置类： @Configuration @EnableWebMvc @ComponentScan(basePackages = \u0026#34;com.codingman.controller\u0026#34;) public class WebConfig { } 在这里，与 Spring Boot 解决方案不同，我们必须显式定义@EnableWebMvc以设置默认 Spring MVC 配置和@ComponentScan以指定要扫描组件的包。 @EnableWebMvc注解提供Spring Web MVC配置，例如设置调度程序 servlet、启用@Controller和@RequestMapping注解以及设置其他默认值。 @ComponentScan配置组件扫描指令，指定要扫描的包。 3.3 初始化器类 接下来，我们需要添加一个实现 WebApplicationInitializer接口的类： public class AppInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext container) throws ServletException { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.scan(\u0026#34;com.codingman\u0026#34;); container.addListener(new ContextLoaderListener(context)); ServletRegistration.Dynamic dispatcher = container.addServlet(\u0026#34;mvc\u0026#34;, new DispatcherServlet(context)); dispatcher.setLoadOnStartup(1); dispatcher.addMapping(\u0026#34;/\u0026#34;); } } 在这里，我们使用 AnnotationConfigWebApplicationContext类创建一个 Spring 上下文，这意味着我们只使用基于注释的配置。然后，我们指定要扫描组件和配置类的包。 最后，我们定义了 Web 应用程序的入口点——DispatcherServlet。 此类可以完全替换Servlet 3.0版本的web.xml文件。 4. XML 配置 让我们快速看一下等效的 XML Web 配置： \u0026lt;context:component-scan base-package=\u0026#34;com.codingman.controller\u0026#34; /\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; 我们可以用上面的WebConfig类替换这个 XML 文件。 要启动应用程序，我们可以使用加载 XML 配置或 web.xml 文件的 Initializer 类。有关这两种方法的更多详细信息，请查看之前的文章。 ","permalink":"http://itcodingman.github.io/bootstraping-a-web-application-with-spring-and-java-based-configuration/","tags":["Spring 5"],"title":"使用 Spring 5 创建 Web 应用程序"},{"categories":["Spring Persistence"],"contents":"使用 Spring 引导 Hibernate 5 1. 概述 在本文中，我们将讨论如何使用 Spring 引导 Hibernate 5，同时使用 Java 和 XML 配置。 文章 Spring Boot with Hibernate 描述了如何在 Spring Boot 中使用 Hibernate。 2. Spring集成 使用本机 Hibernate API引导SessionFactory有点复杂，需要我们编写好几行代码（请查看官方文档）。 幸运的是，Spring支持引导SessionFactory因此我们只需要几行 Java 代码或 XML 配置。 3. Maven依赖 让我们首先将必要的依赖项添加到我们的pom.xml中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.2.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring-orm 模块提供了 Spring 与 Hibernate 的集成： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-orm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为简单起见，我们将使用H2作为我们的数据库： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.197\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 最后，我们将使用Tomcat JDBC 连接池，它比Spring 提供的DriverManagerDataSource更适合生产目的： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-dbcp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4.配置 如前所述，Spring 支持我们引导 Hibernate SessionFactory。 我们所要做的就是定义一些 bean 以及一些参数。 使用 Spring，我们为这些配置提供了两种选择，一种基于 Java 的方式，一种基于 XML 的方式。 4.1。使用 Java 配置 对于将 Hibernate 5 与 Spring 一起使用，自Hibernate 4以来几乎没有变化：我们必须使用包org.springframework.orm.hibernate5中的LocalSessionFactoryBean而不是org.springframework.orm.hibernate4。 与之前的 Hibernate 4 一样，我们必须为LocalSessionFactoryBean、DataSource和PlatformTransactionManager定义 bean ，以及一些 Hibernate 特定的属性。 让我们创建HibernateConfig类来使用 Spring 配置 Hibernate 5： @Configuration @EnableTransactionManagement public class HibernateConf { @Bean public LocalSessionFactoryBean sessionFactory() { LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); sessionFactory.setPackagesToScan( {\u0026#34;com.codingman.hibernate.bootstrap.model\u0026#34; }); sessionFactory.setHibernateProperties(hibernateProperties()); return sessionFactory; } @Bean public DataSource dataSource() { BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\u0026#34;org.h2.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:h2:mem:db;DB_CLOSE_DELAY=-1\u0026#34;); dataSource.setUsername(\u0026#34;sa\u0026#34;); dataSource.setPassword(\u0026#34;sa\u0026#34;); return dataSource; } @Bean public PlatformTransactionManager hibernateTransactionManager() { HibernateTransactionManager transactionManager = new HibernateTransactionManager(); transactionManager.setSessionFactory(sessionFactory().getObject()); return transactionManager; } private final Properties hibernateProperties() { Properties hibernateProperties = new Properties(); hibernateProperties.setProperty( \u0026#34;hibernate.hbm2ddl.auto\u0026#34;, \u0026#34;create-drop\u0026#34;); hibernateProperties.setProperty( \u0026#34;hibernate.dialect\u0026#34;, \u0026#34;org.hibernate.dialect.H2Dialect\u0026#34;); return hibernateProperties; } } 4.2. 使用 XML 配置 作为次要选项，我们还可以使用基于 XML 的配置来配置 Hibernate 5： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;sessionFactory\u0026#34; class=\u0026#34;org.springframework.orm.hibernate5.LocalSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packagesToScan\u0026#34; value=\u0026#34;com.codingman.hibernate.bootstrap.model\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;hibernateProperties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.hbm2ddl.auto\u0026#34;\u0026gt; create-drop \u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.dialect\u0026#34;\u0026gt; org.hibernate.dialect.H2Dialect \u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;org.h2.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:h2:mem:db;DB_CLOSE_DELAY=-1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.orm.hibernate5.HibernateTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sessionFactory\u0026#34; ref=\u0026#34;sessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 正如我们很容易看到的那样，我们定义的 bean 和参数与前面基于 Java 的配置完全相同。 要将 XML 引导到 Spring 上下文中，如果应用程序配置了 Java 配置，我们可以使用一个简单的 Java 配置文件： @Configuration @EnableTransactionManagement @ImportResource({\u0026#34;classpath:hibernate5Configuration.xml\u0026#34;}) public class HibernateXMLConf { // } 或者，如果整体配置是纯 XML，我们可以简单地将 XML 文件提供给 Spring 上下文。 5. 用法 至此，Hibernate 5 完全配置了 Spring，我们可以在需要时直接注入原始的 Hibernate SessionFactory ： public abstract class BarHibernateDAO { @Autowired private SessionFactory sessionFactory; // ... } 6. 支持的数据库 不幸的是，Hibernate 项目并没有完全提供支持数据库的官方列表。 话虽如此，很容易看出是否支持特定的数据库类型，我们可以查看支持的方言列表。 ","permalink":"http://itcodingman.github.io/hibernate-5-spring/","tags":["Hibernate"],"title":"使用 Spring 引导 Hibernate 5"},{"categories":[],"contents":"C++中地址和引用的区别   ","permalink":"http://itcodingman.github.io/c_plus_point_reference_diffrence/","tags":[],"title":"C++中地址和引用的区别"},{"categories":[],"contents":"10分钟学习PyScript   ","permalink":"http://itcodingman.github.io/10_mins_pyscript/","tags":[],"title":"10分钟学习PyScript"},{"categories":[],"contents":"20分钟学习Ant安装和使用   ","permalink":"http://itcodingman.github.io/20_mins_ant/","tags":[],"title":"20分钟学习Ant安装和使用"},{"categories":[],"contents":"30分钟学习MyBatis通用CRUD Mapper   ","permalink":"http://itcodingman.github.io/30_mins_mybatis_generic_mapper/","tags":[],"title":"30分钟学习MyBatis通用CRUD Mapper"},{"categories":[],"contents":"15分钟学习MyBatis Generator   ","permalink":"http://itcodingman.github.io/15_mins_mybatis_generator/","tags":[],"title":"15分钟学习MyBatis Generator"},{"categories":[],"contents":"15分钟学习Spring Boot和MyBatis   ","permalink":"http://itcodingman.github.io/15_mins_spring_boot_mybatis/","tags":[],"title":"15分钟学习Spring Boot和MyBatis"},{"categories":[],"contents":"15分钟学习Spring和MyBatis   ","permalink":"http://itcodingman.github.io/15_mins_spring_mybatis/","tags":[],"title":"15分钟学习Spring和MyBatis"},{"categories":[],"contents":"40分钟学习MyBatis   ","permalink":"http://itcodingman.github.io/40_mins_mybatis/","tags":[],"title":"40分钟学习MyBatis"},{"categories":[],"contents":"40分钟学习Spring Boot Web   ","permalink":"http://itcodingman.github.io/40_mins_spring_boot_web/","tags":[],"title":"40分钟学习Spring Boot Web"},{"categories":[],"contents":"30分钟学习Spring MVC和Thymeleaf   ","permalink":"http://itcodingman.github.io/30_mins_spring_mvc_thymeleaf/","tags":[],"title":"30分钟学习Spring MVC和Thymeleaf"},{"categories":[],"contents":"50分钟学习Thymeleaf   ","permalink":"http://itcodingman.github.io/50_mins_thymeleaf/","tags":[],"title":"50分钟学习Thymeleaf"},{"categories":[],"contents":"40分钟学习JPA   ","permalink":"http://itcodingman.github.io/40_mins_jpa/","tags":[],"title":"40分钟学习JPA"},{"categories":[],"contents":"10分钟学习Spring Data JPA   ","permalink":"http://itcodingman.github.io/10_mins_spring_data_jpa/","tags":[],"title":"10分钟学习Spring Data JPA"},{"categories":[],"contents":"10分钟学习Spring JPA   ","permalink":"http://itcodingman.github.io/10_mins_spring_jpa/","tags":[],"title":"10分钟学习Spring JPA"},{"categories":[],"contents":"30分钟学习JDBC   ","permalink":"http://itcodingman.github.io/30_mins_jdbc/","tags":[],"title":"30分钟学习JDBC"},{"categories":[],"contents":"10分钟学习Spring Data JDBC   ","permalink":"http://itcodingman.github.io/10_mins_spring_data_jdbc/","tags":[],"title":"10分钟学习Spring Data JDBC"},{"categories":[],"contents":"10分钟学习Spring Boot JDBC   ","permalink":"http://itcodingman.github.io/10_mins_spring_boot_jdbc/","tags":[],"title":"10分钟学习Spring Boot JDBC"},{"categories":[],"contents":"40分钟学习Spring Boot Spring Boot 教程包括 Spring Boot 的所有主题，例如特性、项目、maven 项目、启动项目向导、Spring Initializr、CLI、应用程序、注释、依赖管理、属性、启动器、执行器等。   ","permalink":"http://itcodingman.github.io/40_mins_spring_boot/","tags":[],"title":"40分钟学习Spring Boot"},{"categories":[],"contents":"使用OpenCV和EasyOCR识别车牌   ","permalink":"http://itcodingman.github.io/opencv_easyocr_anpr/","tags":[],"title":"使用OpenCV和EasyOCR识别车牌"},{"categories":[],"contents":"30分钟学习Spring MVC #SpringMVC   ","permalink":"http://itcodingman.github.io/30_mins_spring_mvc_springmvc/","tags":[],"title":"30分钟学习Spring MVC #SpringMVC"},{"categories":[],"contents":"10分钟学习TesseractOCR   ","permalink":"http://itcodingman.github.io/10_mins_tesseractocr/","tags":[],"title":"10分钟学习TesseractOCR"},{"categories":[],"contents":"10分钟学习EasyOCR   ","permalink":"http://itcodingman.github.io/10_mins_easyocr/","tags":[],"title":"10分钟学习EasyOCR"},{"categories":[],"contents":"maven安装和使用   ","permalink":"http://itcodingman.github.io/maven_install_introduce/","tags":[],"title":"maven安装和使用"},{"categories":[],"contents":"Spring Tools 4 安装和使用   ","permalink":"http://itcodingman.github.io/spring_tools_install_introduce/","tags":[],"title":"Spring Tools 4 安装和使用"},{"categories":[],"contents":"10分钟学习Spring JDBC   ","permalink":"http://itcodingman.github.io/10_mins_spring_jdbc/","tags":[],"title":"10分钟学习Spring JDBC"},{"categories":[],"contents":"45分钟学习Spring Framework   ","permalink":"http://itcodingman.github.io/45_mins_spring_framework/","tags":[],"title":"45分钟学习Spring Framework"},{"categories":["Python"],"contents":"一小时学习python和mediapipe 这是一门针对初学者的完整课程，学习有关MediaPipe的所有知识。包括：人脸识别、匹配、手势、姿势、自拍背景等。   ","permalink":"http://itcodingman.github.io/1_hour_python_mediapipe/","tags":["Python","MediaPipe"],"title":"一小时学习python和mediapipe"},{"categories":["Python"],"contents":"一小时学习python和flask 这是一门针对初学者的完整课程，学习有关Flask的所有知识。包括：基础知识（路由、变量及URL规则、 模板、 静态文件、重定向和错误 ）和高级知识（Cookies及会话、 消息闪现、 WTF表单、文件上传、 SQLAlchemy及数据库、Sjiax）。   ","permalink":"http://itcodingman.github.io/1_hour_python_flask/","tags":["Python","Flask"],"title":"一小时学习python和flask"},{"categories":["Python"],"contents":"一小时学习python和opencv 这是一门针对初学者的完整课程，学习有关OpenCV的所有知识。包括：基础知识（图像和视频的读取、图像变换、图形绘制）和高级知识（色彩空间、位操作、直方图和边缘检测、滤波）。最后部分讲解人脸检测和识别。   ","permalink":"http://itcodingman.github.io/1_hour_python_opencv/","tags":["Python","OpenCV"],"title":"一小时学习python和opencv"},{"categories":null,"contents":"使用 Spring 和 Java Config 构建 REST API 一、概述 在本教程中，我们将学习如何**在 Spring 中设置 REST，**包括控制器和 HTTP 响应代码、有效负载编组的配置和内容协商。 进一步阅读： 使用 Spring @ResponseStatus 设置 HTTP 状态码 查看 @ResponseStatus 注释以及如何使用它来设置响应状态代码。 阅读更多→ Spring @Controller 和 @RestController 注解 了解 Spring MVC 中 @Controller 和 @RestController 注解的区别。 阅读更多→ 2. 了解 Spring 中的 REST Spring 框架支持两种创建 RESTful 服务的方式：  将 MVC 与ModelAndView一起使用 使用 HTTP 消息转换器  ModelAndView方法更老，文档更好，但也更冗长且配置繁重。它试图将 REST 范式硬塞到旧模型中，这并非没有问题。Spring 团队明白这一点，并从 Spring 3.0 开始提供一流的 REST 支持。 **新方法基于*HttpMessageConverter* 和注解，更轻量级且易于实现。**配置是最少的，它为我们对 RESTful 服务的期望提供了合理的默认值。 3. Java 配置 @Configuration @EnableWebMvc public class WebConfig{ // } 新的*@EnableWebMvc*注解做了一些有用的事情；具体来说，在 REST 的情况下，它会检测到类路径中 Jackson 和 JAXB 2 的存在，并自动创建和注册默认的 JSON 和 XML 转换器。注解的功能等同于 XML 版本： \u0026lt;mvc:注解驱动 /\u0026gt; 这是一条捷径，尽管它在许多情况下可能很有用，但并不完美。当我们需要更复杂的配置时，可以去掉注解，直接扩展WebMvcConfigurationSupport。 3.1。使用 Spring Boot 如果我们使用*@SpringBootApplication注解，并且spring-webmvc* 库位于类路径上，那么 @EnableWebMvc注解会自动添加，并带有默认的 autoconfiguration。 我们仍然可以通过在@Configuration 注释类上实现WebMvcConfigurer 接口 来将 MVC 功能添加到此配置中 。我们还可以使用 WebMvcRegistrationsAdapter实例来提供我们自己的 RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver 实现。 最后，如果我们想放弃 Spring Boot 的 MVC 特性并声明自定义配置，我们可以使用*@EnableWebMvc*注解来实现。 4. 测试 Spring 上下文 从 Spring 3.1 开始，我们获得了对@Configuration类的一流测试支持： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( classes = {WebConfig.class, PersistenceConfig.class}, loader = AnnotationConfigContextLoader.class) public class SpringContextIntegrationTest { @Test public void contextLoads(){ // When  } } 我们使用*@ContextConfiguration注解指定 Java 配置类。新的AnnotationConfigContextLoader从@Configuration*类加载 bean 定义。 请注意，WebConfig配置类未包含在测试中，因为它需要在未提供的 Servlet 上下文中运行。 4.1。使用 Spring Boot Spring Boot 提供了几个注解来以更直观的方式为我们的测试设置 Spring ApplicationContext 。 我们可以只加载应用程序配置的特定部分，也可以模拟整个上下文启动过程。 例如， 如果我们想在不启动服务器的情况下创建整个上下文，我们可以使用*@SpringBootTest注解。* 有了它，我们就可以添加*@AutoConfigureMockMvc* 来注入 MockMvc 实例并发送 HTTP 请求*：* @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class FooControllerAppIntegrationTest { @Autowired private MockMvc mockMvc; @Test public void whenTestApp_thenEmptyResponse() throws Exception { this.mockMvc.perform(get(\u0026#34;/foos\u0026#34;) .andExpect(status().isOk()) .andExpect(...); } } 为了避免创建整个上下文并只测试我们的 MVC 控制器，我们可以使用 @WebMvcTest： @RunWith(SpringRunner.class) @WebMvcTest(FooController.class) public class FooControllerWebLayerIntegrationTest { @Autowired private MockMvc mockMvc; @MockBean private IFooService service; @Test() public void whenTestMvcController_thenRetrieveExpectedResult() throws Exception { // ...  this.mockMvc.perform(get(\u0026#34;/foos\u0026#34;) .andExpect(...); } } 我们可以在“Spring Boot 中的测试”文章中找到有关此主题的详细信息。 5. 控制器 **@RestController是 RESTful API 的整个 Web 层中的核心工件*。***就本文而言，控制器正在建模一个简单的 REST 资源Foo： @RestController @RequestMapping(\u0026#34;/foos\u0026#34;) class FooController { @Autowired private IFooService service; @GetMapping public List\u0026lt;Foo\u0026gt; findAll() { return service.findAll(); } @GetMapping(value = \u0026#34;/{id}\u0026#34;) public Foo findById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return RestPreconditions.checkFound(service.findById(id)); } @PostMapping @ResponseStatus(HttpStatus.CREATED) public Long create(@RequestBody Foo resource) { Preconditions.checkNotNull(resource); return service.create(resource); } @PutMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.OK) public void update(@PathVariable( \u0026#34;id\u0026#34; ) Long id, @RequestBody Foo resource) { Preconditions.checkNotNull(resource); RestPreconditions.checkNotNull(service.getById(resource.getId())); service.update(resource); } @DeleteMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.OK) public void delete(@PathVariable(\u0026#34;id\u0026#34;) Long id) { service.deleteById(id); } } 正如我们所见，我们使用了一个简单的 Guava 风格的RestPreconditions实用程序： public class RestPreconditions { public static \u0026lt;T\u0026gt; T checkFound(T resource) { if (resource == null) { throw new MyResourceNotFoundException(); } return resource; } } Controller 实现是非公开的，因为它不需要。 通常，控制器是依赖链中的最后一个。它从 Spring 前端控制器（DispatcherServlet）接收 HTTP 请求，并将它们简单地委托给服务层。如果没有必须通过直接引用注入或操作控制器的用例，那么我们可能不希望将其声明为公共的。 请求映射很简单。与任何控制器一样，映射的实际*值*以及 HTTP 方法决定了请求的目标方法。@RequestBody将方法的参数绑定到 HTTP 请求的主体，而*@ResponseBody对响应和返回类型执行相同的操作。* @RestController 是在我们的类*中*包含 *@ResponseBody* 和 *@Controller*注释的简写*。* 他们还确保使用正确的 HTTP 转换器对资源进行编组和解组。将进行内容协商以选择将使用哪一个活动转换器，主要基于Accept标头，尽管也可以使用其他 HTTP 标头来确定表示形式。 6. 映射 HTTP 响应代码 HTTP 响应的状态码是 REST 服务最重要的部分之一，主题很快就会变得非常复杂。正确处理这些可能是服务的成败。 6.1。未映射的请求 如果 Spring MVC 接收到一个没有映射的请求，它认为该请求不允许，并返回一个 405 METHOD NOT ALLOWED 返回给客户端。 在向客户端返回405以指定允许哪些操作时，包含Allow HTTP 标头也是一种很好的做法。这是 Spring MVC 的标准行为，不需要任何额外的配置。 6.2. 有效的映射请求 对于任何具有映射的请求，Spring MVC 认为该请求有效并以 200 OK 响应，如果没有另外指定其他状态代码。 正因为如此，控制器为create、update和delete操作声明了不同的**@ResponseStatus，但没有为get声明，它确实应该返回默认的 200 OK。 6.3. 客户端错误 在客户端错误的情况下，自定义异常被定义并映射到适当的错误代码。 简单地从 web 层的任何层抛出这些异常将确保 Spring 在 HTTP 响应上映射相应的状态代码： @ResponseStatus(HttpStatus.BAD_REQUEST) public class BadRequestException extends RuntimeException { // } @ResponseStatus(HttpStatus.NOT_FOUND) public class ResourceNotFoundException extends RuntimeException { // } 这些异常是 REST API 的一部分，因此，我们应该只在与 REST 对应的适当层中使用它们；例如，如果存在 DAO/DAL 层，则不应直接使用异常。 另请注意，这些不是检查异常，而是符合 Spring 实践和习惯用法的运行时异常。 6.4. 使用*@ExceptionHandler* 将自定义异常映射到特定状态代码的另一个选项是在控制器中使用*@ExceptionHandler*注释。这种方法的问题在于注释仅适用于定义它的控制器。这意味着我们需要在每个控制器中单独声明它们。 当然，在 Spring 和 Spring Boot 中处理错误的方法更多，提供了更大的灵活性。 7. 额外的 Maven 依赖 除了标准 Web 应用程序所需的spring-webmvc依赖项之外，我们还需要为 REST API 设置内容编组和解组： \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 我们将使用这些库将 REST 资源的表示形式转换为 JSON 或 XML。 7.1。使用 Spring Boot 如果我们想检索 JSON 格式的资源，Spring Boot 提供了对不同库的支持，即 Jackson、Gson 和 JSON-B。 我们可以通过简单地在类路径中包含任何映射库来执行自动配置。 通常，如果我们正在开发一个 Web 应用程序，我们只需添加 *spring-boot-starter-web*依赖项并依赖它来将所有必要的工件包含到我们的项目中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Spring Boot 默认使用 Jackson。 如果我们想以 XML 格式序列化我们的资源，我们必须将 Jackson XML 扩展 ( jackson-dataformat-xml ) 添加到我们的依赖项中，或者通过使用回退到 JAXB 实现（JDK 中默认提供） 我们资源上的*@XmlRootElement*注释。 8. 结论 本文说明了如何使用 Spring 和基于 Java 的配置来实现和配置 REST 服务。 在本系列的下一篇文章中，我们将重点介绍API 的可发现性、高级内容协商以及使用资源的其他表示。 本文中的所有代码都可以在 Github 上找到。这是一个基于 Maven 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/building-a-restful-web-service-with-spring-and-java-based-configuration/","tags":null,"title":""},{"categories":null,"contents":"Spring REST API 的实体到 DTO 转换 一、概述 在本教程中，我们将处理需要在 Spring 应用程序的内部实体和发布回客户端的外部**DTO （数据传输对象）之间发生的转换。** 进一步阅读： Spring 的 RequestBody 和 ResponseBody 注解 了解 Spring @RequestBody 和 @ResponseBody 注释。 阅读更多→ MapStruct 快速指南 使用 MapStruct 的快速实用指南 阅读更多→ 2. 模型映射器 让我们首先介绍我们将用于执行此实体-DTO 转换的主库*ModelMapper*。 我们将在pom.xml中需要这个依赖： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.modelmapper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;modelmapper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 要检查此库是否有更新版本，[请转到此处](https://search.maven.org/classic/#search|gav|1|g%3A\u0026quot;org.modelmapper\u0026quot; AND a%3A\u0026quot;modelmapper\u0026quot;)。 然后我们将在 Spring 配置中定义ModelMapper bean： @Bean public ModelMapper modelMapper() { return new ModelMapper(); } 3. DTO 接下来我们介绍一下这个双面问题的DTO端，Post DTO： public class PostDto { private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm\u0026#34;); private Long id; private String title; private String url; private String date; private UserDto user; public Date getSubmissionDateConverted(String timezone) throws ParseException { dateFormat.setTimeZone(TimeZone.getTimeZone(timezone)); return dateFormat.parse(this.date); } public void setSubmissionDate(Date date, String timezone) { dateFormat.setTimeZone(TimeZone.getTimeZone(timezone)); this.date = dateFormat.format(date); } // standard getters and setters } 请注意，两个自定义日期相关方法处理客户端和服务器之间来回的日期转换：  getSubmissionDateConverted()方法将日期字符串转换为服务器时区中的日期，以在持久的Post实体中使用它 setSubmissionDate()方法是在当前用户时区将 DTO 的日期设置为Post的日期  4.服务层 现在让我们看一下服务级别操作，它显然适用于实体（而不是 DTO）： public List\u0026lt;Post\u0026gt; getPostsList( int page, int size, String sortDir, String sort) { PageRequest pageReq = PageRequest.of(page, size, Sort.Direction.fromString(sortDir), sort); Page\u0026lt;Post\u0026gt; posts = postRepository .findByUser(userService.getCurrentUser(), pageReq); return posts.getContent(); } 接下来我们将看一下服务之上的层，即控制器层。这是实际发生转换的地方。 5.控制器层 接下来让我们检查一个标准控制器实现，为Post资源公开简单的 REST API。 我们将在这里展示一些简单的 CRUD 操作：创建、更新、获取一个和获取所有。鉴于操作非常简单，我们对 Entity-DTO 转换方面特别感兴趣： @Controller class PostRestController { @Autowired private IPostService postService; @Autowired private IUserService userService; @Autowired private ModelMapper modelMapper; @GetMapping @ResponseBody public List\u0026lt;PostDto\u0026gt; getPosts(...) { //...  List\u0026lt;Post\u0026gt; posts = postService.getPostsList(page, size, sortDir, sort); return posts.stream() .map(this::convertToDto) .collect(Collectors.toList()); } @PostMapping @ResponseStatus(HttpStatus.CREATED) @ResponseBody public PostDto createPost(@RequestBody PostDto postDto) { Post post = convertToEntity(postDto); Post postCreated = postService.createPost(post)); return convertToDto(postCreated); } @GetMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseBody public PostDto getPost(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return convertToDto(postService.getPostById(id)); } @PutMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.OK) public void updatePost(@PathVariable(\u0026#34;id\u0026#34;) Long id, @RequestBody PostDto postDto) { if(!Objects.equals(id, postDto.getId())){ throw new IllegalArgumentException(\u0026#34;IDs don\u0026#39;t match\u0026#34;); } Post post = convertToEntity(postDto); postService.updatePost(post); } } 这是我们从*Post*实体到*PostDto*的转换： private PostDto convertToDto(Post post) { PostDto postDto = modelMapper.map(post, PostDto.class); postDto.setSubmissionDate(post.getSubmissionDate(), userService.getCurrentUser().getPreference().getTimezone()); return postDto; } 这是从 DTO 到实体的转换： private Post convertToEntity(PostDto postDto) throws ParseException { Post post = modelMapper.map(postDto, Post.class); post.setSubmissionDate(postDto.getSubmissionDateConverted( userService.getCurrentUser().getPreference().getTimezone())); if (postDto.getId() != null) { Post oldPost = postService.getPostById(postDto.getId()); post.setRedditID(oldPost.getRedditID()); post.setSent(oldPost.isSent()); } return post; } 如我们所见，在模型映射器的帮助下，**转换逻辑快速而简单。**我们正在使用映射器的地图API，并且无需编写任何转换逻辑即可转换数据。 6. 单元测试 最后，让我们做一个非常简单的测试，以确保实体和 DTO 之间的转换工作正常： public class PostDtoUnitTest { private ModelMapper modelMapper = new ModelMapper(); @Test public void whenConvertPostEntityToPostDto_thenCorrect() { Post post = new Post(); post.setId(1L); post.setTitle(randomAlphabetic(6)); post.setUrl(\u0026#34;www.test.com\u0026#34;); PostDto postDto = modelMapper.map(post, PostDto.class); assertEquals(post.getId(), postDto.getId()); assertEquals(post.getTitle(), postDto.getTitle()); assertEquals(post.getUrl(), postDto.getUrl()); } @Test public void whenConvertPostDtoToPostEntity_thenCorrect() { PostDto postDto = new PostDto(); postDto.setId(1L); postDto.setTitle(randomAlphabetic(6)); postDto.setUrl(\u0026#34;www.test.com\u0026#34;); Post post = modelMapper.map(postDto, Post.class); assertEquals(postDto.getId(), post.getId()); assertEquals(postDto.getTitle(), post.getTitle()); assertEquals(postDto.getUrl(), post.getUrl()); } } 7. 结论 在本文中，我们详细介绍了简化从 Entity 到 DTO 以及在 Spring REST API 中从 DTO 到 Entity 的转换，方法是使用模型映射器库而不是手动编写这些转换。 示例的完整源代码可在GitHub 项目中找到。 ","permalink":"http://itcodingman.github.io/entity-to-and-from-dto-for-a-java-spring-application/","tags":null,"title":""},{"categories":null,"contents":"Spring 持久性教程 Spring 和 JPA/休眠  *休眠 5 与 Spring* *在 Spring Boot 中以编程方式配置数据源* *与 Spring 和 JPA 的事务 （流行）* *Spring中的事务传播和隔离@Transactional （流行）* *Spring中的程序化事务管理* *JPA/Hibernate 持久化上下文* *带有 Spring 和 Hibernate 的 DAO* *JPA 和 Spring 的 DAO* *使用 Spring 和 Java 泛型简化 DAO* *显示来自 Spring Boot 的 Hibernate/JPA SQL 语句* *使用 Spring Boot 加载初始数据的快速指南*  春季数据 JPA  *带有 Spring Setup 的 JPA（流行）* *Spring Data JPA 简介 （通俗）* *Spring Data JPA @Query （流行）* *Spring Data JPA @Modifying 注解* *Spring Data – CrudRepository save() 方法* *Spring Data JPA Repositories 中的派生查询方法（流行）* *Spring Data JPA 删除和关系* *Spring Data JPA 和 Null 参数 * *带有 H2 数据库的 Spring Boot （流行）* *禁用 Spring Data 自动配置* *@DynamicUpdate 与 Spring Data JPA * *Spring JPA 存储库中的 LIKE 查询* *使用 Spring Data JPA 按日期和时间查询实体* *使用 JPA 和 Spring Data JPA 限制查询结果* *使用 Spring Data JPA 进行分页和排序 （流行）* *使用 Spring Data 对查询结果进行排序* *从 Spring Data JPA 存储库调用存储过程* *使用 JPA、Hibernate 和 Spring Data JPA 进行审计* *Spring Data 中 save() 和 saveAll() 的性能差异* *如何使用 Spring JPA 实现软删除* *使用 JPA 返回自动生成的 ID*  其他 Spring 持久性技术  *使用 Liquibase 安全地发展您的数据库架构* *Liquibase 回滚简介* *使用 Flyway 进行数据库迁移* *使用 Spring Data 的 Spring Boot 应用程序中的 DynamoDB* *MyBatis 与 Spring* *使用 Kotlin 和 JPA* *Spring JDBC（流行）* *在 JdbcTemplate IN 子句中使用值列表* *Spring Data REST 简介* *Spring Data JDBC简介*  春季数据 MongoDB  *Spring Data MongoDB 简介* *Spring Data MongoDB 中的查询指南* *Spring Data MongoDB——索引、注释和转换器* *Spring Data MongoDB 中的自定义级联* *Spring Data Reactive Repositories with MongoDB* *使用嵌入式 MongoDB 进行 Spring Boot 集成测试* *Spring Data MongoDB 事务*  其他 Spring 教程  REST with Spring 教程 如何使用 Spring 构建 REST 服务 Spring 异常教程 Spring 中一些最常见的异常示例——为什么会发生以及如何快速解决它们 Spring 的安全性如何保护 MVC 项目、登录和注销、如何使用 OAuth 保护 REST 服务。  ","permalink":"http://itcodingman.github.io/persistence-with-spring-series/","tags":null,"title":""},{"categories":null,"contents":"使用 Spring 进行项目配置 目录  **1.**配置必须是特定于环境的 **2.每个环境的.properties文件 **3.**弹簧配置 **4.**在每个环境中设置属性 **5.**测试和 Maven **6.**更进一步 **7.**结论  1. 配置必须是特定于环境的 配置必须是特定于环境的——这是不争的事实。如果不是这种情况，那么它就不是配置，我们只会在代码中硬编码值。 对于 Spring 应用程序，您可以使用多种解决方案——从简单的解决方案一直到超级灵活、高度复杂的替代方案。 一个更常见和直接的解决方案是灵活使用属性文件和Spring 提供的一流属性支持。 作为概念证明，出于本文的目的，我们将了解一种特定类型的属性——数据库配置。将一种类型的数据库配置用于生产，另一种用于测试，另一种用于开发环境是非常有意义的。 2.每个环境的*.properties文件* 让我们开始我们的概念证明——通过定义我们想要定位的环境：    开发 分期 生产    720 接下来 – 让我们创建 3 个属性文件 – 每个环境一个：  持久性-dev.properties 持久性-staging.properties 持久性生产.properties  在典型的 Maven 应用程序中，它们可以驻留在src/main/resources中，但是无论它们在哪里，它们都需要在部署应用程序时在类路径中可用。 一个重要的旁注——将所有属性文件置于版本控制之下，使配置更加透明和可重复。这与将配置放在磁盘上的某个地方并简单地将 Spring 指向它们相反。 3. 弹簧配置 在 Spring 中，我们将根据环境包含正确的文件： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\u0026#34;\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34; classpath*:*persistence-${envTarget}.properties\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 当然，Java 配置也可以做到这一点： @PropertySource({ \u0026#34;classpath:persistence-${envTarget:dev}.properties\u0026#34; }) 这种方法允许灵活地拥有多个**.properties*文件以用于特定的、集中的目的。例如——在我们的例子中，持久性 Spring 配置导入持久性属性——这非常有意义。安全配置将导入与安全相关的属性等。 4. 在每个环境中设置属性 最终的、可部署的战争将包含所有属性文件——对于持久性， persistence-*.properties的三个变体。由于文件实际上命名不同，因此不必担心意外包含错误的文件。我们将设置*envTarget*变量，从而从多个现有变体中选择我们想要的实例。 envTarget变量可以在操作系统/环境中设置或作为 JVM 命令行的参数*：* -DenvTarget=dev 5. 测试和 Maven 对于需要启用持久性的集成测试——我们只需在 pom.xml 中设置envTarget属性： \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;systemPropertyVariables\u0026gt; \u0026lt;envTarget\u0026gt;h2_test\u0026lt;/envTarget\u0026gt; \u0026lt;/systemPropertyVariables\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; 对应的persistence-h2_test.properties文件可以放在src/test/resources中，这样它就只会用于测试，而不是在运行时不必要地包含和部署在 war 中。 6. 更进一步 如果需要，有几种方法可以在此解决方案中增加额外的灵活性。 一种这样的方法是对属性文件的名称使用更复杂的编码，不仅指定要使用它们的环境，还指定更多信息（例如持久性提供程序）。例如，我们可能会使用以下类型的属性：persistence-h2.properties、persistence-mysql.properties ，或者更具体的：persistence-dev_h2.properties、persistence-staging_mysql.properties、persistence-production_amazonRDS.properties。 这种命名约定的优势——它只是一个约定，因为整体方法没有任何变化——只是透明。现在仅通过查看名称就可以更清楚地了解配置的作用：  *persistence-dev_h2.properties*：开发环境的持久性提供程序是一个轻量级的内存 H2 数据库 *persistence-staging_mysql.properties*：暂存环境的持久性提供程序是一个 MySQL 实例 *persistence-production_amazon_rds.propertie*：生产环境的持久性提供程序是 Amazon RDS  7. 结论 本文讨论了在 Spring 中进行环境特定配置的灵活解决方案。可以在此处找到使用配置文件的替代解决方案。 解决方案的实现可以在GitHub 项目中找到——这是一个基于 Maven 的项目，因此应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/project-configuration-with-spring/","tags":null,"title":""},{"categories":null,"contents":"Spring 和 Spring Boot 的属性 1. 概述 本教程将展示如何 通过 Java 配置和*@PropertySource*在 Spring 中设置和使用属性。 我们还将看到属性在 Spring Boot 中是如何工作的。 2. 通过注解注册一个属性文件 Spring 3.1 还引入了新的*@PropertySource*注解作为向环境添加属性源的便捷机制。 我们可以将此注解与*@Configuration*注解结合使用： @Configuration @PropertySource(\u0026#34;classpath:foo.properties\u0026#34;) public class PropertiesWithJavaConfig { //... } 注册新属性文件的另一种非常有用的方法是使用占位符，它允许我们在运行时动态选择正确的文件： @PropertySource({ \u0026#34;classpath:persistence-${envTarget:mysql}.properties\u0026#34; }) ... 2.1。定义多个属性位置 根据Java 8 约定， @PropertySource注释是可重复的。因此，如果我们使用 Java 8 或更高版本，我们可以使用这个注解来定义多个属性位置： @PropertySource(\u0026#34;classpath:foo.properties\u0026#34;) @PropertySource(\u0026#34;classpath:bar.properties\u0026#34;) public class PropertiesWithJavaConfig { //... } 当然，*我们也可以使用@PropertySources注解，指定一个@PropertySource*数组。**这适用于任何受支持的 Java 版本，而不仅仅是 Java 8 或更高版本： @PropertySources({ @PropertySource(\u0026#34;classpath:foo.properties\u0026#34;), @PropertySource(\u0026#34;classpath:bar.properties\u0026#34;) }) public class PropertiesWithJavaConfig { //... } 在任何一种情况下，值得注意的是，如果发生属性名称冲突，最后读取的源优先。 3. 使用/注入属性 *使用@Value*注释****注入属性很简单： @Value( \u0026#34;${jdbc.url}\u0026#34; ) private String jdbcUrl; 我们还可以为属性指定一个默认值： @Value( \u0026#34;${jdbc.url:aDefaultUrl}\u0026#34; ) private String jdbcUrl; Spring 3.1 中添加的新PropertySourcesPlaceholderConfigurer在 bean 定义属性值和*@Value*注释中解析 ${…} 占位符。 最后，我们可以使用*Environment* API 获取属性的值 ： @Autowired private Environment env; ... dataSource.setUrl(env.getProperty(\u0026#34;jdbc.url\u0026#34;)); 4. Spring Boot 的属性 在我们进入更高级的属性配置选项之前，让我们花一些时间来看看 Spring Boot 中的新属性支持。 一般来说，与标准 Spring 相比，这种新的支持涉及更少的配置，这当然是 Boot 的主要目标之一。 4.1。*application.properties：*默认属性文件 Boot 将其典型的约定优于配置方法应用于属性文件。这意味着我们可以简单地将*application.properties*文件放在我们的*src/main/resources* 目录中，它会被自动检测到。然后我们可以像往常一样从中注入任何加载的属性。 因此，通过使用此默认文件，我们不必显式注册PropertySource ，甚至不必提供属性文件的路径。 如果需要，我们还可以使用环境属性在运行时配置不同的文件： java -jar app.jar --spring.config.location=classpath:/another-location.properties 从Spring Boot 2.3开始，我们还可以为配置文件指定通配符位置。 例如，我们可以将 spring.config.location 属性设置为 config/*/： java -jar app.jar --spring.config.location=config/*/ 这样，Spring Boot 将在我们的 jar 文件之外查找与*config/*/ 目录模式匹配的配置文件。*当我们有多个配置属性来源时，这会派上用场。 从2.4.0版本开始，Spring Boot 支持使用多文档属性文件，类似于YAML的设计： baeldung.customProperty=defaultValue #--- baeldung.customProperty=overriddenValue 请注意，对于属性文件，三破折号表示法前面有一个注释字符 ( # )。 4.2. 环境特定的属性文件 如果我们需要针对不同的环境，Boot 中有一个内置机制。 *我们可以简单的在*src/main/resources目录下定义一个*application-environment.properties*文件，然后设置一个相同环境名的 Spring profile。 例如，如果我们定义一个“暂存”环境，这意味着我们必须定义一个暂存配置文件，然后定义application-staging.properties。 此 env 文件将被加载，**并将优先于默认属性文件。**注意还是会加载默认文件，只是当发生属性冲突时，环境特定的属性文件优先。 4.3. 测试特定的属性文件 当我们的应用程序正在测试时，我们可能还需要使用不同的属性值。 Spring Boot 通过在测试运行期间查看我们的*src/test/resources* 目录来为我们处理这个问题。同样，默认属性仍然可以正常注入，但如果发生冲突，默认属性将被这些属性覆盖。 4.4. *@TestPropertySource*注解 如果我们需要对测试属性进行更精细的控制，那么我们可以使用*@TestPropertySource*注释。 这允许我们为特定的测试上下文设置测试属性，优先于默认属性源： @RunWith(SpringRunner.class) @TestPropertySource(\u0026#34;/foo.properties\u0026#34;) public class FilePropertyInjectionUnitTest { @Value(\u0026#34;${foo}\u0026#34;) private String foo; @Test public void whenFilePropertyProvided_thenProperlyInjected() { assertThat(foo).isEqualTo(\u0026#34;bar\u0026#34;); } } 如果我们不想使用文件，我们可以直接指定名称和值： @RunWith(SpringRunner.class) @TestPropertySource(properties = {\u0026#34;foo=bar\u0026#34;}) public class PropertyInjectionUnitTest { @Value(\u0026#34;${foo}\u0026#34;) private String foo; @Test public void whenPropertyProvided_thenProperlyInjected() { assertThat(foo).isEqualTo(\u0026#34;bar\u0026#34;); } } *我们也可以使用@SpringBootTest*注解的*properties*参数来实现类似的效果： @RunWith(SpringRunner.class) @SpringBootTest( properties = {\u0026#34;foo=bar\u0026#34;}, classes = SpringBootPropertiesTestApplication.class) public class SpringBootPropertyInjectionIntegrationTest { @Value(\u0026#34;${foo}\u0026#34;) private String foo; @Test public void whenSpringBootPropertyProvided_thenProperlyInjected() { assertThat(foo).isEqualTo(\u0026#34;bar\u0026#34;); } } 4.5. 分层属性 如果我们有组合在一起的属性，我们可以使用*@ConfigurationProperties*注释，它将这些属性层次结构映射到 Java 对象图中。 让我们使用一些用于配置数据库连接的属性： database.url=jdbc:postgresql:/localhost:5432/instance database.username=foo database.password=bar 然后让我们使用注解将它们映射到数据库对象： @ConfigurationProperties(prefix = \u0026#34;database\u0026#34;) public class Database { String url; String username; String password; // standard getters and setters } Spring Boot 再次应用它的约定而不是配置方法，在属性名称及其对应字段之间自动映射。我们需要提供的只是属性前缀。 如果您想深入了解配置属性，请查看我们的深度文章。 4.6. 替代方案：YAML 文件 Spring 还支持 YAML 文件。 所有相同的命名规则都适用于特定于测试的、特定于环境的和默认属性文件。唯一的区别是文件扩展名和对我们类路径上的SnakeYAML库的依赖。 YAML 特别适合分层属性存储；以下属性文件： database.url=jdbc:postgresql:/localhost:5432/instance database.username=foo database.password=bar secret: foo 与以下 YAML 文件同义： database: url: jdbc:postgresql:/localhost:5432/instance username: foo password: bar secret: foo 还值得一提的是 YAML 文件不支持*@PropertySource*注解，所以如果我们需要使用这个注解，它会限制我们使用属性文件。 另一个值得注意的点是，在 2.4.0 版本中，Spring Boot 改变了从多文档 YAML 文件加载属性的方式。以前，它们的添加顺序基于配置文件激活顺序。然而，在新版本中，框架遵循我们之前为*.properties*文件指出的相同排序规则；在文件中声明较低的属性将简单地覆盖那些较高的属性。 此外，在此版本中，无法再从特定于配置文件的文档中激活配置文件，从而使结果更加清晰和可预测。 4.7. 导入其他配置文件 在 2.4.0 版本之前，Spring Boot 允许使用spring.config.location和 spring.config.additional-location 属性包含其他配置文件，但它们有一定的限制。例如，必须在启动应用程序之前定义它们（作为环境或系统属性，或使用命令行参数），因为它们在流程的早期使用。 在上述版本中，**我们可以使用 *application.properties* 或 *application.yml 文件中的**spring.config.import*属性来轻松包含其他文件。**这个属性支持一些有趣的特性：  添加多个文件或目录 可以从类路径或外部目录加载文件 指示如果找不到文件或者它是否是可选文件，则启动过程是否应该失败 导入无扩展名文件  让我们看一个有效的例子： spring.config.import=classpath:additional-application.properties, classpath:additional-application[.yml], optional:file:./external.properties, classpath:additional-application-properties/ 注意：为了清楚起见，我们在这里使用换行符格式化了这个属性。 Spring 会将导入视为紧接在导入声明下方插入的新文档。 4.8. 命令行参数的属性 除了使用文件，我们还可以直接在命令行中传递属性： java -jar app.jar --property=\u0026#34;value\u0026#34; 我们也可以通过系统属性来做到这一点，这些属性在*-jar*命令之前而不是之后提供： java -Dproperty.name=\u0026#34;value\u0026#34; -jar app.jar 4.9. 来自环境变量的属性 Spring Boot 还将检测环境变量，将它们视为属性： export name=value java -jar app.jar 4.10。属性值的随机化 如果我们不想要确定性属性值，我们可以使用*RandomValuePropertySource* 来随机化属性值： random.number=${random.int} random.long=${random.long} random.uuid=${random.uuid} 4.11。其他类型的财产来源 Spring Boot 支持多种属性源，实现了经过深思熟虑的排序以允许明智的覆盖。值得参考官方文档，这超出了本文的范围。 5. 使用原始 Bean 进行配置 — *PropertySourcesPlaceholderConfigurer* 除了将属性获取到 Spring 中的便捷方法外，我们还可以手动定义和注册属性配置 bean。 使用*PropertySourcesPlaceholderConfigurer*可以让我们完全控制配置，但缺点是更冗长且大多数时候是不必要的。 让我们看看如何使用 Java 配置定义这个 bean： @Bean public static PropertySourcesPlaceholderConfigurer properties(){ PropertySourcesPlaceholderConfigurer pspc = new PropertySourcesPlaceholderConfigurer(); Resource[] resources = new ClassPathResource[ ] { new ClassPathResource( \u0026#34;foo.properties\u0026#34; ) }; pspc.setLocations( resources ); pspc.setIgnoreUnresolvablePlaceholders( true ); return pspc; } 6. 父子上下文中的属性 这个问题一次又一次地出现：当我们的Web 应用程序有父上下文和子上下文时会发生什么？父上下文可能有一些共同的核心功能和 bean，然后是一个（或多个）子上下文，可能包含特定于 servlet 的 bean。 在这种情况下，定义属性文件并将它们包含在这些上下文中的最佳方法是什么？以及如何最好地从 Spring 中检索这些属性？ 我们将给出一个简单的细分。 如果文件是在父上下文中定义的：   @Value在子上下文中工作：是   @Value在父上下文中工作：是   子上下文中的environment.getProperty：是   父上下文中的environment.getProperty：是   如果文件在子上下文中定义：   @Value在子上下文中工作：是   @Value在父上下文中工作：否   子上下文中的environment.getProperty：是   父上下文中的environment.getProperty：否   7. 结论 本文展示了在 Spring 中使用属性和属性文件的几个示例。 ","permalink":"http://itcodingman.github.io/properties-with-spring/","tags":null,"title":""},{"categories":null,"contents":"Spring REST API + OAuth2 + Angular 一、概述 在本教程中，我们将使用 OAuth2 保护 REST API，并从一个简单的 Angular 客户端使用它。 我们要构建的应用程序将包含三个独立的模块：  授权服务器 资源服务器 UI 授权码：使用授权码流程的前端应用程序  **我们将在 Spring Security 5 中使用 OAuth 堆栈。**如果您想使用 Spring Security OAuth legacy stack，请查看之前的这篇文章：Spring REST API + OAuth2 + Angular（使用 Spring Security OAuth Legacy Stack）。 进一步阅读： 将 JWT 与 Spring Security OAuth 结合使用 在 Spring Security 5 中使用 JWT 令牌的指南。 阅读更多→ OAuth2.0 和动态客户端注册（使用 Spring Security OAuth 遗留堆栈） 了解如何使用 Spring Security 和 OAuth2 动态定义客户端。 阅读更多→ 让我们直接跳进去。 2. OAuth2授权服务器（AS） 简单地说，授权服务器是一个发布授权令牌的应用程序。 以前，Spring Security OAuth 堆栈提供了将授权服务器设置为 Spring 应用程序的可能性。但该项目已被弃用，主要是因为 OAuth 是一个开放标准，拥有许多成熟的供应商，例如 Okta、Keycloak 和 ForgeRock，仅举几例。 其中，我们将使用Keycloak。它是由 Red Hat 管理的开源身份和访问管理服务器，由 JBoss 用 Java 开发。它不仅支持 OAuth2，还支持其他标准协议，例如 OpenID Connect 和 SAML。 对于本教程，我们将在 Spring Boot 应用程序中设置嵌入式 Keycloak 服务器。 3. 资源服务器（RS） 现在让我们讨论资源服务器；这本质上是 REST API，我们最终希望能够使用它。 3.1。Maven 配置 我们的资源服务器的 pom 与之前的授权服务器 pom 非常相似，没有 Keycloak 部分，并具有额外的*spring-boot-starter-oauth2-resource-server*依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-oauth2-resource-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3.2. 安全配置 由于我们使用的是 Spring Boot，因此我们可以使用 Boot 属性定义所需的最低配置。 我们将在application.yml文件中执行此操作： server: port: 8081 servlet: context-path: /resource-server spring: security: oauth2: resourceserver: jwt: issuer-uri: http://localhost:8083/auth/realms/baeldung jwk-set-uri: http://localhost:8083/auth/realms/baeldung/protocol/openid-connect/certs 在这里，我们指定我们将使用 JWT 令牌进行授权。 jwk *-set-uri*属性指向包含公钥的 URI，以便我们的资源服务器可以验证令牌的完整性。 issuer-uri属性表示验证令牌颁发者（即授权服务器）的附加安全措施。但是，添加此属性还要求授权服务器应该在我们启动资源服务器应用程序之前运行。 接下来，让我们为 API 设置安全配置以保护端点： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.cors() .and() .authorizeRequests() .antMatchers(HttpMethod.GET, \u0026#34;/user/info\u0026#34;, \u0026#34;/api/foos/**\u0026#34;) .hasAuthority(\u0026#34;SCOPE_read\u0026#34;) .antMatchers(HttpMethod.POST, \u0026#34;/api/foos\u0026#34;) .hasAuthority(\u0026#34;SCOPE_write\u0026#34;) .anyRequest() .authenticated() .and() .oauth2ResourceServer() .jwt(); } } 正如我们所见，对于我们的 GET 方法，我们只允许具有读取范围的请求。对于 POST 方法，请求者除了read之外还需要有写权限。但是，对于任何其他端点，该请求应该只通过任何用户进行身份验证。 此外，**oauth2ResourceServer *()***方法指定这是一个资源服务器，带有*jwt()*格式的令牌。 这里要注意的另一点是使用方法*cors()*来允许请求上的 Access-Control 标头。这一点尤其重要，因为我们正在处理一个 Angular 客户端，并且我们的请求将来自另一个源 URL。 3.4. 模型和存储库 接下来，让我们为我们的模型Foo定义一个**javax.persistence.Entity： @Entity public class Foo { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; // constructor, getters and setters } 然后我们需要一个Foo的存储库。我们将使用 Spring 的PagingAndSortingRepository： public interface IFooRepository extends PagingAndSortingRepository\u0026lt;Foo, Long\u0026gt; { } 3.4. 服务与实施 之后，我们将为我们的 API 定义并实现一个简单的服务： public interface IFooService { Optional\u0026lt;Foo\u0026gt; findById(Long id); Foo save(Foo foo); Iterable\u0026lt;Foo\u0026gt; findAll(); } @Service public class FooServiceImpl implements IFooService { private IFooRepository fooRepository; public FooServiceImpl(IFooRepository fooRepository) { this.fooRepository = fooRepository; } @Override public Optional\u0026lt;Foo\u0026gt; findById(Long id) { return fooRepository.findById(id); } @Override public Foo save(Foo foo) { return fooRepository.save(foo); } @Override public Iterable\u0026lt;Foo\u0026gt; findAll() { return fooRepository.findAll(); } } 3.5. 示例控制器 现在让我们实现一个简单的控制器，通过 DTO公开我们的Foo资源： @RestController @RequestMapping(value = \u0026#34;/api/foos\u0026#34;) public class FooController { private IFooService fooService; public FooController(IFooService fooService) { this.fooService = fooService; } @CrossOrigin(origins = \u0026#34;http://localhost:8089\u0026#34;) @GetMapping(value = \u0026#34;/{id}\u0026#34;) public FooDto findOne(@PathVariable Long id) { Foo entity = fooService.findById(id) .orElseThrow(() -\u0026gt; new ResponseStatusException(HttpStatus.NOT_FOUND)); return convertToDto(entity); } @GetMapping public Collection\u0026lt;FooDto\u0026gt; findAll() { Iterable\u0026lt;Foo\u0026gt; foos = this.fooService.findAll(); List\u0026lt;FooDto\u0026gt; fooDtos = new ArrayList\u0026lt;\u0026gt;(); foos.forEach(p -\u0026gt; fooDtos.add(convertToDto(p))); return fooDtos; } protected FooDto convertToDto(Foo entity) { FooDto dto = new FooDto(entity.getId(), entity.getName()); return dto; } } 注意上面*@CrossOrigin*的使用；这是控制器级别的配置，我们需要允许来自我们的 Angular 应用程序的 CORS 在指定的 URL 上运行。 这是我们的FooDto： public class FooDto { private long id; private String name; } 4. 前端——设置 现在，我们将研究一个简单的客户端 Angular 前端实现，它将访问我们的 REST API。 我们将首先使用Angular CLI来生成和管理我们的前端模块。 首先，我们安装node 和 npm，因为 Angular CLI 是一个 npm 工具。 然后我们需要使用frontend-maven-plugin来使用 Maven 构建我们的 Angular 项目： \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.github.eirslett\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;frontend-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;nodeVersion\u0026gt;v6.10.2\u0026lt;/nodeVersion\u0026gt; \u0026lt;npmVersion\u0026gt;3.10.10\u0026lt;/npmVersion\u0026gt; \u0026lt;workingDirectory\u0026gt;src/main/resources\u0026lt;/workingDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;install node and npm\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;install-node-and-npm\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;npm install\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;npm\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;npm run build\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;npm\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;arguments\u0026gt;run build\u0026lt;/arguments\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 最后，使用 Angular CLI 生成一个新模块： ng new oauthApp 在下一节中，我们将讨论 Angular 应用程序逻辑。 5. 使用 Angular 的授权代码流 我们将在此处使用 OAuth2 授权代码流程。 我们的用例：客户端应用程序从授权服务器请求代码并显示登录页面。**一旦用户提供了他们的有效凭证并提交，授权服务器就会给我们代码。**然后前端客户端使用它来获取访问令牌。 5.1。家庭组件 让我们从我们的主要组件HomeComponent开始，所有动作都从这里开始： @Component({ selector: \u0026#39;home-header\u0026#39;, providers: [AppService], template: `\u0026lt;div class=\u0026#34;container\u0026#34; \u0026gt; \u0026lt;button *ngIf=\u0026#34;!isLoggedIn\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; (click)=\u0026#34;login()\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt; Login\u0026lt;/button\u0026gt; \u0026lt;div *ngIf=\u0026#34;isLoggedIn\u0026#34; class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Welcome !!\u0026lt;/span\u0026gt; \u0026lt;a class=\u0026#34;btn btn-default pull-right\u0026#34;(click)=\u0026#34;logout()\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;Logout\u0026lt;/a\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;foo-details\u0026gt;\u0026lt;/foo-details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;` }) export class HomeComponent { public isLoggedIn = false; constructor(private _service: AppService) { } ngOnInit() { this.isLoggedIn = this._service.checkCredentials(); let i = window.location.href.indexOf(\u0026#39;code\u0026#39;); if(!this.isLoggedIn \u0026amp;\u0026amp; i != -1) { this._service.retrieveToken(window.location.href.substring(i + 5)); } } login() { window.location.href = \u0026#39;http://localhost:8083/auth/realms/baeldung/protocol/openid-connect/auth? response_type=code\u0026amp;scope=openid%20write%20read\u0026amp;client_id=\u0026#39; + this._service.clientId + \u0026#39;\u0026amp;redirect_uri=\u0026#39;+ this._service.redirectUri; } logout() { this._service.logout(); } } 一开始，当用户没有登录时，只出现登录按钮。单击此按钮后，用户将导航到 AS 的授权 URL，他们在其中键入用户名和密码。成功登录后，用户将使用授权代码重定向回来，然后我们使用此代码检索访问令牌。 5.2. 应用服务 现在让我们看看*AppService——位于app.service.ts——*它包含服务器交互的逻辑：  retrieveToken()：使用授权码获取访问令牌 saveToken()：使用 ng2-cookies 库将我们的访问令牌保存在 cookie 中 getResource()：使用其 ID 从服务器获取 Foo 对象 checkCredentials() : 检查用户是否登录 logout()：删除访问令牌cookie并注销用户  export class Foo { constructor(public id: number, public name: string) { } } @Injectable() export class AppService { public clientId = \u0026#39;newClient\u0026#39;; public redirectUri = \u0026#39;http://localhost:8089/\u0026#39;; constructor(private _http: HttpClient) { } retrieveToken(code) { let params = new URLSearchParams(); params.append(\u0026#39;grant_type\u0026#39;,\u0026#39;authorization_code\u0026#39;); params.append(\u0026#39;client_id\u0026#39;, this.clientId); params.append(\u0026#39;client_secret\u0026#39;, \u0026#39;newClientSecret\u0026#39;); params.append(\u0026#39;redirect_uri\u0026#39;, this.redirectUri); params.append(\u0026#39;code\u0026#39;,code); let headers = new HttpHeaders({\u0026#39;Content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded; charset=utf-8\u0026#39;}); this._http.post(\u0026#39;http://localhost:8083/auth/realms/baeldung/protocol/openid-connect/token\u0026#39;, params.toString(), { headers: headers }) .subscribe( data =\u0026gt; this.saveToken(data), err =\u0026gt; alert(\u0026#39;Invalid Credentials\u0026#39;)); } saveToken(token) { var expireDate = new Date().getTime() + (1000 * token.expires_in); Cookie.set(\u0026#34;access_token\u0026#34;, token.access_token, expireDate); console.log(\u0026#39;Obtained Access token\u0026#39;); window.location.href = \u0026#39;http://localhost:8089\u0026#39;; } getResource(resourceUrl) : Observable\u0026lt;any\u0026gt; { var headers = new HttpHeaders({ \u0026#39;Content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded; charset=utf-8\u0026#39;, \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer \u0026#39;+Cookie.get(\u0026#39;access_token\u0026#39;)}); return this._http.get(resourceUrl, { headers: headers }) .catch((error:any) =\u0026gt; Observable.throw(error.json().error || \u0026#39;Server error\u0026#39;)); } checkCredentials() { return Cookie.check(\u0026#39;access_token\u0026#39;); } logout() { Cookie.delete(\u0026#39;access_token\u0026#39;); window.location.reload(); } } 在retrieveToken方法中，我们使用我们的客户端凭据和基本身份验证将POST发送到*/openid-connect/token*端点以获取访问令牌。参数以 URL 编码格式发送。获得访问令牌后，我们将其存储在 cookie 中。 cookie 存储在这里尤为重要，因为我们仅将 cookie 用于存储目的，而不是直接驱动身份验证过程。这有助于防止跨站点请求伪造 (CSRF) 攻击和漏洞。 5.3. Foo 组件 最后，我们的FooComponent来显示我们的 Foo 详细信息： @Component({ selector: \u0026#39;foo-details\u0026#39;, providers: [AppService], template: `\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;col-sm-12\u0026#34;\u0026gt;Foo Details\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;col-sm-12\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;col-sm-3\u0026#34;\u0026gt;ID\u0026lt;/label\u0026gt; \u0026lt;span\u0026gt;{{foo.id}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-12\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;col-sm-3\u0026#34;\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;span\u0026gt;{{foo.name}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-12\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; (click)=\u0026#34;getFoo()\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;New Foo\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;` }) export class FooComponent { public foo = new Foo(1,\u0026#39;sample foo\u0026#39;); private foosUrl = \u0026#39;http://localhost:8081/resource-server/api/foos/\u0026#39;; constructor(private _service:AppService) {} getFoo() { this._service.getResource(this.foosUrl+this.foo.id) .subscribe( data =\u0026gt; this.foo = data, error =\u0026gt; this.foo.name = \u0026#39;Error\u0026#39;); } } 5.5. 应用组件 我们简单的AppComponent作为根组件： @Component({ selector: \u0026#39;app-root\u0026#39;, template: `\u0026lt;nav class=\u0026#34;navbar navbar-default\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;navbar-header\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;navbar-brand\u0026#34; href=\u0026#34;/\u0026#34;\u0026gt;Spring Security Oauth - Authorization Code\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt;` }) export class AppComponent { } 还有我们包装所有组件、服务和路由的AppModule ： @NgModule({ declarations: [ AppComponent, HomeComponent, FooComponent ], imports: [ BrowserModule, HttpClientModule, RouterModule.forRoot([ { path: \u0026#39;\u0026#39;, component: HomeComponent, pathMatch: \u0026#39;full\u0026#39; }], {onSameUrlNavigation: \u0026#39;reload\u0026#39;}) ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 7. 运行前端 \\1. 要运行我们的任何前端模块，我们需要先构建应用程序： mvn clean install \\2. 然后我们需要导航到我们的 Angular 应用目录： cd src/main/resources \\3. 最后，我们将启动我们的应用程序： npm start 服务器将默认在端口 4200 上启动；要更改任何模块的端口，请更改： \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34; 在*package.json 中；*例如，要使其在端口 8089 上运行，请添加： \u0026#34;start\u0026#34;: \u0026#34;ng serve --port 8089\u0026#34; 8. 结论 在本文中，我们学习了如何使用 OAuth2 授权我们的应用程序。 本教程的完整实现可以在GitHub 项目中找到。 ","permalink":"http://itcodingman.github.io/securing-a-restful-web-service-with-spring-security/","tags":null,"title":""},{"categories":null,"contents":"Spring 的安全性 正如您所期望的 那样，Spring Security教程 的重点是 Spring Security。 如果您有兴趣构建注册流程并了解一些框架基础知识，请从注册系列开始。 然后，深入探索身份验证和其他 Spring Security 内部。 最后，看看一些更高级的主题，例如 OAuth 支持。 向 Spring Security 注册  Spring Security 注册教程 使用 Spring Security 构建注册流程。  使用 Spring Security 进行身份验证  *Spring Security 表单登录* *Spring Security - 基本身份验证（流行）* *表单登录 - 错误处理和本地化* *登出* *登录后重定向到不同的页面* *记得我* *Spring Security 身份验证提供程序* *如何使用 Spring Security 手动验证用户身份* *Spring Security 的额外登录字段* *Spring Security 自定义 AuthenticationFailureHandler* *使用 Spring Security 防止暴力验证尝试* *带有 React 的 Spring Security 登录页面*  核心弹簧安全  *使用 Maven 的 Spring 安全性* *Spring Security 中检索用户信息 （流行）* *Spring 安全表达式简介* *Spring Security - 安全无，过滤器无，访问permitAll* *会话管理 （流行）* *Spring方法安全性介绍（普及）* *Spring Boot 安全自动配置* *Spring Security 5 中的默认密码编码器* *查找已注册的 Spring Security 过滤器* *使用 CORS Preflights 和 Spring Security 修复 401* *防止 Spring 应用程序中的跨站点脚本 (XSS)*  带有 Spring Security 的 OAuth2  Spring Security OAuth 2 指南 通过 Spring Security 了解 OAuth2，同时使用 Spring Security 5 堆栈以及 Spring Security OAuth 遗留堆栈。  其他 Spring 教程  REST with Spring 教程 如何使用 Spring 构建 REST 服务 Persistence with Spring Tutorial 如何使用 Spring 和 Hibernate、JPA、Spring Data 等构建应用程序的持久层 Spring Exceptions Tutorial Spring 中的常见异常以及示例——它们为什么会发生以及如何快速解决它们  ","permalink":"http://itcodingman.github.io/security-spring/","tags":null,"title":""},{"categories":null,"contents":"Spring 中的接线：@Autowired、@Resource 和 @Inject 一、概述 在本 Spring Framework 教程中，我们将演示如何使用与依赖注入相关的注解，即*@Resource*、@Inject和*@Autowired*注解。这些注解为类提供了一种声明性的方式来解决依赖关系： @Autowired ArbitraryClass arbObject; 与直接实例化它们相反（命令式）： ArbitraryClass arbObject = new ArbitraryClass(); 三个注解中有两个属于 Java 扩展包：javax.annotation.Resource和javax.inject.Inject。@Autowired注解属于org.springframework.beans.factory.annotation包。 这些注解中的每一个都可以通过字段注入或 setter 注入来解决依赖关系。我们将使用一个简化但实用的示例来演示三个注释之间的区别，基于每个注释所采用的执行路径。 示例将重点介绍如何在集成测试期间使用三个注入注解。测试所需的依赖可以是任意文件或任意类。 进一步阅读： Spring中的构造函数依赖注入 使用 Spring 快速实用地介绍基于构造函数的注入。 阅读更多→ Spring 控制反转和依赖注入简介 快速介绍控制反转和依赖注入的概念，然后使用 Spring 框架进行简单演示 阅读更多→ 在抽象类中使用 @Autowired 了解在抽象类和具体类上使用 @Autowired 的区别 阅读更多→ 2. @ ***Resource***注解 @Resource注释是JSR-250注释集合的一部分，并与 Jakarta EE 一起打包。此注解具有以下执行路径，按优先级列出：  按名称匹配 按类型匹配 按预选赛匹配  这些执行路径适用于 setter 和 field 注入。 2.1。现场注入 我们可以通过使用@Resource注释来注释实例变量来通过字段注入来解决依赖关系。 2.1.1。按名称匹配 我们将使用以下集成测试来演示按名称匹配字段注入： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceNameType.class) public class FieldResourceInjectionIntegrationTest { @Resource(name=\u0026#34;namedFile\u0026#34;) private File defaultFile; @Test public void givenResourceAnnotation_WhenOnField_ThenDependencyValid(){ assertNotNull(defaultFile); assertEquals(\u0026#34;namedFile.txt\u0026#34;, defaultFile.getName()); } } 让我们看一下代码。在FieldResourceInjectionTest集成测试中，在第 7 行，我们通过将 bean 名称作为属性值传递给*@Resource*注释来按名称解析依赖项： @Resource(name=\u0026#34;namedFile\u0026#34;) private File defaultFile; 此配置将使用按名称匹配执行路径解析依赖关系。我们必须在ApplicationContextTestResourceNameType应用程序上下文中定义 bean namedFile 。 注意 bean id 和对应的引用属性值必须匹配： @Configuration public class ApplicationContextTestResourceNameType { @Bean(name=\u0026#34;namedFile\u0026#34;) public File namedFile() { File namedFile = new File(\u0026#34;namedFile.txt\u0026#34;); return namedFile; } } 如果我们未能在应用程序上下文中定义 bean，它将导致org.springframework.beans.factory.NoSuchBeanDefinitionException被抛出。我们可以通过更改ApplicationContextTestResourceNameType应用程序上下文中传递给**@Bean注解的属性值，或者更改FieldResourceInjectionTest集成测试中传递给*@Resource*注解的属性值来证明这一点。 2.1.2. 按类型匹配 为了演示按类型匹配的执行路径，我们只删除FieldResourceInjectionTest集成测试第 7 行的属性值： @Resource private File defaultFile; 然后我们再次运行测试。 测试仍然会通过，因为如果*@Resource*注释没有接收到 bean 名称作为属性值，Spring 框架将继续进行下一级优先级，按类型匹配，以尝试解决依赖关系。 2.1.3。按预选赛匹配 为了演示 match-by-qualifier 执行路径，将修改集成测试场景，以便在ApplicationContextTestResourceQualifier应用程序上下文中定义两个 bean： @Configuration public class ApplicationContextTestResourceQualifier { @Bean(name=\u0026#34;defaultFile\u0026#34;) public File defaultFile() { File defaultFile = new File(\u0026#34;defaultFile.txt\u0026#34;); return defaultFile; } @Bean(name=\u0026#34;namedFile\u0026#34;) public File namedFile() { File namedFile = new File(\u0026#34;namedFile.txt\u0026#34;); return namedFile; } } 我们将使用QualifierResourceInjectionTest集成测试来演示逐个匹配的依赖关系解析。在这种情况下，需要将特定的 bean 依赖注入到每个引用变量中： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceQualifier.class) public class QualifierResourceInjectionIntegrationTest { @Resource private File dependency1; @Resource private File dependency2; @Test public void givenResourceAnnotation_WhenField_ThenDependency1Valid(){ assertNotNull(dependency1); assertEquals(\u0026#34;defaultFile.txt\u0026#34;, dependency1.getName()); } @Test public void givenResourceQualifier_WhenField_ThenDependency2Valid(){ assertNotNull(dependency2); assertEquals(\u0026#34;namedFile.txt\u0026#34;, dependency2.getName()); } } 当我们运行集成测试时，会抛出org.springframework.beans.factory.NoUniqueBeanDefinitionException 。**这会发生，因为应用程序上下文将找到两个类型为File的 bean 定义，并且不知道哪个 bean 应该解决依赖关系。 要解决这个问题，我们需要参考QualifierResourceInjectionTest集成测试的第 7 行到第 10 行： @Resource private File dependency1; @Resource private File dependency2; 我们必须添加以下代码行： @Qualifier(\u0026#34;defaultFile\u0026#34;) @Qualifier(\u0026#34;namedFile\u0026#34;) 使代码块如下所示： @Resource @Qualifier(\u0026#34;defaultFile\u0026#34;) private File dependency1; @Resource @Qualifier(\u0026#34;namedFile\u0026#34;) private File dependency2; 当我们再次运行集成测试时，它应该会通过。我们的测试表明，即使我们在应用程序上下文中定义了多个 bean，我们也可以使用*@Qualifier*注释通过允许我们将特定的依赖项注入到一个类中来消除任何混淆。 2.2. 二传手注入 在字段上注入依赖项时所采用的执行路径也适用于基于 setter 的注入。 2.2.1。按名称匹配 唯一的区别是MethodResourceInjectionTest集成测试有一个 setter 方法： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceNameType.class) public class MethodResourceInjectionIntegrationTest { private File defaultFile; @Resource(name=\u0026#34;namedFile\u0026#34;) protected void setDefaultFile(File defaultFile) { this.defaultFile = defaultFile; } @Test public void givenResourceAnnotation_WhenSetter_ThenDependencyValid(){ assertNotNull(defaultFile); assertEquals(\u0026#34;namedFile.txt\u0026#34;, defaultFile.getName()); } } 我们通过注解引用变量的相应 setter 方法，通过 setter 注入来解决依赖关系。然后我们将bean依赖的名称作为属性值传递给*@Resource*注解： private File defaultFile; @Resource(name=\u0026#34;namedFile\u0026#34;) protected void setDefaultFile(File defaultFile) { this.defaultFile = defaultFile; } 在本例中，我们将重用namedFile bean 依赖项。bean 名称和相应的属性值必须匹配。 当我们运行集成测试时，它将通过。 为了让我们验证按名称匹配执行路径是否解决了依赖关系，我们需要将传递给*@Resource注解的属性值更改为我们选择的值并再次运行测试。这一次，测试将失败并出现NoSuchBeanDefinitionException*。 2.2.2。按类型匹配 为了演示基于 setter、按类型匹配的执行，我们将使用MethodByTypeResourceTest集成测试： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceNameType.class) public class MethodByTypeResourceIntegrationTest { private File defaultFile; @Resource protected void setDefaultFile(File defaultFile) { this.defaultFile = defaultFile; } @Test public void givenResourceAnnotation_WhenSetter_ThenValidDependency(){ assertNotNull(defaultFile); assertEquals(\u0026#34;namedFile.txt\u0026#34;, defaultFile.getName()); } } 当我们运行这个测试时，它会通过。 为了让我们验证按类型匹配的执行路径是否解决了File依赖关系，我们需要将defaultFile变量的类类型更改为另一个类类型，如String。然后我们可以再次执行MethodByTypeResourceTest集成测试，这次会抛出NoSuchBeanDefinitionException 。 该异常验证是否确实使用了按类型匹配来解决文件依赖关系。NoSuchBeanDefinitionException确认引用变量名称不需要与 bean 名称匹配。相反，依赖解析取决于 bean 的类类型与引用变量的类类型匹配。 2.2.3。按预选赛匹配 我们将使用MethodByQualifierResourceTest集成测试来演示 match-by-qualifier 执行路径： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceQualifier.class) public class MethodByQualifierResourceIntegrationTest { private File arbDependency; private File anotherArbDependency; @Test public void givenResourceQualifier_WhenSetter_ThenValidDependencies(){ assertNotNull(arbDependency); assertEquals(\u0026#34;namedFile.txt\u0026#34;, arbDependency.getName()); assertNotNull(anotherArbDependency); assertEquals(\u0026#34;defaultFile.txt\u0026#34;, anotherArbDependency.getName()); } @Resource @Qualifier(\u0026#34;namedFile\u0026#34;) public void setArbDependency(File arbDependency) { this.arbDependency = arbDependency; } @Resource @Qualifier(\u0026#34;defaultFile\u0026#34;) public void setAnotherArbDependency(File anotherArbDependency) { this.anotherArbDependency = anotherArbDependency; } } 我们的测试表明，即使我们在应用程序上下文中定义了特定类型的多个 bean 实现，我们也可以使用*@Qualifier注释和@Resource*注释来解决依赖关系。 类似于基于字段的依赖注入，如果我们在一个应用上下文中定义多个bean，我们必须使用 @Qualifier 注解来指定使用哪个bean来解析依赖，否则会抛出NoUniqueBeanDefinitionException 。 3. *@Inject*注解 @Inject注释属于JSR-330注释集合。此注解具有以下执行路径，按优先级列出：  按类型匹配 按预选赛匹配 按名称匹配  这些执行路径适用于 setter 和 field 注入。为了让我们访问*@Inject注解，我们必须将javax.inject*库声明为 Gradle 或 Maven 依赖项。 对于 Gradle： testCompile group: \u0026#39;javax.inject\u0026#39;, name: \u0026#39;javax.inject\u0026#39;, version: \u0026#39;1\u0026#39; 对于 Maven： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.inject\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.inject\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3.1。现场注入 3.1.1。按类型匹配 我们将修改集成测试示例以使用另一种类型的依赖项，即ArbitraryDependency类。ArbitraryDependency类依赖仅作为一个简单的依赖，并没有进一步的意义： @Component public class ArbitraryDependency { private final String label = \u0026#34;Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 这是有问题的FieldInjectTest集成测试： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestInjectType.class) public class FieldInjectIntegrationTest { @Inject private ArbitraryDependency fieldInjectDependency; @Test public void givenInjectAnnotation_WhenOnField_ThenValidDependency(){ assertNotNull(fieldInjectDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, fieldInjectDependency.toString()); } } 与*@Resource注解首先按名称解析依赖关系不同，@* Inject注解的默认行为是按类型解析依赖关系。 这意味着即使类引用变量名称与 bean 名称不同，依赖关系仍然会被解析，前提是 bean 是在应用程序上下文中定义的。请注意以下测试中引用变量名称的方式： @Inject private ArbitraryDependency fieldInjectDependency; 与应用程序上下文中配置的 bean 名称不同： @Bean public ArbitraryDependency injectDependency() { ArbitraryDependency injectDependency = new ArbitraryDependency(); return injectDependency; } 当我们执行测试时，我们能够解决依赖关系。 3.1.2。按预选赛匹配 如果一个特定的类类型有多个实现，并且某个类需要一个特定的 bean，该怎么办？让我们修改集成测试示例，使其需要另一个依赖项。 在此示例中，我们将ArbitraryDependency类（在按类型匹配示例中使用）进行子类化，以创建AnotherArbitraryDependency类： public class AnotherArbitraryDependency extends ArbitraryDependency { private final String label = \u0026#34;Another Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 每个测试用例的目标是确保我们将每个依赖项正确地注入每个引用变量中： @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; 我们可以使用FieldQualifierInjectTest集成测试来演示限定符匹配： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestInjectQualifier.class) public class FieldQualifierInjectIntegrationTest { @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; @Test public void givenInjectQualifier_WhenOnField_ThenDefaultFileValid(){ assertNotNull(defaultDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, defaultDependency.toString()); } @Test public void givenInjectQualifier_WhenOnField_ThenNamedFileValid(){ assertNotNull(defaultDependency); assertEquals(\u0026#34;Another Arbitrary Dependency\u0026#34;, namedDependency.toString()); } } 如果我们在应用程序上下文中有多个特定类的实现，并且FieldQualifierInjectTest集成测试尝试以下面列出的方式注入依赖项，则会抛出NoUniqueBeanDefinitionException ： @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; 抛出这个异常是 Spring 框架指出某个类有多个实现的方式，它对使用哪一个感到困惑。为了阐明混淆，我们可以转到FieldQualifierInjectTest集成测试的第 7 行和第 10 行： @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; 我们可以将所需的 bean 名称传递给*@Qualifier注释，我们将其与@Inject*注释一起使用。这就是代码块现在的样子： @Inject @Qualifier(\u0026#34;defaultFile\u0026#34;) private ArbitraryDependency defaultDependency; @Inject @Qualifier(\u0026#34;namedFile\u0026#34;) private ArbitraryDependency namedDependency; @Qualifier注解在接收 bean 名称时要求严格匹配。我们必须确保将 bean 名称正确传递给Qualifier，否则将抛出*NoUniqueBeanDefinitionException 。*如果我们再次运行测试，它应该会通过。 3.1.3. 按名称匹配 用于演示按名称匹配的FieldByNameInjectTest集成测试类似于按类型匹配执行路径。唯一的区别是现在我们需要一个特定的 bean，而不是一个特定的类型。在此示例中，我们再次对ArbitraryDependency类进行子类化以生成YetAnotherArbitraryDependency类： public class YetAnotherArbitraryDependency extends ArbitraryDependency { private final String label = \u0026#34;Yet Another Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 为了演示按名称匹配的执行路径，我们将使用以下集成测试： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestInjectName.class) public class FieldByNameInjectIntegrationTest { @Inject @Named(\u0026#34;yetAnotherFieldInjectDependency\u0026#34;) private ArbitraryDependency yetAnotherFieldInjectDependency; @Test public void givenInjectQualifier_WhenSetOnField_ThenDependencyValid(){ assertNotNull(yetAnotherFieldInjectDependency); assertEquals(\u0026#34;Yet Another Arbitrary Dependency\u0026#34;, yetAnotherFieldInjectDependency.toString()); } } 我们列出应用程序上下文： @Configuration public class ApplicationContextTestInjectName { @Bean public ArbitraryDependency yetAnotherFieldInjectDependency() { ArbitraryDependency yetAnotherFieldInjectDependency = new YetAnotherArbitraryDependency(); return yetAnotherFieldInjectDependency; } } 如果我们运行集成测试，它将通过。 为了验证我们是否通过按名称匹配执行路径注入了依赖项，我们需要将传入*@Named注释的值**yetAnotherFieldInjectDependency更改为我们选择的另一个名称。当我们再次运行测试时，会抛出NoSuchBeanDefinitionException 。* 3.2. 二传手注入 @Inject注解的基于设置器的注入类似于用于基于*@Resource*设置器的注入的方法。我们不是注释引用变量，而是注释相应的 setter 方法。基于字段的依赖注入所遵循的执行路径也适用于基于 setter 的注入。 4. *@Autowired*注解 @Autowired注解的行为类似于*@Inject注解。唯一的区别是@Autowired*注解是 Spring 框架的一部分。此注解与@Inject注解具有相同的执行路径，按优先顺序列出：  按类型匹配 按预选赛匹配 按名称匹配  这些执行路径适用于 setter 和 field 注入。 4.1。现场注入 4.1.1。按类型匹配 用于演示*@Autowired按类型匹配执行路径的集成测试示例将类似于用于演示@Inject按类型匹配执行路径的测试。我们使用以下FieldAutowiredTest集成测试来演示使用@Autowired*注释的按类型匹配： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestAutowiredType.class) public class FieldAutowiredIntegrationTest { @Autowired private ArbitraryDependency fieldDependency; @Test public void givenAutowired_WhenSetOnField_ThenDependencyResolved() { assertNotNull(fieldDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, fieldDependency.toString()); } } 我们列出了此集成测试的应用程序上下文： @Configuration public class ApplicationContextTestAutowiredType { @Bean public ArbitraryDependency autowiredFieldDependency() { ArbitraryDependency autowiredFieldDependency = new ArbitraryDependency(); return autowiredFieldDependency; } } 我们使用此集成测试来证明按类型匹配优先于其他执行路径。注意FieldAutowiredTest集成测试第 8 行的引用变量名称： @Autowired private ArbitraryDependency fieldDependency; 这与应用程序上下文中的 bean 名称不同： @Bean public ArbitraryDependency autowiredFieldDependency() { ArbitraryDependency autowiredFieldDependency = new ArbitraryDependency(); return autowiredFieldDependency; } 当我们运行测试时，它应该通过了。 为了确认依赖确实是使用 match-by-type 执行路径解决的，我们需要更改fieldDependency引用变量的类型并再次运行集成测试。这一次，FieldAutowiredTest集成测试将失败，并引发NoSuchBeanDefinitionException。这验证了我们使用了按类型匹配来解决依赖关系。 4.1.2. 按预选赛匹配 如果我们遇到在应用程序上下文中定义了多个 bean 实现的情况怎么办： @Configuration public class ApplicationContextTestAutowiredQualifier { @Bean public ArbitraryDependency autowiredFieldDependency() { ArbitraryDependency autowiredFieldDependency = new ArbitraryDependency(); return autowiredFieldDependency; } @Bean public ArbitraryDependency anotherAutowiredFieldDependency() { ArbitraryDependency anotherAutowiredFieldDependency = new AnotherArbitraryDependency(); return anotherAutowiredFieldDependency; } } 如果我们执行以下FieldQualifierAutowiredTest集成测试，将抛出NoUniqueBeanDefinitionException ： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestAutowiredQualifier.class) public class FieldQualifierAutowiredIntegrationTest { @Autowired private ArbitraryDependency fieldDependency1; @Autowired private ArbitraryDependency fieldDependency2; @Test public void givenAutowiredQualifier_WhenOnField_ThenDep1Valid(){ assertNotNull(fieldDependency1); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, fieldDependency1.toString()); } @Test public void givenAutowiredQualifier_WhenOnField_ThenDep2Valid(){ assertNotNull(fieldDependency2); assertEquals(\u0026#34;Another Arbitrary Dependency\u0026#34;, fieldDependency2.toString()); } } 异常是由于应用程序上下文中定义的两个 bean 引起的歧义。Spring 框架不知道哪个 bean 依赖项应该自动装配到哪个引用变量。我们可以通过在FieldQualifierAutowiredTest集成测试的第 7 行和第 10 行添加*@Qualifier*注释来解决此问题： @Autowired private FieldDependency fieldDependency1; @Autowired private FieldDependency fieldDependency2; 使代码块如下所示： @Autowired @Qualifier(\u0026#34;autowiredFieldDependency\u0026#34;) private FieldDependency fieldDependency1; @Autowired @Qualifier(\u0026#34;anotherAutowiredFieldDependency\u0026#34;) private FieldDependency fieldDependency2; 当我们再次运行测试时，它将通过。 4.1.3。按名称匹配 我们将使用相同的集成测试场景来演示使用@Autowired注释注入字段依赖项的按名称匹配执行路径。当按名称自动装配依赖项时，@ComponentScan注释必须与应用程序上下文ApplicationContextTestAutowiredName一起使用： @Configuration @ComponentScan(basePackages={\u0026#34;com.codingman.dependency\u0026#34;}) public class ApplicationContextTestAutowiredName { } 我们使用*@ComponentScan注解在包中搜索已使用@Component 注解进行注解的Java类*。例如，在应用程序上下文中，将扫描com.codingman.dependency包以查找已使用*@Component注释进行注释的类。在这种情况下，Spring 框架必须检测带有@Component注解的ArbitraryDependency*类： @Component(value=\u0026#34;autowiredFieldDependency\u0026#34;) public class ArbitraryDependency { private final String label = \u0026#34;Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 传递到*@Component注释的属性值autowiredFieldDependency告诉 Spring 框架ArbitraryDependency类是一个名为autowiredFieldDependency的组件。为了让@Autowired注解通过名称解析依赖，组件名称必须与FieldAutowiredNameTest*集成测试中定义的字段名称相对应；请参考第8行： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestAutowiredName.class) public class FieldAutowiredNameIntegrationTest { @Autowired private ArbitraryDependency autowiredFieldDependency; @Test public void givenAutowiredAnnotation_WhenOnField_ThenDepValid(){ assertNotNull(autowiredFieldDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, autowiredFieldDependency.toString()); } } 当我们运行FieldAutowiredNameTest集成测试时，它将通过。 但是我们怎么知道*@Autowired注解确实调用了按名称匹配的执行路径呢？我们可以将引用变量autowiredFieldDependency*的名称更改为我们选择的另一个名称，然后再次运行测试。 这一次，测试将失败并抛出NoUniqueBeanDefinitionException。类似的检查是将*@Component属性值autowiredFieldDependency更改为我们选择的另一个值并再次运行测试。NoUniqueBeanDefinitionException也会*被抛出。 这个异常证明如果我们使用不正确的 bean 名称，将找不到有效的 bean。这就是我们知道调用了按名称匹配执行路径的方式。 4.2. 二传手注入 @Autowired注解的基于设置器的注入类似于为基于*@Resource*设置器的注入演示的方法。我们不是用@Inject注解来注解引用变量，而是注解对应的setter。基于字段的依赖注入所遵循的执行路径也适用于基于 setter 的注入。 5. 应用这些注释 这就提出了应该使用哪种注释以及在什么情况下使用的问题。这些问题的答案取决于相关应用程序面临的设计场景，以及开发人员希望如何利用基于每个注释的默认执行路径的多态性。 5.1。通过多态性在应用程序范围内使用单例 如果设计是这样的应用程序行为基于接口或抽象类的实现，并且这些行为在整个应用程序中使用，那么我们可以使用*@Inject或@Autowired*注解。 这种方法的好处是，当我们升级应用程序或应用补丁来修复错误时，可以将类换出，而对整体应用程序行为的负面影响最小。在这种情况下，主要的默认执行路径是按类型匹配。 5.2. 通过多态进行细粒度的应用程序行为配置 如果设计使得应用程序具有复杂的行为，每个行为都基于不同的接口/抽象类，并且这些实现中的每一个的使用因应用程序而异，那么我们可以使用*@Resource*注解。在这种情况下，主要的默认执行路径是按名称匹配。 5.3. 依赖注入应该由 Jakarta EE 平台单独处理 如果 Jakarta EE 平台而不是 Spring 注入所有依赖项的设计要求，那么选择是在*@Resource注释和@Inject*注释之间进行选择。我们应该根据需要哪个默认执行路径来缩小两个注释之间的最终决定。 5.4. 依赖注入应该由 Spring 框架单独处理 如果要求所有依赖项都由 Spring 框架处理，则唯一的选择是*@Autowired*注释。 5.5. 讨论总结 下表总结了我们的讨论。    设想 @资源 @注入 @自动连线     通过多态性在应用程序范围内使用单例 ✗ ✔ ✔   通过多态进行细粒度的应用程序行为配置 ✔ ✗ ✗   依赖注入应该由 Jakarta EE 平台单独处理 ✔ ✔ ✗   依赖注入应该由 Spring Framework 单独处理 ✗ ✗ ✔    六，结论 在本文中，我们旨在更深入地了解每个注释的行为。了解每个注释的行为方式将有助于更好的整体应用程序设计和维护。 讨论期间使用的代码可以在GitHub上找到。 ","permalink":"http://itcodingman.github.io/spring-annotations-resource-inject-autowire/","tags":null,"title":""},{"categories":null,"contents":"Spring @Autowired 指南 一、概述 从 Spring 2.5 开始，该框架引入了注解驱动的依赖注入。此功能的主要注释是*@Autowired* 。 它允许 Spring 解析协作 bean 并将其注入到我们的 bean 中。 进一步阅读： Spring 组件扫描 了解 Spring 组件扫描背后的机制，以及如何根据自己的需要对其进行调整 阅读更多→ Spring 控制反转和依赖注入简介 快速介绍控制反转和依赖注入的概念，然后使用 Spring 框架进行简单演示 阅读更多→ 在本教程中，我们将首先了解如何启用自动装配以及自动装配 bean 的 各种 方法。之后，我们将讨论使用***@Qualifier*注解解决 bean 冲突**，以及潜在的异常情况。 2. 启用*@Autowired*注解 Spring 框架支持自动依赖注入。换句话说，通过在 Spring 配置文件中声明所有 bean 依赖项，Spring 容器可以自动装配协作 bean 之间的关系。这称为*Spring bean 自动装配*。 要在我们的应用程序中使用基于 Java 的配置，让我们启用注解驱动注入 来加载我们的 Spring 配置： @Configuration @ComponentScan(\u0026#34;com.codingman.autowire.sample\u0026#34;) public class AppConfig {} 或者，[**注解](/spring-contextannotation-contextcomponentscan#:~:text=The can resolve.)主要用于激活 Spring XML 文件中的依赖注入注解。 此外，Spring Boot 引入了*@SpringBootApplication*注解。此单个注释等效于使用*@Configuration*、@EnableAutoConfiguration和 @ComponentScan。 让我们在应用程序的主类中使用这个注解： @SpringBootApplication class VehicleFactoryApplication { public static void main(String[] args) { SpringApplication.run(VehicleFactoryApplication.class, args); } } 因此，当我们运行这个 Spring Boot 应用程序时，它会自动扫描当前包及其子包中的组件。因此它将在 Spring 的应用程序上下文中注册它们，并允许我们使用*@Autowired*注入 bean 。 3. 使用*@Autowired* 启用注解注入后，我们可以对属性、设置器和构造器使用自动装配。 3.1。*@Autowired*属性 让我们看看如何使用*@Autowired*注释属性。这消除了对 getter 和 setter 的需要。 首先，让我们定义一个fooFormatter bean： @Component(\u0026#34;fooFormatter\u0026#34;) public class FooFormatter { public String format() { return \u0026#34;foo\u0026#34;; } } 然后，我们将在字段定义上使用*@Autowired将此 bean 注入FooService bean：* @Component public class FooService { @Autowired private FooFormatter fooFormatter; } 因此，Spring在创建FooService时会注入fooFormatter。 3.2. 设置器上的*@Autowired* 现在让我们尝试在 setter 方法上添加*@Autowired注解。* 在以下示例中，在创建FooService时使用 FooFormatter的实例调用 setter 方法： public class FooService { private FooFormatter fooFormatter; @Autowired public void setFooFormatter(FooFormatter fooFormatter) { this.fooFormatter = fooFormatter; } } 3.3. *@Autowired*在构造函数上 最后，让我们在构造函数上使用*@Autowired*。 我们将看到Spring 将 FooFormatter 的实例作为FooService**构造函数的参数注入： public class FooService { private FooFormatter fooFormatter; @Autowired public FooService(FooFormatter fooFormatter) { this.fooFormatter = fooFormatter; } } 4. @Autowired和可选依赖 构建 bean 时，@Autowired依赖项应该可用。否则，如果 Spring 无法解析 bean 进行布线，它将抛出异常。 因此，它会阻止 Spring 容器成功启动，但以下形式除外： Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.autowire.sample.FooDAO] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} 为了解决这个问题，我们需要声明一个所需类型的 bean： public class FooService { @Autowired(required = false) private FooDAO dataAccessor; } 5. Autowire消歧 默认情况下，Spring 按类型解析*@Autowired*条目。如果容器中有多个相同类型的 bean 可用，框架将抛出一个致命异常。 为了解决这个冲突，我们需要明确地告诉 Spring 我们要注入哪个 bean。 5.1。*@Qualifier*自动装配 例如，让我们看看如何使用@Qualifier注解来指示所需的 bean。 首先，我们将定义 2 个Formatter类型的 bean ： @Component(\u0026#34;fooFormatter\u0026#34;) public class FooFormatter implements Formatter { public String format() { return \u0026#34;foo\u0026#34;; } } @Component(\u0026#34;barFormatter\u0026#34;) public class BarFormatter implements Formatter { public String format() { return \u0026#34;bar\u0026#34;; } } 现在让我们尝试将Formatter bean 注入FooService类： public class FooService { @Autowired private Formatter formatter; } 在我们的示例中，有两个可用于 Spring 容器的Formatter的具体实现。因此， Spring 在构造*FooService**时会抛出*NoUniqueBeanDefinitionException*异常： * Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [com.autowire.sample.Formatter] is defined: expected single matching bean but found 2: barFormatter,fooFormatter 我们可以通过使用*@Qualifier*注解缩小实现范围来避免这种情况： public class FooService { @Autowired @Qualifier(\u0026#34;fooFormatter\u0026#34;) private Formatter formatter; } 当有多个相同类型的 bean 时，最好使用*@Qualifier*来避免歧义。 请注意，@Qualifier 注释的值与我们的 FooFormatter**实现的*@Component*注释中声明的名称匹配。 5.2. 通过自定义限定符自动装配 Spring 还允许我们创建自己的自定义*@Qualifier*注释。为此，我们应该提供带有定义的*@Qualifier*注释： @Qualifier @Target({ ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) public @interface FormatterType { String value(); } 然后我们可以在各种实现中使用FormatterType 来指定自定义值： @FormatterType(\u0026#34;Foo\u0026#34;) @Component public class FooFormatter implements Formatter { public String format() { return \u0026#34;foo\u0026#34;; } } @FormatterType(\u0026#34;Bar\u0026#34;) @Component public class BarFormatter implements Formatter { public String format() { return \u0026#34;bar\u0026#34;; } } 最后，我们的自定义 Qualifier 注解已准备好用于自动装配： @Component public class FooService { @Autowired @FormatterType(\u0026#34;Foo\u0026#34;) private Formatter formatter; } *@Target*元注释中指定的值限制了应用限定符的位置，在我们的示例中是字段、方法、类型和参数。 5.3. 按名称自动装配 **Spring 使用 bean 的名称作为默认限定符值。**它将检查容器并查找具有确切名称的 bean 作为属性来自动装配它。 因此，在我们的示例中，Spring 将fooFormatter属性名称与FooFormatter实现相匹配。因此，它在构造FooService时注入了该特定实现： public class FooService { @Autowired private Formatter fooFormatter; } 六，结论 在本文中，我们讨论了自动装配以及使用它的不同方式。我们还研究了解决由丢失 bean 或不明确 bean 注入引起的两种常见自动装配异常的方法。 本文的源代码可在GitHub 项目上找到。 ","permalink":"http://itcodingman.github.io/spring-autowire/","tags":null,"title":""},{"categories":null,"contents":"Spring Bean 注解 一、概述 在本教程中，我们将讨论用于定义不同类型bean的最常见的 Spring bean 注释。 有几种方法可以在 Spring 容器中配置 bean。首先，我们可以使用 XML 配置声明它们。我们还可以在配置类中使用*@Bean注解来声明 bean。* 最后，我们可以使用org.springframework.stereotype包中的注释之一标记该类，并将其余部分留给组件扫描。 2. 组件扫描 如果启用了组件扫描，Spring 可以自动扫描包中的 bean。 @ComponentScan配置要扫描哪些包以查找具有注释配置的类。我们可以使用basePackages或value参数之一直接指定基本包名称（ value是basePackages的别名）： @Configuration @ComponentScan(basePackages = \u0026#34;com.codingman.annotations\u0026#34;) class VehicleFactoryConfig {} 此外，我们可以使用basePackageClasses参数指向基础包中的类： @Configuration @ComponentScan(basePackageClasses = VehicleFactoryConfig.class) class VehicleFactoryConfig {} 这两个参数都是数组，因此我们可以为每个参数提供多个包。 如果未指定参数，则扫描从存在*@ComponentScan*注释类的同一包中进行。 @ComponentScan利用了 Java 8 的重复注解特性，这意味着我们可以用它多次标记一个类： @Configuration @ComponentScan(basePackages = \u0026#34;com.codingman.annotations\u0026#34;) @ComponentScan(basePackageClasses = VehicleFactoryConfig.class) class VehicleFactoryConfig {} 或者，我们可以使用*@ComponentScans指定多个@ComponentScan*配置： @Configuration @ComponentScans({ @ComponentScan(basePackages = \u0026#34;com.codingman.annotations\u0026#34;), @ComponentScan(basePackageClasses = VehicleFactoryConfig.class) }) class VehicleFactoryConfig {} 使用XML 配置时，配置组件扫描同样简单： \u0026lt;context:component-scan base-package=\u0026#34;com.codingman\u0026#34; /\u0026gt; 3. *@组件* @Component是一个类级别的注解。在组件扫描期间，Spring Framework 会自动检测带有*@Component 注释的类：* @Component class CarUtility { // ... } 默认情况下，此类的 bean 实例与具有小写首字母的类名称具有相同的名称。此外，我们可以使用此注解的可选值参数指定不同的名称。 由于*@Repository*、@Service、@Configuration和*@Controller都是@Component*的元注释，它们共享相同的 bean 命名行为。Spring 还会在组件扫描过程中自动拾取它们。 4. *@存储库* DAO 或 Repository 类通常代表应用程序中的数据库访问层，应使用*@Repository 进行注释：* @Repository class VehicleRepository { // ... } 使用此注释的一个优点是它启用了自动持久性异常转换。当使用持久性框架（例如 Hibernate）时，在带有*@Repository注释的类中抛出的本机异常将自动转换为 Spring 的DataAccessExeption*的子类。 要启用异常翻译，我们需要声明我们自己的PersistenceExceptionTranslationPostProcessor bean： @Bean public PersistenceExceptionTranslationPostProcessor exceptionTranslation() { return new PersistenceExceptionTranslationPostProcessor(); } 请注意，在大多数情况下，Spring 会自动执行上述步骤。 或者通过 XML 配置： \u0026lt;bean class= \u0026#34;org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\u0026#34;/\u0026gt; 5. *@服务* 应用程序的业务逻辑通常驻留在服务层中，因此我们将使用*@Service* 注解来指示一个类属于该层： @Service public class VehicleService { // ... } 6. *@控制器* @Controller是一个类级别的注解，它告诉 Spring Framework 这个类作为Spring MVC 中的一个控制器： @Controller public class VehicleController { // ... } 7. @配置 配置类可以包含使用*@Bean*注释的bean 定义方法： @Configuration class VehicleFactoryConfig { @Bean Engine engine() { return new Engine(); } } 8. 刻板印象注释和 AOP 当我们使用 Spring 原型注解时，很容易创建一个指向所有具有特定原型的类的切入点。 例如，假设我们想从 DAO 层测量方法的执行时间。我们将利用*@Repository*原型创建以下方面（使用AspectJ 注释）： @Aspect @Component public class PerformanceAspect { @Pointcut(\u0026#34;within(@org.springframework.stereotype.Repository *)\u0026#34;) public void repositoryClassMethods() {}; @Around(\u0026#34;repositoryClassMethods()\u0026#34;) public Object measureMethodExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.nanoTime(); Object returnValue = joinPoint.proceed(); long end = System.nanoTime(); String methodName = joinPoint.getSignature().getName(); System.out.println( \u0026#34;Execution of \u0026#34; + methodName + \u0026#34; took \u0026#34; + TimeUnit.NANOSECONDS.toMillis(end - start) + \u0026#34; ms\u0026#34;); return returnValue; } } 在此示例中，我们创建了一个切入点，该切入点匹配使用*@Repository注释的类中的所有方法。然后我们使用@Around*通知来定位那个切入点，并确定被拦截方法调用的执行时间。 此外，使用这种方法，我们可以将日志记录、性能管理、审计和其他行为添加到每个应用程序层。 9. 结论 在本文中，我们检查了 Spring 原型注解并讨论了它们各自代表的语义类型。 我们还学习了如何使用组件扫描来告诉容器在哪里可以找到带注释的类。 最后，我们了解了这些注释如何导致一个干净的、分层的设计以及应用程序的关注点之间的分离。它们还使配置更小，因为我们不再需要手动显式定义 bean。 像往常一样，这些示例可以在 GitHub 上找到。 ","permalink":"http://itcodingman.github.io/spring-bean-annotations/","tags":null,"title":""},{"categories":null,"contents":"Spring Bean 范围快速指南 一、概述 在这个快速教程中，我们将了解 Spring 框架中不同类型的 bean 作用域。 bean 的范围定义了该 bean 在我们使用它的上下文中的生命周期和可见性。 最新版本的 Spring 框架定义了 6 种作用域：  单身人士 原型 要求 会议 应用 网络套接字  最后提到的四个范围，request、session、application和websocket，仅在 web 感知应用程序中可用。 进一步阅读： 什么是 Spring Bean？ 关于 Spring Bean 是什么的快速实用的解释。 阅读更多→ Spring Bean 注解 了解如何以及何时使用标准 Spring bean 注释 - @Component、@Repository、@Service 和 @Controller。 阅读更多→ 2. 单例范围 当我们使用单例范围定义 bean 时，容器会创建该 bean 的单个实例；对该 bean 名称的所有请求都将返回相同的对象，该对象被缓存。对对象的任何修改都将反映在对 bean 的所有引用中。如果未指定其他范围，则此范围是默认值。 让我们创建一个Person实体来举例说明作用域的概念： public class Person { private String name; // standard constructor, getters and setters } 之后，我们使用*@Scope注释定义具有单例*范围的 bean： @Bean @Scope(\u0026#34;singleton\u0026#34;) public Person personSingleton() { return new Person(); } 我们还可以通过以下方式使用常量而不是String值： @Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON) 现在我们可以继续编写一个测试，表明引用同一个 bean 的两个对象将具有相同的值，即使它们中只有一个改变了它们的状态，因为它们都引用了同一个 bean 实例： private static final String NAME = \u0026#34;John Smith\u0026#34;; @Test public void givenSingletonScope_whenSetName_thenEqualNames() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;scopes.xml\u0026#34;); Person personSingletonA = (Person) applicationContext.getBean(\u0026#34;personSingleton\u0026#34;); Person personSingletonB = (Person) applicationContext.getBean(\u0026#34;personSingleton\u0026#34;); personSingletonA.setName(NAME); Assert.assertEquals(NAME, personSingletonB.getName()); ((AbstractApplicationContext) applicationContext).close(); } 此示例中的scopes.xml文件应包含所用 bean 的 xml 定义： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;personSingleton\u0026#34; class=\u0026#34;com.codingman.scopes.Person\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 3.原型范围 每次从容器请求时，具有原型作用域的 bean都会返回不同的实例。它是通过将值原型设置为 bean 定义中的*@Scope*注解来定义的： @Bean @Scope(\u0026#34;prototype\u0026#34;) public Person personPrototype() { return new Person(); } 我们也可以像在单例作用域中那样使用常量： @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) 我们现在将编写一个与之前类似的测试，显示两个对象在 原型 范围内请求相同的 bean 名称。它们将具有不同的状态，因为它们不再引用同一个 bean 实例： private static final String NAME = \u0026#34;John Smith\u0026#34;; private static final String NAME_OTHER = \u0026#34;Anna Jones\u0026#34;; @Test public void givenPrototypeScope_whenSetNames_thenDifferentNames() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;scopes.xml\u0026#34;); Person personPrototypeA = (Person) applicationContext.getBean(\u0026#34;personPrototype\u0026#34;); Person personPrototypeB = (Person) applicationContext.getBean(\u0026#34;personPrototype\u0026#34;); personPrototypeA.setName(NAME); personPrototypeB.setName(NAME_OTHER); Assert.assertEquals(NAME, personPrototypeA.getName()); Assert.assertEquals(NAME_OTHER, personPrototypeB.getName()); ((AbstractApplicationContext) applicationContext).close(); } scopes.xml文件类似于上一节中介绍的文件，同时为具有原型作用域的 bean 添加xml定义： \u0026lt;bean id=\u0026#34;personPrototype\u0026#34; class=\u0026#34;com.codingman.scopes.Person\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 4. Web 感知范围 如前所述，有四个附加范围仅在 Web 感知应用程序上下文中可用。我们在实践中较少使用这些。 请求范围为单个 HTTP 请求创建一个 bean 实例，而 s会话范围为一个 HTTP 会话创建一个 bean 实例。 应用程序范围为ServletContext的生命周期创建 bean 实例，而websocket范围为特定的WebSocket会话创建它。 让我们创建一个用于实例化 bean 的类： public class HelloMessageGenerator { private String message; // standard getter and setter } 4.1。请求范围 我们可以使用*@Scope注释定义具有请求*范围的 bean： @Bean @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator requestScopedBean() { return new HelloMessageGenerator(); } proxyMode属性是必要的*，*因为在 Web 应用程序上下文的实例化时刻，没有活动请求。Spring 创建一个代理作为依赖注入，并在请求中需要它时实例化目标 bean。 我们还可以使用*@RequestScope*组合注释作为上述定义的快捷方式： @Bean @RequestScope public HelloMessageGenerator requestScopedBean() { return new HelloMessageGenerator(); } 接下来，我们可以定义一个控制器，该控制器具有对requestScopedBean的注入引用。我们需要访问同一个请求两次以测试 Web 特定范围。 如果我们在每次运行请求时都显示该消息，我们可以看到该值被重置为**null，即使它后来在方法中被更改。这是因为每个请求都返回了不同的 bean 实例。 @Controller public class ScopesController { @Resource(name = \u0026#34;requestScopedBean\u0026#34;) HelloMessageGenerator requestScopedBean; @RequestMapping(\u0026#34;/scopes/request\u0026#34;) public String getRequestScopeMessage(final Model model) { model.addAttribute(\u0026#34;previousMessage\u0026#34;, requestScopedBean.getMessage()); requestScopedBean.setMessage(\u0026#34;Good morning!\u0026#34;); model.addAttribute(\u0026#34;currentMessage\u0026#34;, requestScopedBean.getMessage()); return \u0026#34;scopesExample\u0026#34;; } } 4.2. 会话范围 我们可以用类似的方式定义具有会话范围的 bean： @Bean @Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator sessionScopedBean() { return new HelloMessageGenerator(); } 还有一个专用的组合注释，我们可以使用它来简化 bean 定义： @Bean @SessionScope public HelloMessageGenerator sessionScopedBean() { return new HelloMessageGenerator(); } 接下来我们定义一个引用sessionScopedBean的控制器。同样，我们需要运行两个请求以显示消息字段的值对于会话是相同的。 在这种情况下，当第一次发出请求时，值消息为*空。*但是，一旦更改，该值将保留给后续请求，因为为整个会话返回相同的 bean 实例。 @Controller public class ScopesController { @Resource(name = \u0026#34;sessionScopedBean\u0026#34;) HelloMessageGenerator sessionScopedBean; @RequestMapping(\u0026#34;/scopes/session\u0026#34;) public String getSessionScopeMessage(final Model model) { model.addAttribute(\u0026#34;previousMessage\u0026#34;, sessionScopedBean.getMessage()); sessionScopedBean.setMessage(\u0026#34;Good afternoon!\u0026#34;); model.addAttribute(\u0026#34;currentMessage\u0026#34;, sessionScopedBean.getMessage()); return \u0026#34;scopesExample\u0026#34;; } } 4.3. 适用范围 应用程序范围为ServletContext的生命周期创建 bean 实例。 这类似于单例范围，但在 bean 的范围方面有一个非常重要的区别。 当 bean 是应用程序作用域时，bean 的同一个实例在同一个**ServletContext中运行的多个基于 servlet 的应用程序之间共享，而单例作用域 bean 的作用域仅限于单个应用程序上下文。 让我们创建具有应用程序范围的 bean ： @Bean @Scope( value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator applicationScopedBean() { return new HelloMessageGenerator(); } 类似于请求和会话范围，我们可以使用更短的版本： @Bean @ApplicationScope public HelloMessageGenerator applicationScopedBean() { return new HelloMessageGenerator(); } 现在让我们创建一个引用这个 bean 的控制器： @Controller public class ScopesController { @Resource(name = \u0026#34;applicationScopedBean\u0026#34;) HelloMessageGenerator applicationScopedBean; @RequestMapping(\u0026#34;/scopes/application\u0026#34;) public String getApplicationScopeMessage(final Model model) { model.addAttribute(\u0026#34;previousMessage\u0026#34;, applicationScopedBean.getMessage()); applicationScopedBean.setMessage(\u0026#34;Good afternoon!\u0026#34;); model.addAttribute(\u0026#34;currentMessage\u0026#34;, applicationScopedBean.getMessage()); return \u0026#34;scopesExample\u0026#34;; } } 在这种情况下，一旦在applicationScopedBean中设置，值消息将保留给所有后续请求、会话，甚至对于将访问此 bean 的不同 servlet 应用程序，只要它在相同的ServletContext 中运行。 4.4. WebSocket 范围 最后，让我们使用websocket范围创建 bean ： @Bean @Scope(scopeName = \u0026#34;websocket\u0026#34;, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator websocketScopedBean() { return new HelloMessageGenerator(); } 首次访问时，WebSocket范围的 bean 存储在WebSocket会话属性中。每当在整个WebSocket会话期间访问该 bean 时，都会返回该 bean 的相同实例。 我们也可以说它表现出单例行为，但仅限于WebSocket**会话。 5. 结论 在本文中，我们讨论了 Spring 提供的不同 bean 范围以及它们的预期用途。 本文的实现可以在GitHub 项目中找到。 ","permalink":"http://itcodingman.github.io/spring-bean-scopes/","tags":null,"title":""},{"categories":null,"contents":"什么是 Spring Bean？ 一、概述 Bean 是 Spring Framework 的一个关键概念。因此，理解这个概念对于掌握框架并以有效的方式使用它至关重要。 不幸的是，**对于 Spring bean 究竟是什么这个简单问题，并没有明确的答案。**一些解释太低了以至于错过了大局，而另一些解释太模糊了。 本教程将尝试阐明该主题，从官方文档中的描述开始。 进一步阅读： 为什么选择 Spring 作为您的 Java 框架？ Spring 框架主要价值主张的快速实用概述。 阅读更多→ 了解 Spring 中的 getBean() 了解 Spring 的 BeanFactory.getBean() 方法的不同变体，用于从 Spring 容器中检索 bean 实例 阅读更多→ 2. bean定义 这是Spring Framework 文档中 bean 的定义 ： 在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。bean 是由 Spring IoC 容器实例化、组装和管理的对象。 这个定义简洁明了，**但没有详细说明一个重要元素：Spring IoC 容器。**让我们仔细看看它是什么以及它带来的好处。 3. 控制反转 简单地说，控制反转(IoC) 是**一个对象定义其依赖关系而不创建它们的过程。**该对象将构建此类依赖项的工作委托给 IoC 容器。 在深入研究 IoC 之前，让我们先声明几个域类。 3.1。领域类 假设我们有一个类声明： public class Company { private Address address; public Company(Address address) { this.address = address; } // getter, setter and other properties } 这个类需要一个 Address类型的协作者： public class Address { private String street; private int number; public Address(String street, int number) { this.street = street; this.number = number; } // getters and setters } 3.2. 传统方法 通常，我们使用类的构造函数创建对象： Address address = new Address(\u0026#34;High Street\u0026#34;, 1000); Company company = new Company(address); 这种方法没有任何问题，但是以更好的方式管理依赖关系不是很好吗？ 想象一个有几十个甚至几百个类的应用程序。有时我们希望在整个应用程序中共享一个类的单个实例，有时我们需要为每个用例提供一个单独的对象，等等。 管理如此多的对象简直就是一场噩梦。这就是控制反转来拯救的地方。 对象可以从 IoC 容器中检索其依赖项，而不是自己构建依赖项。我们需要做的就是为容器提供适当的配置元数据。 3.3. 豆配置 首先，让我们用*@Component注解来装饰Company类：* @Component public class Company { // this body is the same as before } 这是一个向 IoC 容器提供 bean 元数据的配置类： @Configuration @ComponentScan(basePackageClasses = Company.class) public class Config { @Bean public Address getAddress() { return new Address(\u0026#34;High Street\u0026#34;, 1000); } } 配置类产生一个 Address类型的 bean 。它还带有*@ComponentScan注释，它指示容器在包含Company*类的包中查找 bean。 当 Spring IoC 容器构造这些类型的对象时，所有对象都称为 Spring bean，因为它们由 IoC 容器管理。 3.4. 国际奥委会在行动 由于我们在配置类中定义了 bean，我们需要*AnnotationConfigApplicationContext*类的实例来构建容器： ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); 快速测试验证我们的 bean 的存在和属性值： Company company = context.getBean(\u0026#34;company\u0026#34;, Company.class); assertEquals(\u0026#34;High Street\u0026#34;, company.getAddress().getStreet()); assertEquals(1000, company.getAddress().getNumber()); 结果证明 IoC 容器已经正确地创建和初始化了 bean。 4。结论 本文简要介绍了 Spring bean 及其与 IoC 容器的关系。 完整的源代码可以在 GitHub 上找到。 ","permalink":"http://itcodingman.github.io/spring-bean/","tags":null,"title":""},{"categories":null,"contents":"Spring Boot 2 中的 Max-HTTP-Header-Size 一、概述 Spring Boot Web 应用程序默认包含一个预配置的嵌入式 Web 服务器。但是，在某些情况下，我们希望修改默认配置以满足自定义要求。 在本教程中，我们将了解如何在 Spring Boot 2.x 应用程序的application.properties文件中为请求标头设置和使用max-http-header-size属性。 2. Max-HTTP-Header-Size Spring Boot 支持Tomcat、Undertow和Jetty作为嵌入式服务器。通常，我们在 Spring Boot 应用程序中的application.properties文件或application.yaml文件中编写服务器配置。 大多数 Web 服务器都有自己的 HTTP 请求标头大小限制。HTTP 标头值受服务器实现的限制。在 Spring Boot 应用程序中，最大 HTTP 标头大小是使用server.max-http-header-size配置的。 Tomcat 和 Jetty 的实际默认值为 8kB，Undertow 的默认值为 1MB。 要修改最大 HTTP 标头大小，我们将属性添加到application.properties文件中： server.max-http-header-size=20000 对于application.yaml格式也是如此： server:max-http-header-size:20000从 Spring Boot 2.1 开始，我们现在将使用DataSize可解析值： server.max-http-header-size=10KB 3.请求头太大 假设在总 HTTP 标头大小大于max-http-header-size值的情况下发送请求。服务器以“400 Bad request”错误拒绝该请求。在下一个示例中，我们将在日志文件中看到此错误。 让我们创建一个控制器，它有一个名为 token 的标头属性： @RestController @RequestMapping(value = \u0026#34;/request-header-test\u0026#34;) public class MaxHttpHeaderSizeController { @GetMapping public boolean testMaxHTTPHeaderSize(@RequestHeader(value = \u0026#34;token\u0026#34;) String token) { return true; } } 接下来，让我们在application.properties文件中添加一些属性： ## Server connections configuration\rserver.tomcat.threads.max=200\rserver.connection-timeout=5s\rserver.max-http-header-size=8KB\rserver.tomcat.max-swallow-size=2MB\rserver.tomcat.max-http-post-size=2MB 当我们在令牌中传递一个大小大于 8kb的字符串值时，我们将得到 400 错误，如下所示：  在日志中，我们看到以下错误： 19:41:50.757 [http-nio-8080-exec-7] INFO o.a.coyote.http11.Http11Processor - Error parsing HTTP request header Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level. java.lang.IllegalArgumentException: Request header is too large ... 4.解决方案 我们可以根据需要在application.properties文件中增加max-http-header-size属性的值。 在上面的程序中，我们可以将它的值从默认的 8kb 升级到 40KB，这样就可以解决问题了。 server.max-http-header-size=40KB 现在，服务器将处理请求并返回 200 响应，如下所示：  因此，每当标头大小超过服务器列出的默认值时，我们将看到服务器返回 400-Bad Request 并显示错误“请求标头太大”。如上例所示，我们必须覆盖应用程序配置文件中的max-http-header-size值以匹配请求标头长度。 通常，当使用的令牌由于加密而非常长时，请求标头可能会变得太大。 5. 结论 在本教程中，我们学习了如何在 Spring Boot 应用程序的应用程序配置文件中使用max-http-header-size属性。 然后，我们看到了当我们传递一个超过这个大小的请求头时会发生什么，以及如何在我们的application.properties中增加**max-http-header-size 的大小。 与往常一样，这些示例的源代码可在 GitHub 上获得。 ","permalink":"http://itcodingman.github.io/spring-boot-max-http-header-size/","tags":null,"title":""},{"categories":null,"contents":"Spring 中的 @Component 与 @Repository 和 @Service 一、简介 在本快速教程中，我们将了解Spring Framework 中*@Component、@Repository和@Service注释之间的区别。* 进一步阅读： Spring @Autowired 指南 Springs @Autowired 注解和限定符最常见用法指南 阅读更多→ Spring @Qualifier 注解 @Autowired 单独有时不足以消除依赖关系。您可以使用 @Qualifier 注释更准确地连接。@Primary 也可以提供帮助。 阅读更多→ 2. Spring注解 在大多数典型应用程序中，我们有不同的层，如数据访问、表示、服务、业务等。 此外，在每一层中，我们都有各种 bean。为了自动检测这些 bean，Spring 使用类路径扫描注解。 然后它在ApplicationContext中注册每个 bean 。 以下是其中一些注释的快速概述：  @Component是任何 Spring 管理的组件的通用构造型。 @Service在服务层注释类。 @Repository在持久层注释类，它将充当数据库存储库。  我们已经有一篇关于这些注释的扩展文章，所以我们将重点放在它们之间的区别上。 3. 有什么不同？ **这些刻板印象之间的主要区别在于它们用于不同的分类。**当我们注释一个类进行自动检测时，我们应该使用各自的原型。 现在让我们更详细地了解它们。 3.1。 *@零件* 我们可以在整个应用程序中使用 @Component 将 bean 标记为 Spring 的托管组件。Spring 只会使用*@Component获取和注册bean，一般不会查找@Service* 和 @Repository。 它们在ApplicationContext中注册，因为它们使用*@Component*注释： @Component public @interface Service { } @Component public @interface Repository { } @Service 和 @Repository是*@Component*的特例。它们在技术上是相同的，但我们将它们用于不同的目的。 3.2. *@Repository* *@Repository*的工作是捕获特定于持久性的异常并将它们作为 Spring 的统一未检查异常之一重新抛出。 为此，Spring 提供了PersistenceExceptionTranslationPostProcessor，我们需要将其添加到我们的应用程序上下文中（如果我们使用 Spring Boot，则已经包括在内）： \u0026lt;bean class= \u0026#34;org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\u0026#34;/\u0026gt; 这个 bean 后处理器为任何使用 @Repository 注释的 bean 添加了一个顾问。 3.3. *@服务* 我们用@Service 标记bean 以表明它们持有业务逻辑。该注解除了用于服务层外，没有其他特殊用途。 4。结论 在本文中，我们了解了*@Component、@Repository*和*@Service*注释之间的区别。我们分别检查了每个注释以了解它们的使用领域。 总之，根据图层约定选择注释总是一个好主意。 ","permalink":"http://itcodingman.github.io/spring-component-repository-service/","tags":null,"title":""},{"categories":null,"contents":"Spring @Controller 和 @RestController 注解 一、概述 在这个简短的教程中，我们将讨论Spring MVC 中*@Controller和@RestController注解之间的区别。* 我们可以将第一个注解用于传统的 Spring 控制器，它已经成为框架的一部分很长时间了。 Spring 4.0 引入了*@RestController注解，以简化 RESTful Web 服务的创建。这是一个方便的注解，结合了*@Controller*和*@ResponseBody*，它消除了使用@ResponseBody*注解对控制器类的每个请求处理方法进行注解的需要。 进一步阅读： 春季请求映射 Spring @RequestMapping - 基本示例、@RequestParam、@PathVariable、标头映射 阅读更多→ Spring @RequestParam 注解 Spring 的 @RequestParam 注解的详细指南 阅读更多→ 2. Spring MVC @Controller 我们可以使用*@Controller*注解来注解经典控制器。这只是 @Component类的一个特化，它允许我们通过类路径扫描自动检测实现类。 我们通常将 @Controller与*@RequestMapping*注解结合使用，用于请求处理方法。 让我们看一个 Spring MVC 控制器的快速示例： @Controller @RequestMapping(\u0026#34;books\u0026#34;) public class SimpleBookController { @GetMapping(\u0026#34;/{id}\u0026#34;, produces = \u0026#34;application/json\u0026#34;) public @ResponseBody Book getBook(@PathVariable int id) { return findBookById(id); } private Book findBookById(int id) { // ...  } } 我们用@ResponseBody注释了请求处理方法。此注释支持将返回对象自动序列化到HttpResponse中。 3. Spring MVC @RestController @RestController是控制器的专用版本。它包括*@Controller和@ResponseBody*注释，因此简化了控制器的实现： @RestController @RequestMapping(\u0026#34;books-rest\u0026#34;) public class SimpleBookRestController { @GetMapping(\u0026#34;/{id}\u0026#34;, produces = \u0026#34;application/json\u0026#34;) public Book getBook(@PathVariable int id) { return findBookById(id); } private Book findBookById(int id) { // ...  } } 控制器使用*@RestController*注解进行注解；因此，*不需要@ResponseBody*。 控制器类的每个请求处理方法都会自动将返回对象序列化为HttpResponse。 4。结论 在本文中，我们检查了 Spring 框架中可用的经典和专用 REST 控制器。 示例的完整源代码可在GitHub 项目中找到。这是一个 Maven 项目，因此可以按原样导入和使用。 ","permalink":"http://itcodingman.github.io/spring-controller-vs-restcontroller/","tags":null,"title":""},{"categories":null,"contents":"Spring 核心注解 一、概述 我们可以使用org.springframework.beans.factory.annotation 和 org.springframework.context.annotation包中的注释来利用 Spring DI 引擎的功能。 我们经常将这些称为“Spring 核心注释”，我们将在本教程中回顾它们。 2. DI 相关注解 2.1。@自动连线 我们可以使用*@Autowired*来标记 Spring 将要解析和注入的依赖项。我们可以将此注解与构造函数、setter 或字段注入一起使用。 构造函数注入： class Car { Engine engine; @Autowired Car(Engine engine) { this.engine = engine; } } 二传手注入： class Car { Engine engine; @Autowired void setEngine(Engine engine) { this.engine = engine; } } 现场注入： class Car { @Autowired Engine engine; } @Autowired有一个名为required的**布尔参数，默认值为true。当找不到合适的 bean 进行连接时，它会调整 Spring 的行为。当true时，抛出异常，否则，什么都没有连接。 请注意，如果我们使用构造函数注入，则所有构造函数参数都是必需的。 从 4.3 版开始，除非我们声明至少两个构造函数，否则我们不需要显式使用*@Autowired注释构造函数。* 有关更多详细信息，请访问我们关于@Autowired和构造函数注入的文章。 2.2. @豆 @Bean标记了一个实例化 Spring bean 的工厂方法： @Bean Engine engine() { return new Engine(); } 当需要返回类型的新实例时，Spring 会调用这些方法。 生成的 bean 与工厂方法具有相同的名称。如果我们想以不同的方式命名它，我们可以使用这个注解的name或value参数（参数value是参数name的别名）： @Bean(\u0026#34;engine\u0026#34;) Engine getEngine() { return new Engine(); } 请注意，所有使用*@Bean注释的方法都必须在@Configuration*类中。 2.3. @Qualifier 我们使用*@Qualifier和@Autowired*来提供我们想要在模棱两可的情况下使用的bean id 或bean 名称。 例如，以下两个 bean 实现了相同的接口： class Bike implements Vehicle {} class Car implements Vehicle {} 如果 Spring 需要注入一个Vehicle bean，它最终会得到多个匹配的定义。在这种情况下，我们可以使用@Qualifier注释显式地提供 bean 的名称。 使用构造函数注入： @Autowired Biker(@Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle) { this.vehicle = vehicle; } 使用 setter 注入： @Autowired void setVehicle(@Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle) { this.vehicle = vehicle; } 或者： @Autowired @Qualifier(\u0026#34;bike\u0026#34;) void setVehicle(Vehicle vehicle) { this.vehicle = vehicle; } 使用字段注入： @Autowired @Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle; 更详细的描述，请阅读这篇文章。 2.4. @必需的 @Required在 setter 方法上标记我们希望通过 XML 填充的依赖项： @Required void setColor(String color) { this.color = color; } \u0026lt;bean class=\u0026#34;com.codingman.annotations.Bike\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;green\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 否则，将抛出BeanInitializationException 。 2.5. @价值 我们可以使用@Value将属性值注入到 bean 中。它与构造函数、设置器和字段注入兼容。 构造函数注入： Engine(@Value(\u0026#34;8\u0026#34;) int cylinderCount) { this.cylinderCount = cylinderCount; } 二传手注入： @Autowired void setCylinderCount(@Value(\u0026#34;8\u0026#34;) int cylinderCount) { this.cylinderCount = cylinderCount; } 或者： @Value(\u0026#34;8\u0026#34;) void setCylinderCount(int cylinderCount) { this.cylinderCount = cylinderCount; } 现场注入： @Value(\u0026#34;8\u0026#34;) int cylinderCount; 当然，注入静态值是没有用的。因此，我们可以在*@Value中使用占位符字符串来连接外部源中定义的**值，例如，在.properties或.yaml*文件中。 让我们假设以下*.properties*文件： engine.fuelType=petrol 我们可以使用以下内容注入engine.fuelType的值： @Value(\u0026#34;${engine.fuelType}\u0026#34;) String fuelType; 即使在 SpEL 中，我们也可以使用*@Value*。更多高级示例可以在我们关于*@Value*的文章中找到。 2.6. @取决于 我们可以使用这个注解让Spring在被注解的bean之前初始化其他bean。通常，这种行为是自动的，基于 bean 之间的显式依赖关系。 我们只有在依赖是隐式的时候才需要这个注解，例如 JDBC 驱动加载或者静态变量初始化。 我们可以在依赖类上使用*@DependsOn来指定依赖bean 的名称。注释的value*参数需要一个包含依赖 bean 名称的数组： @DependsOn(\u0026#34;engine\u0026#34;) class Car implements Vehicle {} 或者，如果我们使用*@Bean注解定义 bean，则工厂方法应该使用@DependsOn*进行注解： @Bean @DependsOn(\u0026#34;fuel\u0026#34;) Engine engine() { return new Engine(); } 2.7. @懒惰的 当我们想要懒惰地初始化我们的bean时，我们使用@Lazy 。默认情况下，Spring 在应用程序上下文的启动/引导时急切地创建所有单例 bean。 但是，在某些情况下，我们需要在请求时创建 bean，而不是在应用程序启动时。 这个注解的行为会根据我们准确放置的位置而有所不同。我们可以装上：  一个*@Bean*注释的 bean 工厂方法，用于延迟方法调用（因此创建 bean） 一个*@Configuration类和所有包含的@Bean*方法都会受到影响 一个*@Component类，它不是一个@Configuration*类，这个bean 将被延迟初始化 @Autowired构造函数、设置器或字段，用于延迟加载依赖项本身（通过代理）  此注释有一个名为value的参数，默认值为true。覆盖默认行为很有用。 例如，当全局设置为惰性时，将 bean 标记为预加载，或者在标有*@Lazy的**@Configuration类中配置特定的 @Bean*方法以预加载： @Configuration @Lazy class VehicleFactoryConfig { @Bean @Lazy(false) Engine engine() { return new Engine(); } } 如需进一步阅读，请访问本文。 2.8. @抬头 使用*@Lookup*注释的方法告诉 Spring 在我们调用它时返回该方法的返回类型的实例。 有关注释的详细信息可以在本文中找到。 2.9。@基本的 有时我们需要定义多个相同类型的bean。在这些情况下，注入将不成功，因为 Spring 不知道我们需要哪个 bean。 我们已经看到了处理这种情况的一个选项：用*@Qualifier*标记所有连接点并指定所需bean 的名称。 然而，大多数时候我们需要一个特定的 bean 而很少需要其他的。我们可以使用*@Primary来简化这种情况：如果我们用**@Primary*****标记最常用的bean，**它将在不合格的注入点上被选中： @Component @Primary class Car implements Vehicle {} @Component class Bike implements Vehicle {} @Component class Driver { @Autowired Vehicle vehicle; } @Component class Biker { @Autowired @Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle; } 在前面的示例中，汽车是主要车辆。因此，在Driver类中，Spring 注入了一个Car bean。当然，在Biker bean 中，字段vehicle的值将是Bike对象，因为它是合格的。 2.10。@范围 我们使用*@Scope来定义@Component类或@Bean定义的范围。它可以是单例、原型、请求、会话、globalSession*或一些自定义范围。 例如： @Component @Scope(\u0026#34;prototype\u0026#34;) class Engine {} 3. 上下文配置注解 我们可以使用本节中描述的注释来配置应用程序上下文。 3.1。@轮廓 如果我们希望 Spring**仅在特定配置文件处于活动状态时*使用*@Component*类或*@Bean**方法，我们可以用@Profile标记它。我们可以使用注解的value参数配置配置文件的名称： @Component @Profile(\u0026#34;sportDay\u0026#34;) class Bike implements Vehicle {} 您可以在本文中阅读有关配置文件的更多信息。 3.2. @进口 我们可以使用**特定的*@Configuration*类而无需使用此注解进行组件扫描。*我们可以为这些类提供@Import的value*参数： @Import(VehiclePartSupplier.class) class VehicleFactoryConfig {} 3.3. @ImportResource 我们可以使用此注解**导入 XML 配置。**我们可以使用位置参数指定 XML 文件位置，或者使用它的别名，值参数： @Configuration @ImportResource(\u0026#34;classpath:/annotations.xml\u0026#34;) class VehicleFactoryConfig {} 3.4. @PropertySource 使用此注解，我们可以为应用程序设置定义属性文件： @Configuration @PropertySource(\u0026#34;classpath:/annotations.properties\u0026#34;) class VehicleFactoryConfig {} @PropertySource利用 Java 8 重复注释功能，这意味着我们可以多次使用它标记一个类： @Configuration @PropertySource(\u0026#34;classpath:/annotations.properties\u0026#34;) @PropertySource(\u0026#34;classpath:/vehicle-factory.properties\u0026#34;) class VehicleFactoryConfig {} 3.5. @PropertySources 我们可以使用这个注解来指定多个*@PropertySource*配置： @Configuration @PropertySources({ @PropertySource(\u0026#34;classpath:/annotations.properties\u0026#34;), @PropertySource(\u0026#34;classpath:/vehicle-factory.properties\u0026#34;) }) class VehicleFactoryConfig {} 请注意，从 Java 8 开始，我们可以通过上述重复注释功能实现相同的功能。 4。结论 在本文中，我们看到了最常见的 Spring 核心注解的概述。我们看到了如何配置 bean 连接和应用程序上下文，以及如何标记类以进行组件扫描。 像往常一样，这些示例可以在 GitHub 上找到。 ","permalink":"http://itcodingman.github.io/spring-core-annotations/","tags":null,"title":""},{"categories":null,"contents":"JPA 和 Spring 的 DAO 一、概述 本文将展示如何使用 Spring 和 JPA 实现 DAO。有关核心 JPA 配置，请参阅有关 JPA with Spring 的文章。 2. 不再有 Spring 模板 从 Spring 3.1 开始，已弃用JpaTemplate和相应的JpaDaoSupport 以支持使用本机 Java Persistence API。 此外，这两个类仅与 JPA 1 相关（来自JpaTemplate javadoc）：  请注意，此类没有升级到 JPA 2.0，也永远不会升级。  因此，现在最好的做法是直接使用 Java Persistence API而不是JpaTemplate。 2.1. 没有模板的异常翻译 JpaTemplate的职责之一是异常转换——将低级异常转换为更高级别的通用 Spring 异常。 如果没有模板，异常翻译仍然可以为所有使用 @Repository 注释的 DAO启用并完全正常运行。Spring 使用 bean 后处理器实现这一点，该后处理器将使用容器中找到的所有PersistenceExceptionTranslator通知所有**@Repository bean 。 同样重要的是要注意异常转换机制使用代理——为了让 Spring 能够围绕 DAO 类创建代理，这些代理不能被声明为final。 3. DAO 首先，我们将为所有 DAO 实现基础层——一个使用泛型并设计为可扩展的抽象类： public abstract class AbstractJpaDAO\u0026lt; T extends Serializable \u0026gt; { private Class\u0026lt; T \u0026gt; clazz; @PersistenceContext EntityManager entityManager; public final void setClazz( Class\u0026lt; T \u0026gt; clazzToSet ){ this.clazz = clazzToSet; } public T findOne( long id ){ return entityManager.find( clazz, id ); } public List\u0026lt; T \u0026gt; findAll(){ return entityManager.createQuery( \u0026#34;from \u0026#34; + clazz.getName() ) .getResultList(); } public void create( T entity ){ entityManager.persist( entity ); } public T update( T entity ){ return entityManager.merge( entity ); } public void delete( T entity ){ entityManager.remove( entity ); } public void deleteById( long entityId ){ T entity = findOne( entityId ); delete( entity ); } } 这里主要有趣的方面是EntityManager*的*注入方式——使用标准的*@PersistenceContext注释。在后台，这是由PersistenceAnnotationBeanPostProcessor*处理的——它处理注释，从包含中检索 JPA 实体管理器并注入它。 持久化后处理器要么通过在配置中定义显式创建，要么通过在命名空间配置中定义context:annotation-config或context:component-scan自动创建。 另外，请注意实体Class在构造函数中传递以用于通用操作： @Repository public class FooDAO extends AbstractJPADAO\u0026lt; Foo \u0026gt; implements IFooDAO{ public FooDAO(){ setClazz(Foo.class ); } } 4。结论 本教程说明了如何使用 Spring 和 JPA 设置 DAO 层，同时使用基于 XML 和 Java 的配置。我们还讨论了为什么不使用JpaTemplate以及如何用EntityManager替换它。最终结果是一个轻量级、干净的 DAO 实现，编译时几乎不依赖 Spring。 这个简单项目的实现可以在GitHub 项目中找到——这是一个基于 Maven 的项目，所以它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-dao-jpa/","tags":null,"title":""},{"categories":null,"contents":"Spring Data Cassandra简介 一、概述 本文是使用 Spring Data 使用 Cassandra 的实用介绍。 我们将从基础开始，通过配置和编码，最终构建一个完整的 Spring Data Cassandra 模块。 进一步阅读： 使用 Cassandra、Astra 和 Stargate 构建仪表板 了解如何使用 DataStax Astra 构建仪表板，这是一种由 Apache Cassandra 和 Stargate API 提供支持的数据库即服务。 阅读更多→ 使用 Cassandra、Astra、REST 和 GraphQL 构建仪表板——记录状态更新 使用 Cassandra 存储时间序列数据的示例。 阅读更多→ 使用 Cassandra、Astra 和 CQL 构建仪表板——映射事件数据 了解如何根据存储在 Astra 数据库中的数据在交互式地图上显示事件。 阅读更多→ 2.Maven依赖 让我们首先使用 Maven在pom.xml中定义依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.datastax.cassandra\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-driver-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3. Cassandra的配置 我们将在整个过程中使用 Java 配置风格来配置 Cassandra 集成。 3.1。主要配置（弹簧） 我们将为此使用 Java 配置风格。让我们从主要的配置类开始——当然是通过类级别的*@Configuration*注解驱动的： @Configuration public class CassandraConfig extends AbstractCassandraConfiguration { @Override protected String getKeyspaceName() { return \u0026#34;testKeySpace\u0026#34;; } @Bean public CassandraClusterFactoryBean cluster() { CassandraClusterFactoryBean cluster = new CassandraClusterFactoryBean(); cluster.setContactPoints(\u0026#34;127.0.0.1\u0026#34;); cluster.setPort(9142); return cluster; } @Bean public CassandraMappingContext cassandraMapping() throws ClassNotFoundException { return new BasicCassandraMappingContext(); } } 注意带有默认实现的新 bean - *BasicCassandraMappingContext 。*这是在它们的对象和它们的持久格式之间映射持久实体所必需的。 并且由于默认实现足够强大，我们可以直接使用它。 3.2. 主要配置（Spring Boot） 让我们通过application.properties进行 Cassandra 配置： spring.data.cassandra.keyspace-name=testKeySpace spring.data.cassandra.port=9142 spring.data.cassandra.contact-points=127.0.0.1 我们完成了！这就是我们在使用 Spring Boot 时所需要的。 3.3. Cassandra 连接属性 我们必须配置三个强制设置来设置 Cassandra 客户端的连接。 我们必须设置 Cassandra 服务器作为联系点运行的主机名*。端口*只是服务器中请求的侦听端口。KeyspaceName是定义节点上数据复制的命名空间，它基于 Cassandra 相关概念。 4. Cassandra 存储库 我们将使用CassandraRepository作为数据访问层。这遵循 Spring Data repository 抽象，该抽象专注于抽象出跨不同持久性机制实现数据访问层所需的代码。 4.1。创建*Cassandra 存储库* 让我们创建要在配置中使用的CassandraRepository： @Repository public interface BookRepository extends CassandraRepository\u0026lt;Book\u0026gt; { // } 4.2. *CassandraRepository*的配置 现在，我们可以扩展第 3.1 节中的配置，在 CassandraConfig 中添加*@EnableCassandraRepositories*类级别注释来标记我们在第 4.1 节中创建的 Cassandra Repository ： @Configuration @EnableCassandraRepositories( basePackages = \u0026#34;com.codingman.spring.data.cassandra.repository\u0026#34;) public class CassandraConfig extends AbstractCassandraConfiguration { // } 5. 实体 让我们快速看一下实体——我们将要使用的模型类。该类被注释并定义了嵌入模式下元数据 Cassandra 数据表创建的附加参数。 使用*@Table*注解，bean 直接映射到 Cassandra 数据表。此外，每个属性都被定义为一种主键或简单列： @Table public class Book { @PrimaryKeyColumn( name = \u0026#34;isbn\u0026#34;, ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING) private UUID id; @PrimaryKeyColumn( name = \u0026#34;title\u0026#34;, ordinal = 0, type = PrimaryKeyType.PARTITIONED) private String title; @PrimaryKeyColumn( name = \u0026#34;publisher\u0026#34;, ordinal = 1, type = PrimaryKeyType.PARTITIONED) private String publisher; @Column private Set\u0026lt;String\u0026gt; tags = new HashSet\u0026lt;\u0026gt;(); // standard getters and setters } 6. 使用嵌入式服务器进行测试 6.1。Maven 依赖项 如果要在嵌入式模式下运行 Cassandra（无需手动安装单独的 Cassandra 服务器），则需要将cassandra-unit相关依赖项添加到pom.xml中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.cassandraunit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-unit-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.9.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.cassandraunit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-unit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.cassandraunit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-unit-shaded\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.9.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hectorclient\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hector-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0-0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以使用嵌入式 Cassandra 服务器来测试此应用程序。主要优点是您不想显式安装 Cassandra。 这个嵌入式服务器也与 Spring JUnit 测试兼容。在这里，我们可以使用*@RunWith注解与嵌入式服务器一起设置SpringJUnit4ClassRunner 。*因此，无需运行外部 Cassandra 服务即可实现完整的测试套件。 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = CassandraConfig.class) public class BookRepositoryIntegrationTest { // } 6.2. 启动和停止服务器 如果您正在运行外部 Cassandra 服务器，则可以忽略此部分。 我们必须为整个测试套件启动一次服务器，因此服务器启动方法用*@BeforeClass*注释标记： @BeforeClass public static void startCassandraEmbedded() { EmbeddedCassandraServerHelper.startEmbeddedCassandra(); Cluster cluster = Cluster.builder() .addContactPoints(\u0026#34;127.0.0.1\u0026#34;).withPort(9142).build(); Session session = cluster.connect(); } 接下来，我们必须确保在测试套件执行完成后服务器停止： @AfterClass public static void stopCassandraEmbedded() { EmbeddedCassandraServerHelper.cleanEmbeddedCassandra(); } 6.3. 清洁数据表 最好在每次测试执行之前删除并创建数据表，以避免由于早期测试执行中的操纵数据而导致意外结果。 现在我们可以在服务器启动时创建数据表： @Before public void createTable() { adminTemplate.createTable( true, CqlIdentifier.cqlId(DATA_TABLE_NAME), Book.class, new HashMap\u0026lt;String, Object\u0026gt;()); } 并在每个测试用例执行后丢弃： @After public void dropTable() { adminTemplate.dropTable(CqlIdentifier.cqlId(DATA_TABLE_NAME)); } 7. 使用*CassandraRepository 进行数据访问* 我们可以直接使用上面创建的BookRepository来持久化、操作和获取 Cassandra 数据库中的数据。 7.1。保存一本新书 我们可以将一本新书保存到我们的书店： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); 然后我们可以检查数据库中插入的书的可用性： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); assertEquals(javaBook.getId(), books.iterator().next().getId()); 7.2. 更新现有书籍 Lat 从插入一本新书开始： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); 让我们按标题获取这本书： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); 那我们改一下书名： javaBook.setTitle(\u0026#34;Head First Java Second Edition\u0026#34;); bookRepository.save(ImmutableSet.of(javaBook)); 最后让我们检查一下数据库中的标题是否更新： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java Second Edition\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); assertEquals( javaBook.getTitle(), updateBooks.iterator().next().getTitle()); 7.3. 删除现有书籍 插入一本新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); 然后删除新输入的书： bookRepository.delete(javaBook); 现在我们可以检查删除： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); assertNotEquals(javaBook.getId(), books.iterator().next().getId()); 这将导致从代码中抛出 NoSuchElementException 以确保该书已被删除。 7.4. 查找所有书籍 先插入一本新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); Book dPatternBook = new Book( UUIDs.timeBased(), \u0026#34;Head Design Patterns\u0026#34;,\u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); bookRepository.save(ImmutableSet.of(dPatternBook)); 查找所有书籍： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findAll(); 然后我们可以检查数据库中可用书籍的数量： int bookCount = 0; for (Book book : books) bookCount++; assertEquals(bookCount, 2); 8. 结论 我们通过使用CassandraRepository数据访问机制的最常见方法，对带有 Spring 数据的 Cassandra 进行了基本的动手介绍。 上述代码片段和示例的实现可以在我的 GitHub 项目中找到——这是一个基于 Eclipse 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-data-cassandra-tutorial/","tags":null,"title":""},{"categories":null,"contents":"使用 Spring Data 中的 CassandraTemplate 一、概述 这是 Spring Data Cassandra 文章系列的第二篇。在本文中，我们将主要关注数据访问层中的CassandraTemplate和 CQL 查询。您可以在该系列的第一篇文章中阅读有关 Spring Data Cassandra 的更多信息。 Cassandra Query Language (CQL) 是 Cassandra 数据库的查询语言，CqlTemplate是 Spring Data Cassandra 中的低级数据访问模板——它方便地公开与数据操作相关的操作以执行 CQL 语句。 CassandraTemplate构建在低级CqlTemplate 之上，并提供了一种简单的方法来查询域对象并将对象映射到 Cassandra 中的持久数据结构。 让我们从配置开始，然后深入研究使用这两个模板的示例。 进一步阅读： 使用 Cassandra、Astra 和 Stargate 构建仪表板 了解如何使用 DataStax Astra 构建仪表板，这是一种由 Apache Cassandra 和 Stargate API 提供支持的数据库即服务。 阅读更多→ 使用 Cassandra、Astra、REST 和 GraphQL 构建仪表板——记录状态更新 使用 Cassandra 存储时间序列数据的示例。 阅读更多→ 使用 Cassandra、Astra 和 CQL 构建仪表板——映射事件数据 了解如何根据存储在 Astra 数据库中的数据在交互式地图上显示事件。 阅读更多→ 2. *Cassandra模板*配置 CassandraTemplate在 Spring 上下文中可用，因为我们的主要 Cassandra Spring 配置正在扩展 AbstractCassandraConfiguration： @Configuration @EnableCassandraRepositories(basePackages = \u0026#34;com.codingman.spring.data.cassandra.repository\u0026#34;) public class CassandraConfig extends AbstractCassandraConfiguration { ... } 然后我们可以在模板中进行简单的连接——或者通过它的确切类型，CassandraTemplate，或者作为更通用的接口CassandraOperations： @Autowired private CassandraOperations cassandraTemplate; 3. 使用*CassandraTemplate 进行数据访问* 让我们使用上面在数据访问层模块中定义的CassandraTemplate来处理数据持久化。 3.1。保存一本新书 我们可以将一本新书保存到我们的书店： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); 然后我们可以检查数据库中插入的书的可用性： Select select = QueryBuilder.select().from(\u0026#34;book\u0026#34;) .where(QueryBuilder.eq(\u0026#34;title\u0026#34;, \u0026#34;Head First Java\u0026#34;)) .and(QueryBuilder.eq(\u0026#34;publisher\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;)); Book retrievedBook = cassandraTemplate.selectOne(select, Book.class); 我们在这里使用Select QueryBuilder，映射到 cassandraTemplate 中的selectOne ( )。我们将在 CQL 查询部分更深入地讨论QueryBuilder。 3.2. 保存多本书 我们可以使用列表一次将多本书保存到我们的书店： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); Book dPatternBook = new Book( UUIDs.timeBased(), \u0026#34;Head Design Patterns\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); List\u0026lt;Book\u0026gt; bookList = new ArrayList\u0026lt;Book\u0026gt;(); bookList.add(javaBook); bookList.add(dPatternBook); cassandraTemplate.insert(bookList); 3.3. 更新现有书籍 Lat 从插入一本新书开始： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); 我们来取书： Select select = QueryBuilder.select().from(\u0026#34;book\u0026#34;); Book retrievedBook = cassandraTemplate.selectOne(select, Book.class); 然后让我们为检索到的书添加一些额外的标签： retrievedBook.setTags(ImmutableSet.of(\u0026#34;Java\u0026#34;, \u0026#34;Programming\u0026#34;)); cassandraTemplate.update(retrievedBook); 3.4. 删除插入的书 让我们插入一本新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); 然后删除这本书： cassandraTemplate.delete(javaBook); 3.5. 删除所有书籍 现在让我们插入一些新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); Book dPatternBook = new Book( UUIDs.timeBased(), \u0026#34;Head Design Patterns\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); cassandraTemplate.insert(dPatternBook); 然后删除所有书籍： cassandraTemplate.deleteAll(Book.class); 4. 使用 CQL 查询的数据访问 始终可以使用 CQL 查询在数据访问层中进行数据操作。CQL 查询处理由CqlTemplate类执行，允许我们根据需要执行自定义查询。 但是，由于CassandraTemplate类是CqlTemplate的扩展，我们可以直接使用它来执行这些查询。 让我们看看我们可以使用 CQL 查询来操作数据的不同方法。 4.1。使用*查询构建器* QueryBuilder可用于为数据库中的数据操作构建查询。几乎所有标准操作都可以使用开箱即用的构建块构建： Insert insertQueryBuider = QueryBuilder.insertInto(\u0026#34;book\u0026#34;) .value(\u0026#34;isbn\u0026#34;, UUIDs.timeBased()) .value(\u0026#34;title\u0026#34;, \u0026#34;Head First Java\u0026#34;) .value(\u0026#34;publisher\u0026#34;, \u0026#34;OReilly Media\u0026#34;) .value(\u0026#34;tags\u0026#34;, ImmutableSet.of(\u0026#34;Software\u0026#34;)); cassandraTemplate.execute(insertQueryBuider); 如果您仔细查看代码片段，您可能会注意到使用了execute()方法而不是相关的操作类型（插入、删除等）。这是因为查询的类型是由QueryBuilder 的输出定义的。 4.2. 使用*PreparedStatements* 尽管PreparedStatements可用于任何情况，但通常建议将此机制用于多个插入以进行高速摄取。 PreparedStatement只准备一次，有助于确保高性能： UUID uuid = UUIDs.timeBased(); String insertPreparedCql = \u0026#34;insert into book (isbn, title, publisher, tags) values (?, ?, ?, ?)\u0026#34;; List\u0026lt;Object\u0026gt; singleBookArgsList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;?\u0026gt;\u0026gt; bookList = new ArrayList\u0026lt;\u0026gt;(); singleBookArgsList.add(uuid); singleBookArgsList.add(\u0026#34;Head First Java\u0026#34;); singleBookArgsList.add(\u0026#34;OReilly Media\u0026#34;); singleBookArgsList.add(ImmutableSet.of(\u0026#34;Software\u0026#34;)); bookList.add(singleBookArgsList); cassandraTemplate.ingest(insertPreparedCql, bookList); 4.3. 使用 CQL 语句 我们可以直接使用CQL语句查询数据，如下： UUID uuid = UUIDs.timeBased(); String insertCql = \u0026#34;insert into book (isbn, title, publisher, tags) values (\u0026#34; + uuid + \u0026#34;, \u0026#39;Head First Java\u0026#39;, \u0026#39;OReilly Media\u0026#39;, {\u0026#39;Software\u0026#39;})\u0026#34;; cassandraTemplate.execute(insertCql); 5. 结论 在本文中，我们研究了使用 Spring Data Cassandra 的各种数据操作策略，包括CassandraTemplate和 CQL 查询。 上述代码片段和示例的实现可以在我的 GitHub 项目中找到——这是一个基于 Maven 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-data-cassandratemplate-cqltemplate/","tags":null,"title":""},{"categories":null,"contents":"Spring JPA – 多个数据库 一、概述 在本教程中，我们将为具有多个数据库的 Spring Data JPA 系统实现一个简单的 Spring 配置。 进一步阅读： Spring Data JPA – 派生删除方法 了解如何定义 Spring Data 的 deleteBy 和 removeBy 方法 阅读更多→ 在 Spring Boot 中以编程方式配置数据源 了解如何以编程方式配置 Spring Boot DataSource，从而避开 Spring Boot 的自动 DataSource 配置算法。 阅读更多→ 2. 实体 首先，让我们创建两个简单的实体，每个实体都存在于一个单独的数据库中。 这是第一个用户 实体： package com.codingman.multipledb.model.user; @Entity @Table(schema = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int id; private String name; @Column(unique = true, nullable = false) private String email; private int age; } 这是第二个实体Product： package com.codingman.multipledb.model.product; @Entity @Table(schema = \u0026#34;products\u0026#34;) public class Product { @Id private int id; private String name; private double price; } 我们可以看到这**两个实体也被放置在独立的包中。**当我们进入配置时，这将很重要。 3. JPA 存储库 接下来，让我们看一下我们的两个 JPA 存储库UserRepository： package com.codingman.multipledb.dao.user; public interface UserRepository extends JpaRepository\u0026lt;User, Integer\u0026gt; { } 和ProductRepository： package com.codingman.multipledb.dao.product; public interface ProductRepository extends JpaRepository\u0026lt;Product, Integer\u0026gt; { } 再次注意我们如何在不同的包中创建这两个存储库。 4.用Java配置JPA 现在我们将了解实际的 Spring 配置。我们将首先设置两个配置类——一个用于*User*，另一个用于*Product*。 在每个配置类中，我们需要为User定义以下接口：  数据源 实体管理器工厂（用户实体管理器） 事务管理器（用户事务管理器）  让我们从查看用户配置开始： @Configuration @PropertySource({ \u0026#34;classpath:persistence-multiple-db.properties\u0026#34; }) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.user\u0026#34;, entityManagerFactoryRef = \u0026#34;userEntityManager\u0026#34;, transactionManagerRef = \u0026#34;userTransactionManager\u0026#34; ) public class PersistenceUserConfiguration { @Autowired private Environment env; @Bean @Primary public LocalContainerEntityManagerFactoryBean userEntityManager() { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(userDataSource()); em.setPackagesToScan( new String[] { \u0026#34;com.codingman.multipledb.model.user\u0026#34; }); HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter(); em.setJpaVendorAdapter(vendorAdapter); HashMap\u0026lt;String, Object\u0026gt; properties = new HashMap\u0026lt;\u0026gt;(); properties.put(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;, env.getProperty(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;)); properties.put(\u0026#34;hibernate.dialect\u0026#34;, env.getProperty(\u0026#34;hibernate.dialect\u0026#34;)); em.setJpaPropertyMap(properties); return em; } @Primary @Bean public DataSource userDataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName( env.getProperty(\u0026#34;jdbc.driverClassName\u0026#34;)); dataSource.setUrl(env.getProperty(\u0026#34;user.jdbc.url\u0026#34;)); dataSource.setUsername(env.getProperty(\u0026#34;jdbc.user\u0026#34;)); dataSource.setPassword(env.getProperty(\u0026#34;jdbc.pass\u0026#34;)); return dataSource; } @Primary @Bean public PlatformTransactionManager userTransactionManager() { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory( userEntityManager().getObject()); return transactionManager; } } 请注意我们如何通过使用 @Primary 注释 bean 定义来使用userTransactionManager作为我们的Primary *TransactionManager*。每当我们要隐式或显式地注入事务管理器而不指定哪个名称时，这都会很有帮助。 接下来，让我们讨论PersistenceProductConfiguration，我们在其中定义了类似的 bean： @Configuration @PropertySource({ \u0026#34;classpath:persistence-multiple-db.properties\u0026#34; }) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.product\u0026#34;, entityManagerFactoryRef = \u0026#34;productEntityManager\u0026#34;, transactionManagerRef = \u0026#34;productTransactionManager\u0026#34; ) public class PersistenceProductConfiguration { @Autowired private Environment env; @Bean public LocalContainerEntityManagerFactoryBean productEntityManager() { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(productDataSource()); em.setPackagesToScan( new String[] { \u0026#34;com.codingman.multipledb.model.product\u0026#34; }); HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter(); em.setJpaVendorAdapter(vendorAdapter); HashMap\u0026lt;String, Object\u0026gt; properties = new HashMap\u0026lt;\u0026gt;(); properties.put(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;, env.getProperty(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;)); properties.put(\u0026#34;hibernate.dialect\u0026#34;, env.getProperty(\u0026#34;hibernate.dialect\u0026#34;)); em.setJpaPropertyMap(properties); return em; } @Bean public DataSource productDataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName( env.getProperty(\u0026#34;jdbc.driverClassName\u0026#34;)); dataSource.setUrl(env.getProperty(\u0026#34;product.jdbc.url\u0026#34;)); dataSource.setUsername(env.getProperty(\u0026#34;jdbc.user\u0026#34;)); dataSource.setPassword(env.getProperty(\u0026#34;jdbc.pass\u0026#34;)); return dataSource; } @Bean public PlatformTransactionManager productTransactionManager() { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory( productEntityManager().getObject()); return transactionManager; } } 5. 简单测试 最后，让我们测试一下我们的配置。 为此，我们将创建每个实体的实例并确保它已创建： @RunWith(SpringRunner.class) @SpringBootTest @EnableTransactionManagement public class JpaMultipleDBIntegrationTest { @Autowired private UserRepository userRepository; @Autowired private ProductRepository productRepository; @Test @Transactional(\u0026#34;userTransactionManager\u0026#34;) public void whenCreatingUser_thenCreated() { User user = new User(); user.setName(\u0026#34;John\u0026#34;); user.setEmail(\u0026#34;john@test.com\u0026#34;); user.setAge(20); user = userRepository.save(user); assertNotNull(userRepository.findOne(user.getId())); } @Test @Transactional(\u0026#34;userTransactionManager\u0026#34;) public void whenCreatingUsersWithSameEmail_thenRollback() { User user1 = new User(); user1.setName(\u0026#34;John\u0026#34;); user1.setEmail(\u0026#34;john@test.com\u0026#34;); user1.setAge(20); user1 = userRepository.save(user1); assertNotNull(userRepository.findOne(user1.getId())); User user2 = new User(); user2.setName(\u0026#34;Tom\u0026#34;); user2.setEmail(\u0026#34;john@test.com\u0026#34;); user2.setAge(10); try { user2 = userRepository.save(user2); } catch (DataIntegrityViolationException e) { } assertNull(userRepository.findOne(user2.getId())); } @Test @Transactional(\u0026#34;productTransactionManager\u0026#34;) public void whenCreatingProduct_thenCreated() { Product product = new Product(); product.setName(\u0026#34;Book\u0026#34;); product.setId(2); product.setPrice(20); product = productRepository.save(product); assertNotNull(productRepository.findOne(product.getId())); } } 6. Spring Boot 中的多个数据库 Spring Boot 可以简化上面的配置。 默认情况下，Spring Boot 将使用前缀为*spring.datasource.**的配置属性实例化其默认*DataSource*： spring.datasource.jdbcUrl = [url] spring.datasource.username = [username] spring.datasource.password = [password] 我们现在想继续使用相同的方式来配置第二个*DataSource*，但使用不同的属性命名空间： spring.second-datasource.jdbcUrl = [url] spring.second-datasource.username = [username] spring.second-datasource.password = [password] 因为我们希望 Spring Boot 自动配置能够获取这些不同的属性（并实例化两个不同的DataSources），所以我们将定义两个类似于前面部分的配置类： @Configuration @PropertySource({\u0026#34;classpath:persistence-multiple-db-boot.properties\u0026#34;}) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.user\u0026#34;, entityManagerFactoryRef = \u0026#34;userEntityManager\u0026#34;, transactionManagerRef = \u0026#34;userTransactionManager\u0026#34;) public class PersistenceUserAutoConfiguration { @Primary @Bean @ConfigurationProperties(prefix=\u0026#34;spring.datasource\u0026#34;) public DataSource userDataSource() { return DataSourceBuilder.create().build(); } // userEntityManager bean  // userTransactionManager bean } @Configuration @PropertySource({\u0026#34;classpath:persistence-multiple-db-boot.properties\u0026#34;}) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.product\u0026#34;, entityManagerFactoryRef = \u0026#34;productEntityManager\u0026#34;, transactionManagerRef = \u0026#34;productTransactionManager\u0026#34;) public class PersistenceProductAutoConfiguration { @Bean @ConfigurationProperties(prefix=\u0026#34;spring.second-datasource\u0026#34;) public DataSource productDataSource() { return DataSourceBuilder.create().build(); } // productEntityManager bean  // productTransactionManager bean } 现在我们已经根据 Boot 自动配置约定在persistence-multiple-db-boot.properties中定义了数据源属性。 有趣的部分是使用***@ConfigurationProperties*****注释数据源 bean 创建方法****。我们只需要指定相应的配置前缀。在这个方法中，我们使用了一个DataSourceBuilder，Spring Boot 会自动处理剩下的事情。 但是如何将配置的属性注入到DataSource配置中呢？ 在DataSourceBuilder上调用*build()方法时，它会调用其私有的bind()*方法： public T build() { Class\u0026lt;? extends DataSource\u0026gt; type = getType(); DataSource result = BeanUtils.instantiateClass(type); maybeGetDriverClassName(); bind(result); return (T) result; } 这个私有方法执行了很多自动配置魔法，将解析的配置绑定到实际的DataSource实例： private void bind(DataSource result) { ConfigurationPropertySource source = new MapConfigurationPropertySource(this.properties); ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases(); aliases.addAliases(\u0026#34;url\u0026#34;, \u0026#34;jdbc-url\u0026#34;); aliases.addAliases(\u0026#34;username\u0026#34;, \u0026#34;user\u0026#34;); Binder binder = new Binder(source.withAliases(aliases)); binder.bind(ConfigurationPropertyName.EMPTY, Bindable.ofInstance(result)); } 尽管我们自己不必接触任何这些代码，但了解 Spring Boot 自动配置背后发生的事情仍然很有用。 除此之外，事务管理器和实体管理器 bean 配置与标准 Spring 应用程序相同。 7. 结论 本文是关于如何配置我们的 Spring Data JPA 项目以使用多个数据库的实用概述。 完整的实现可以在GitHub 项目中找到。这是一个基于 Maven 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-data-jpa-multiple-databases/","tags":null,"title":""},{"categories":null,"contents":"Spring Data MongoDB 教程 这是 Spring Data MongoDB 的指南——从快速介绍如何在 Spring 项目中开始运行，到更复杂和有用的用例和库的特性。 Spring Data MongoDB 基础知识  *Spring Data MongoDB 简介* *Spring Data MongoDB 中的查询指南*  Spring Data MongoDB 高级  *Spring Data MongoDB——索引、注释和转换器* *Spring Data MongoDB 中的自定义级联* *Spring Data MongoDB 中的 GridFS* *使用 MongoDB 和 Spring Boot 上传和检索文件* *使用 Spring Boot 为 MongoDB 自动生成的字段* *ZonedDateTime 与 Spring Data MongoDB* *Spring Data MongoDB 事务* *Spring Data Reactive Repositories with MongoDB* *Spring Data MongoDB：投影和聚合* *使用嵌入式 MongoDB 进行 Spring Boot 集成测试*  ","permalink":"http://itcodingman.github.io/spring-data-mongodb-guide/","tags":null,"title":""},{"categories":null,"contents":"","permalink":"http://itcodingman.github.io/search/","tags":null,"title":"Search"}]