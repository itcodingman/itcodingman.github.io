[{"categories":["Java","Youtube"],"contents":"10分钟学习Java Log   ","permalink":"http://itcodingman.github.io/10_mins_java_log/","tags":["JUL","Slf4j","Log4j","Log4j2","JCL","Logback","Commons logging"],"title":"10分钟学习Java Log"},{"categories":["Java","BiliBili"],"contents":"一小时学习Servlet 本教程将讲解如何使用 Java Servlet 来开发基于 web 的应用程序。 \r","permalink":"http://itcodingman.github.io/1_hour_servlet/","tags":[],"title":"一小时学习Servlet"},{"categories":["Spring","Persistence"],"contents":"Grails 3 和 GORM 简介 1. 概述 这是对 Grails 3 和 GORM 的快速介绍。 我们当然会使用 Groovy，并且——隐含地——该框架还使用 Hibernate 来实现 ORM，Spring 框架用于依赖注入，SiteMash 用于布局和主题等。 2.数据源配置 我们无需指定任何显式数据源配置即可开始——默认情况下，Grails 使用 HSQLDB 数据库作为开发和测试环境。 但是如果你想改变这些默认值，你可以在application.yml中定义你选择的数据源： environments: development: dataSource: driverClassName : \u0026#34;com.mysql.jdbc.Driver\u0026#34; url : \u0026#34;jdbc:mysql://localhost:8080/test\u0026#34; dialect : org.hibernate.dialect.MySQL5InnoDBDialect 同样，我们可以在这里创建多个环境，如果需要，可以在开发旁边。 3. Domain Grails 能够基于数据库配置中的dbCreate属性为我们的域类创建数据库结构。 让我们在这里定义这些域类之一： Class User { String userName String password String email String age static constraints = { userName blank: false, unique: true password size: 5..10, blank: false email email: true, blank: true } } 请注意我们如何在模型中指定我们的验证约束，这使事情变得干净整洁，并且没有注释。 当实体被持久化时，这些约束将由 Grails 自动检查，如果这些约束中的任何一个被破坏，框架将抛出适当的验证异常。 我们还可以在模型的映射属性中指定 GORM 映射： static mapping = { sort \u0026#34;userName\u0026#34; } 现在，如果我们调用User.list() - 我们将返回按*用户名*****排序的结果。 我们当然可以通过将排序传递给列表 API 来实现相同的结果： User.list(sort: \u0026#34;userName\u0026#34;) 4. CRUD 操作 当我们看 API 操作时，脚手架在开始时扮演着非常有趣的角色；它允许您为域类生成基本的 CRUD API，包括：  必要的视图 标准 CRUD 操作的控制器操作 两种类型：动态和静态  以下是动态脚手架的工作原理： class UserController { static scaffold = true } 只需编写这一行代码，框架就会在运行时生成 7 个方法：显示、编辑、删除、创建、保存和更新。这些将作为该特定域实体的 API 发布。 静态脚手架示例：  使用脚手架创建视图：“ grails generate-views User ” 使用脚手架创建控制器和视图：“ grails generate-controller User ” 要在单个命令中创建所有内容，请使用：“ grails generate-all User ”  这些命令将为该特定域对象自动生成必要的管道。 现在让我们快速了解如何使用这些操作——例如，对于我们的用户域对象。 **创建新的“用户”**记录： def user = new User(username: \u0026#34;test\u0026#34;, password: \u0026#34;test123\u0026#34;, email: \u0026#34;a@a.com\u0026#34;, age: 14) user.save() 要获取单个记录： def user = User.get(1) 此获取API 将以可编辑模式检索域对象。对于只读模式，我们可以使用read API： def user = User.read(1) 要更新现有记录： def user = User.get(1) user.userName = \u0026#34;testUpdate\u0026#34; user.age = 20 user.save() 以及对现有记录的简单删除操作： def user = User.get(1) user.delete() 5. GORM 查询 5.1 find 让我们从find API 开始： def user = User.find(\u0026#34;from User as u where u.username = \u0026#39;test\u0026#39; \u0026#34;) 我们还可以使用不同的语法来传递参数： def user = User.find(\u0026#34;from User as u where u.username?\u0026#34;, [\u0026#39;test\u0026#39;]) 我们还可以使用命名参数： def user = User.find(\u0026#34;from User as u where u.username=?\u0026#34;, [username: \u0026#39;test\u0026#39;]) 5.2. findBy Grails 提供了一个动态查找工具，它使用域属性在运行时执行查询并返回第一个匹配记录： def user = User.findByUsername(\u0026#34;test\u0026#34;) user = User.findByUsernameAndAge(\u0026#34;test\u0026#34;, 20) user = User.findByUsernameLike(\u0026#34;tes\u0026#34;) user = User.findByUsernameAndAgeNotEquals(\u0026#34;test\u0026#34;, \u0026#34;100\u0026#34;) 你可以在这里找到更多的表达方式。 5.3. Criteria 我们还可以使用一些灵活的标准检索数据： def user = User.find { username == \u0026#34;test\u0026#34;} def user = User.createCriteria() def results = user.list { like (\u0026#34;userName\u0026#34;, \u0026#34;te%\u0026#34;) and { between(\u0026#34;age\u0026#34;, 10, 20) } order(\u0026#34;userName\u0026#34;, \u0026#34;desc\u0026#34;) } 这里有一个说明——当使用条件查询时，使用“{}”而不是“()”。 5.4. 执行查询/更新 GORM 还支持 HQL 查询语法——用于读取操作： def user = User.executeQuery( \u0026#34;select u.userName from User u where u.userName = ?\u0026#34;, [\u0026#39;test\u0026#39;]) 以及写操作： def user = User.executeUpdate(\u0026#34;delete User u where u.username =?\u0026#34;, [\u0026#39;test\u0026#39;]) ","permalink":"http://itcodingman.github.io/grails-gorm-tutorial/","tags":[],"title":"Grails 3 和 GORM 简介"},{"categories":["Spring"],"contents":"Spring Batch 简介 1. 概述 在本教程中，我们将看一个实用的、以代码为中心的 Spring Batch 介绍。Spring Batch 是一个处理框架，专为作业的稳健执行而设计。 它的当前版本 4.3 支持 Spring 5 和 Java 8。它还适应 JSR-352，这是用于批处理的新 Java 规范。 以下是该框架的一些有趣且实用的用例。 2. 工作流程基础 Spring Batch 遵循传统的批处理架构，其中作业存储库执行调度和与作业交互的工作。 一个作业可以有多个步骤。每个步骤通常遵循读取数据、处理数据和写入数据的顺序。 当然，这里的框架将为我们完成大部分繁重的工作——尤其是在处理作业的低级持久性工作时——使用sqlite作为作业存储库。 2.1 示例用例 我们将在这里处理的简单用例是将一些金融交易数据从 CSV 迁移到 XML。 输入文件的结构非常简单。 它包含每行的交易，由用户名、用户 ID、交易日期和金额组成： username, userid, transaction_date, transaction_amount ann, 1234, 31/10/2015, 10000 bob, 2134, 3/12/2015, 12321 robin, 3134, 2/02/2015, 23411 3. Maven POM 本项目需要的依赖有spring core、spring batch和sqlite jdbc connector： \u0026lt;!-- SQLite database driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.xerial\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sqlite-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-oxm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.batch\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-batch-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4. Spring批处理配置 我们要做的第一件事是使用 XML 配置 Spring Batch： \u0026lt;!-- connect to SQLite database --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;org.sqlite.JDBC\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:sqlite:repository.sqlite\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- create job-meta tables automatically --\u0026gt; \u0026lt;jdbc:initialize-database data-source=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;jdbc:script location=\u0026#34;org/springframework/batch/core/schema-drop-sqlite.sql\u0026#34; /\u0026gt; \u0026lt;jdbc:script location=\u0026#34;org/springframework/batch/core/schema-sqlite.sql\u0026#34; /\u0026gt; \u0026lt;/jdbc:initialize-database\u0026gt; \u0026lt;!-- stored job-meta in memory --\u0026gt; \u0026lt;!-- \u0026lt;bean id=\u0026#34;jobRepository\u0026#34; class=\u0026#34;org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- stored job-meta in database --\u0026gt; \u0026lt;bean id=\u0026#34;jobRepository\u0026#34; class=\u0026#34;org.springframework.batch.core.repository.support.JobRepositoryFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;transactionManager\u0026#34; ref=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;databaseType\u0026#34; value=\u0026#34;sqlite\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class= \u0026#34;org.springframework.batch.support.transaction.ResourcelessTransactionManager\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;jobLauncher\u0026#34; class=\u0026#34;org.springframework.batch.core.launch.support.SimpleJobLauncher\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;jobRepository\u0026#34; ref=\u0026#34;jobRepository\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 当然，也可以使用 Java 配置： @Configuration @EnableBatchProcessing public class SpringConfig { @Value(\u0026#34;org/springframework/batch/core/schema-drop-sqlite.sql\u0026#34;) private Resource dropReopsitoryTables; @Value(\u0026#34;org/springframework/batch/core/schema-sqlite.sql\u0026#34;) private Resource dataReopsitorySchema; @Bean public DataSource dataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\u0026#34;org.sqlite.JDBC\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:sqlite:repository.sqlite\u0026#34;); return dataSource; } @Bean public DataSourceInitializer dataSourceInitializer(DataSource dataSource) throws MalformedURLException { ResourceDatabasePopulator databasePopulator = new ResourceDatabasePopulator(); databasePopulator.addScript(dropReopsitoryTables); databasePopulator.addScript(dataReopsitorySchema); databasePopulator.setIgnoreFailedDrops(true); DataSourceInitializer initializer = new DataSourceInitializer(); initializer.setDataSource(dataSource); initializer.setDatabasePopulator(databasePopulator); return initializer; } private JobRepository getJobRepository() throws Exception { JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean(); factory.setDataSource(dataSource()); factory.setTransactionManager(getTransactionManager()); factory.afterPropertiesSet(); return (JobRepository) factory.getObject(); } private PlatformTransactionManager getTransactionManager() { return new ResourcelessTransactionManager(); } public JobLauncher getJobLauncher() throws Exception { SimpleJobLauncher jobLauncher = new SimpleJobLauncher(); jobLauncher.setJobRepository(getJobRepository()); jobLauncher.afterPropertiesSet(); return jobLauncher; } } 5. Spring Batch 作业配置 现在让我们为 CSV 到 XML 工作编写工作描述： \u0026lt;import resource=\u0026#34;spring.xml\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;record\u0026#34; class=\u0026#34;com.codingman.spring_batch_intro.model.Transaction\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemReader\u0026#34; class=\u0026#34;org.springframework.batch.item.file.FlatFileItemReader\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;input/record.csv\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;lineMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.batch.item.file.mapping.DefaultLineMapper\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;lineTokenizer\u0026#34;\u0026gt; \u0026lt;bean class= \u0026#34;org.springframework.batch.item.file.transform.DelimitedLineTokenizer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;names\u0026#34; value=\u0026#34;username,userid,transactiondate,amount\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;fieldSetMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.codingman.spring_batch_intro.service.RecordFieldSetMapper\u0026#34; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemProcessor\u0026#34; class=\u0026#34;com.codingman.spring_batch_intro.service.CustomItemProcessor\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;itemWriter\u0026#34; class=\u0026#34;org.springframework.batch.item.xml.StaxEventItemWriter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;file:xml/output.xml\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;marshaller\u0026#34; ref=\u0026#34;recordMarshaller\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;rootTagName\u0026#34; value=\u0026#34;transactionRecord\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;recordMarshaller\u0026#34; class=\u0026#34;org.springframework.oxm.jaxb.Jaxb2Marshaller\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;classesToBeBound\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;com.codingman.spring_batch_intro.model.Transaction\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;batch:job id=\u0026#34;firstBatchJob\u0026#34;\u0026gt; \u0026lt;batch:step id=\u0026#34;step1\u0026#34;\u0026gt; \u0026lt;batch:tasklet\u0026gt; \u0026lt;batch:chunk reader=\u0026#34;itemReader\u0026#34; writer=\u0026#34;itemWriter\u0026#34; processor=\u0026#34;itemProcessor\u0026#34; commit-interval=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;/batch:chunk\u0026gt; \u0026lt;/batch:tasklet\u0026gt; \u0026lt;/batch:step\u0026gt; \u0026lt;/batch:job\u0026gt; 这是类似的基于 Java 的作业配置： public class SpringBatchConfig { @Autowired private JobBuilderFactory jobs; @Autowired private StepBuilderFactory steps; @Value(\u0026#34;input/record.csv\u0026#34;) private Resource inputCsv; @Value(\u0026#34;file:xml/output.xml\u0026#34;) private Resource outputXml; @Bean public ItemReader\u0026lt;Transaction\u0026gt; itemReader() throws UnexpectedInputException, ParseException { FlatFileItemReader\u0026lt;Transaction\u0026gt; reader = new FlatFileItemReader\u0026lt;Transaction\u0026gt;(); DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer(); String[] tokens = { \u0026#34;username\u0026#34;, \u0026#34;userid\u0026#34;, \u0026#34;transactiondate\u0026#34;, \u0026#34;amount\u0026#34; }; tokenizer.setNames(tokens); reader.setResource(inputCsv); DefaultLineMapper\u0026lt;Transaction\u0026gt; lineMapper = new DefaultLineMapper\u0026lt;Transaction\u0026gt;(); lineMapper.setLineTokenizer(tokenizer); lineMapper.setFieldSetMapper(new RecordFieldSetMapper()); reader.setLineMapper(lineMapper); return reader; } @Bean public ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; itemProcessor() { return new CustomItemProcessor(); } @Bean public ItemWriter\u0026lt;Transaction\u0026gt; itemWriter(Marshaller marshaller) throws MalformedURLException { StaxEventItemWriter\u0026lt;Transaction\u0026gt; itemWriter = new StaxEventItemWriter\u0026lt;Transaction\u0026gt;(); itemWriter.setMarshaller(marshaller); itemWriter.setRootTagName(\u0026#34;transactionRecord\u0026#34;); itemWriter.setResource(outputXml); return itemWriter; } @Bean public Marshaller marshaller() { Jaxb2Marshaller marshaller = new Jaxb2Marshaller(); marshaller.setClassesToBeBound(new Class[] { Transaction.class }); return marshaller; } @Bean protected Step step1(ItemReader\u0026lt;Transaction\u0026gt; reader, ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; processor, ItemWriter\u0026lt;Transaction\u0026gt; writer) { return steps.get(\u0026#34;step1\u0026#34;).\u0026lt;Transaction, Transaction\u0026gt; chunk(10) .reader(reader).processor(processor).writer(writer).build(); } @Bean(name = \u0026#34;firstBatchJob\u0026#34;) public Job job(@Qualifier(\u0026#34;step1\u0026#34;) Step step1) { return jobs.get(\u0026#34;firstBatchJob\u0026#34;).start(step1).build(); } } 现在我们有了整个配置，让我们分解它并开始讨论它。 5.1 使用ItemReader读取数据并创建对象 首先，我们配置了cvsFileItemReader ，它将从record.csv中读取数据并将其转换为Transaction对象： @SuppressWarnings(\u0026#34;restriction\u0026#34;) @XmlRootElement(name = \u0026#34;transactionRecord\u0026#34;) public class Transaction { private String username; private int userId; private LocalDateTime transactionDate; private double amount; /* getters and setters for the attributes */ @Override public String toString() { return \u0026#34;Transaction [username=\u0026#34; + username + \u0026#34;, userId=\u0026#34; + userId + \u0026#34;, transactionDate=\u0026#34; + transactionDate + \u0026#34;, amount=\u0026#34; + amount + \u0026#34;]\u0026#34;; } } 为此，它使用自定义映射器： public class RecordFieldSetMapper implements FieldSetMapper\u0026lt;Transaction\u0026gt; { public Transaction mapFieldSet(FieldSet fieldSet) throws BindException { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;d/M/yyy\u0026#34;); Transaction transaction = new Transaction(); transaction.setUsername(fieldSet.readString(\u0026#34;username\u0026#34;)); transaction.setUserId(fieldSet.readInt(1)); transaction.setAmount(fieldSet.readDouble(3)); String dateString = fieldSet.readString(2); transaction.setTransactionDate(LocalDate.parse(dateString, formatter).atStartOfDay()); return transaction; } } 5.2 使用ItemProcessor处理数据 我们创建了自己的项目处理器CustomItemProcessor。这不会处理与事务对象相关的任何内容。 它所做的只是将来自 reader 的原始对象传递给 writer： public class CustomItemProcessor implements ItemProcessor\u0026lt;Transaction, Transaction\u0026gt; { public Transaction process(Transaction item) { return item; } } 5.3 使用ItemWriter将对象写入 FS 最后，我们将此事务存储到位于xml/output.xml的 XML 文件中： \u0026lt;bean id=\u0026#34;itemWriter\u0026#34; class=\u0026#34;org.springframework.batch.item.xml.StaxEventItemWriter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;resource\u0026#34; value=\u0026#34;file:xml/output.xml\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;marshaller\u0026#34; ref=\u0026#34;recordMarshaller\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;rootTagName\u0026#34; value=\u0026#34;transactionRecord\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 5.4 配置批处理作业 因此，我们所要做的就是使用batch:job语法将这些点与作业连接起来。 注意提交间隔。这是在将批次提交给itemWriter之前要保存在内存中的事务数。 它将在内存中保存事务直到该点（或直到遇到输入数据的结尾）： \u0026lt;batch:job id=\u0026#34;firstBatchJob\u0026#34;\u0026gt; \u0026lt;batch:step id=\u0026#34;step1\u0026#34;\u0026gt; \u0026lt;batch:tasklet\u0026gt; \u0026lt;batch:chunk reader=\u0026#34;itemReader\u0026#34; writer=\u0026#34;itemWriter\u0026#34; processor=\u0026#34;itemProcessor\u0026#34; commit-interval=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;/batch:chunk\u0026gt; \u0026lt;/batch:tasklet\u0026gt; \u0026lt;/batch:step\u0026gt; \u0026lt;/batch:job\u0026gt; 5.5 运行批处理作业 现在让我们设置并运行所有内容： public class App { public static void main(String[] args) { // Spring Java config  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(SpringConfig.class); context.register(SpringBatchConfig.class); context.refresh(); JobLauncher jobLauncher = (JobLauncher) context.getBean(\u0026#34;jobLauncher\u0026#34;); Job job = (Job) context.getBean(\u0026#34;firstBatchJob\u0026#34;); System.out.println(\u0026#34;Starting the batch job\u0026#34;); try { JobExecution execution = jobLauncher.run(job, new JobParameters()); System.out.println(\u0026#34;Job Status : \u0026#34; + execution.getStatus()); System.out.println(\u0026#34;Job completed\u0026#34;); } catch (Exception e) { e.printStackTrace(); System.out.println(\u0026#34;Job failed\u0026#34;); } } } ","permalink":"http://itcodingman.github.io/introduction-to-spring-batch/","tags":["Spring Batch"],"title":"Spring Batch 简介"},{"categories":["REST","Spring"],"contents":"使用 Spring 的 REST 错误处理 1. 概述 本教程将说明**如何使用 Spring 为 REST API 实现异常处理。**我们还将获得一些历史概览，并查看不同版本引入了哪些新选项。 *在 Spring 3.2 之前，在 Spring MVC 应用程序中处理异常的两种主要方法是HandlerExceptionResolver或@ExceptionHandler*注解。**两者都有一些明显的缺点。 从 3.2 开始，我们有了@ControllerAdvice*注解*来解决前两个解决方案的局限性，并在整个应用程序中促进统一的异常处理。 现在Spring 5 引入了ResponseStatusException 类——一种在我们的 REST API 中进行基本错误处理的快速方法。 所有这些都有一个共同点：它们很好地处理了**关注点的分离。**该应用程序可以正常抛出异常以指示某种失败，然后将单独处理。 最后，我们将看到 Spring Boot 带来了什么，以及我们如何配置它以满足我们的需求。 2.方案一：Controller级@ExceptionHandler 第一个解决方案适用于*@Controller级别。我们将定义一个方法来处理异常并使用@ExceptionHandler* 对其进行注释： public class FooController{ //...  @ExceptionHandler({ CustomException1.class, CustomException2.class }) public void handleException() { //  } } 这种方法有一个主要缺点：**@ExceptionHandler注释方法仅对特定的 Controller 有效，**而不是对整个应用程序全局有效。当然，将它添加到每个控制器使其不太适合一般的异常处理机制。 我们可以通过让所有控制器扩展一个基本控制器类来解决这个限制。 然而，这种解决方案对于应用程序来说可能是个问题，无论出于何种原因，这是不可能的。例如，控制器可能已经从另一个基类扩展而来，该基类可能在另一个 jar 中或不可直接修改，或者它们本身可能不可直接修改。 接下来，我们将研究另一种解决异常处理问题的方法——一种全局的并且不包括对现有工件（例如控制器）的任何更改。 3. 解决方案2：HandlerExceptionResolver 第二种解决方案是定义一个HandlerExceptionResolver。这将解决应用程序抛出的任何异常。它还将允许我们在 REST API 中实现统一的异常处理机制。 在使用自定义解析器之前，让我们回顾一下现有的实现。 3.1 ExceptionHandlerExceptionResolver 这个解析器是在 Spring 3.1 中引入的，默认情况下在DispatcherServlet中启用。这实际上是前面介绍的*@ExceptionHandler*机制如何工作的核心组件。 3.2. DefaultHandlerExceptionResolver 这个解析器是在 Spring 3.0 中引入的，默认情况下它在DispatcherServlet中启用。 它用于解决相应的HTTP 状态代码的标准 Spring 异常，即客户端错误4xx和服务器错误5xx状态代码。这是它处理的 Spring 异常的完整列表以及它们如何映射到状态代码。 虽然它确实正确设置了响应的状态代码，但一个**限制是它没有为响应的正文设置任何内容。**对于 REST API——状态码实际上不足以呈现给客户端——响应也必须有一个主体，以允许应用程序提供有关失败的附加信息。 这可以通过ModelAndView配置视图分辨率和渲染错误内容来解决，但该解决方案显然不是最优的。这就是为什么 Spring 3.2 引入了一个更好的选项，我们将在后面的部分讨论。 3.3. ResponseStatusExceptionResolver 这个解析器也在 Spring 3.0 中引入，默认情况下在DispatcherServlet中启用。 它的主要职责是使用自定义异常上可用的*@ResponseStatus*注释并将这些异常映射到 HTTP 状态代码。 这样的自定义异常可能如下所示： @ResponseStatus(value = HttpStatus.NOT_FOUND) public class MyResourceNotFoundException extends RuntimeException { public MyResourceNotFoundException() { super(); } public MyResourceNotFoundException(String message, Throwable cause) { super(message, cause); } public MyResourceNotFoundException(String message) { super(message); } public MyResourceNotFoundException(Throwable cause) { super(cause); } } 与DefaultHandlerExceptionResolver相同，此解析器在处理响应主体的方式上受到限制——它确实将状态代码映射到响应上，但主体仍然为空。 3.4 自定义HandlerExceptionResolver DefaultHandlerExceptionResolver和ResponseStatusExceptionResolver的组合在为 Spring RESTful 服务提供良好的错误处理机制方面大有帮助。如前所述，缺点是无法控制响应的主体。 理想情况下，我们希望能够输出 JSON 或 XML，具体取决于客户端要求的格式（通过Accept标头）。 仅此一项就证明了创建一个新的自定义异常解析器是合理的： @Component public class RestResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver { @Override protected ModelAndView doResolveException( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { try { if (ex instanceof IllegalArgumentException) { return handleIllegalArgument( (IllegalArgumentException) ex, response, handler); } ... } catch (Exception handlerException) { logger.warn(\u0026#34;Handling of [\u0026#34; + ex.getClass().getName() + \u0026#34;] resulted in Exception\u0026#34;, handlerException); } return null; } private ModelAndView handleIllegalArgument(IllegalArgumentException ex, HttpServletResponse response) throws IOException { response.sendError(HttpServletResponse.SC_CONFLICT); String accept = request.getHeader(HttpHeaders.ACCEPT); ... return new ModelAndView(); } } 这里要注意的一个细节是我们可以访问请求本身，因此我们可以考虑客户端发送的Accept标头的值。 例如，如果客户端请求application/json，那么在出现错误情况的情况下，我们希望确保返回一个使用application/json编码的响应正文。 另一个重要的实现细节是我们返回一个 ModelAndView——这是响应的主体，它允许我们在上面设置任何必要的东西。 这种方法是一种一致且易于配置的机制，用于 Spring REST 服务的错误处理。 但是，它确实有局限性：它与低级HtttpServletResponse 交互并适合使用ModelAndView的旧 MVC 模型，因此仍有改进的空间。 4. 解决方案3：@ControllerAdvice Spring 3.2通过@ControllerAdvice注释支持全局@ExceptionHandler。 这启用了一种脱离旧 MVC 模型并利用ResponseEntity以及@ExceptionHandler的类型安全性和灵活性的机制： @ControllerAdvice public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(value = { IllegalArgumentException.class, IllegalStateException.class }) protected ResponseEntity\u0026lt;Object\u0026gt; handleConflict( RuntimeException ex, WebRequest request) { String bodyOfResponse = \u0026#34;This should be application specific\u0026#34;; return handleExceptionInternal(ex, bodyOfResponse, new HttpHeaders(), HttpStatus.CONFLICT, request); } } @ControllerAdvice注解允许我们将之前的多个分散的@ExceptionHandler整合到一个单一的全局错误处理组件中。 实际的机制非常简单，但也非常灵活：  它使我们可以完全控制响应的主体以及状态代码。 它提供了多个异常到同一方法的映射，以便一起处理。 它充分利用了较新的 RESTful ResposeEntity响应。  这里要记住的一件事是将使用@ExceptionHandler声明的异常与用作方法参数的异常相匹配。 如果这些不匹配，编译器不会抱怨——没有理由应该抱怨——Spring 也不会抱怨。 但是，当在运行时实际抛出异常时，异常解析机制将失败，并显示： java.lang.IllegalStateException: No suitable resolver for argument [0] [type=...] HandlerMethod details: ... 5. 解决方案4：ResponseStatusException（Spring 5及以上） Spring 5 引入了ResponseStatusException类。 我们可以创建它的一个实例，提供一个HttpStatus以及一个可选的reason和cause： @GetMapping(value = \u0026#34;/{id}\u0026#34;) public Foo findById(@PathVariable(\u0026#34;id\u0026#34;) Long id, HttpServletResponse response) { try { Foo resourceById = RestPreconditions.checkFound(service.findOne(id)); eventPublisher.publishEvent(new SingleResourceRetrievedEvent(this, response)); return resourceById; } catch (MyResourceNotFoundException exc) { throw new ResponseStatusException( HttpStatus.NOT_FOUND, \u0026#34;Foo Not Found\u0026#34;, exc); } } 使用ResponseStatusException有什么好处？  非常适合原型设计：我们可以非常快速地实施基本解决方案。 一种类型，多种状态码：一种异常类型可能导致多种不同的响应。与@ExceptionHandler相比，这减少了紧密耦合。 我们不必创建尽可能多的自定义异常类。 我们可以更好地控制异常处理，因为可以通过编程方式创建异常。  那么权衡呢？  没有统一的异常处理方式：与提供全局方法的@ControllerAdvice相比，执行一些应用程序范围的约定更加困难。 代码复制：我们可能会发现自己在多个控制器中复制代码。  我们还应该注意到，可以在一个应用程序中组合不同的方法。 例如，我们可以 全局 实现@ControllerAdvice ，也可以在本地实现ResponseStatusException 。 但是，我们需要小心：如果可以以多种方式处理同一个异常，我们可能会注意到一些令人惊讶的行为。一种可能的约定是始终以一种方式处理一种特定类型的异常。 有关更多详细信息和更多示例，请参阅我们的ResponseStatusException教程。 6. 处理Spring Security中的访问被拒绝 当经过身份验证的用户尝试访问他没有足够权限访问的资源时，会发生访问被拒绝。 6.1 REST 和方法级安全性 最后，让我们看看如何处理由方法级安全注解（@PreAuthorize、@PostAuthorize和@Secure ）引发的 Access Denied 异常。 当然，我们也会使用前面讨论过的全局异常处理机制来处理AccessDeniedException： @ControllerAdvice public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler({ AccessDeniedException.class }) public ResponseEntity\u0026lt;Object\u0026gt; handleAccessDeniedException( Exception ex, WebRequest request) { return new ResponseEntity\u0026lt;Object\u0026gt;( \u0026#34;Access denied message here\u0026#34;, new HttpHeaders(), HttpStatus.FORBIDDEN); } ... } 7. Spring Boot 支持 Spring Boot 提供了一个 ErrorController实现以合理的方式处理错误。 简而言之，它为浏览器提供后备错误页面（又名 Whitelabel 错误页面），并为 RESTful、非 HTML 请求提供 JSON 响应： { \u0026#34;timestamp\u0026#34;: \u0026#34;2019-01-17T16:12:45.977+0000\u0026#34;, \u0026#34;status\u0026#34;: 500, \u0026#34;error\u0026#34;: \u0026#34;Internal Server Error\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Error processing the request!\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/my-endpoint-with-exceptions\u0026#34; } 像往常一样，Spring Boot 允许使用属性配置这些功能：  server.error.whitelabel.enabled：可用于禁用 Whitelabel 错误页面并依赖 servlet 容器提供 HTML 错误消息 server.error.include-stacktrace：始终 具有值；在 HTML 和 JSON 默认响应中包含堆栈跟踪 server.error.include-message： 从 2.3 版本开始，Spring Boot 在响应中隐藏了message字段，以避免泄露敏感信息；我们可以使用这个属性和一个 always 值来启用它  除了这些属性之外，我们还可以为 /error 提供我们自己的视图解析器映射，覆盖 Whitelabel 页面。 我们还可以通过在上下文中包含一个ErrorAttributes bean 来自定义我们想要在响应中显示的属性 。我们可以扩展 Spring Boot 提供的 DefaultErrorAttributes类以使事情变得更简单： @Component public class MyCustomErrorAttributes extends DefaultErrorAttributes { @Override public Map\u0026lt;String, Object\u0026gt; getErrorAttributes( WebRequest webRequest, ErrorAttributeOptions options) { Map\u0026lt;String, Object\u0026gt; errorAttributes = super.getErrorAttributes(webRequest, options); errorAttributes.put(\u0026#34;locale\u0026#34;, webRequest.getLocale() .toString()); errorAttributes.remove(\u0026#34;error\u0026#34;); //...  return errorAttributes; } } 如果我们想进一步定义（或覆盖）应用程序将如何处理特定内容类型的错误，我们可以注册一个 ErrorController bean。 同样，我们可以利用 Spring Boot 提供的默认 BasicErrorController 来帮助我们。 例如，假设我们想要自定义我们的应用程序如何处理在 XML 端点中触发的错误。我们所要做的就是使用 @RequestMapping定义一个公共方法，并声明它产生application/xml媒体类型： @Component public class MyErrorController extends BasicErrorController { public MyErrorController( ErrorAttributes errorAttributes, ServerProperties serverProperties) { super(errorAttributes, serverProperties.getError()); } @RequestMapping(produces = MediaType.APPLICATION_XML_VALUE) public ResponseEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; xmlError(HttpServletRequest request) { // ...  } } 注意：这里我们仍然依赖于server.error.我们可能已经在项目中定义的引导属性，这些属性绑定到ServerProperties bean。 ","permalink":"http://itcodingman.github.io/exception-handling-for-rest-with-spring/","tags":[],"title":"使用 Spring 的 REST 错误处理"},{"categories":["Spring"],"contents":"Spring中的构造函数依赖注入 1. 简介 可以说，现代软件设计最重要的开发原则之一是*依赖注入 (DI)，*它很自然地源于另一个至关重要的原则：模块化。 这个快速教程将探讨 Spring 中一种特定类型的 DI 技术，称为基于构造函数的依赖注入， 简单地说，意味着我们在实例化时将所需的组件传递给一个类。 首先，我们需要在pom.xml中导入spring-context依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后我们需要设置一个配置文件。根据偏好，该文件可以是 POJO 或 XML 文件。 2. 基于注解的配置 Java 配置文件看起来类似于带有一些附加注释的 Java 对象： @Configuration @ComponentScan(\u0026#34;com.codingman.constructordi\u0026#34;) public class Config { @Bean public Engine engine() { return new Engine(\u0026#34;v8\u0026#34;, 5); } @Bean public Transmission transmission() { return new Transmission(\u0026#34;sliding\u0026#34;); } } 在这里，我们使用注解来通知 Spring 运行时这个类提供了 bean 定义（@Bean注解），并且包com.codingman.spring需要执行上下文扫描以查找其他 bean。接下来，我们定义一个Car类： @Component public class Car { @Autowired public Car(Engine engine, Transmission transmission) { this.engine = engine; this.transmission = transmission; } } Spring在进行包扫描时会遇到我们的Car类，并会通过调用@Autowired带注释的构造函数来初始化它的实例。 通过调用Config类的@Bean注解方法，我们将获得Engine 和 Transmission的实例。最后，我们需要使用我们的 POJO 配置来引导ApplicationContext： ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); Car car = context.getBean(Car.class); 3. 隐式构造函数注入 从 Spring 4.3 开始，具有单个构造函数的类可以省略@Autowired注释。这是一个很好的便利和样板删除。 最重要的是，同样从 4.3 开始，我们可以在@Configuration注释类中利用基于构造函数的注入。另外，如果这样的类只有一个构造函数，我们也可以省略@Autowired注解。 4. 基于 XML 的配置 使用基于构造函数的依赖注入配置 Spring 运行时的另一种方法是使用 XML 配置文件： \u0026lt;bean id=\u0026#34;toyota\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Car\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;engine\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; ref=\u0026#34;transmission\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;engine\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Engine\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;v4\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transmission\u0026#34; class=\u0026#34;com.codingman.constructordi.domain.Transmission\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;sliding\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 请注意，constructor-arg可以接受文字值或对另一个 bean 的引用，并且可以提供可选的显式索引和类型。我们可以使用Type和index属性来解决歧义（例如，如果构造函数采用相同类型的多个参数）。  name属性也可以用于 xml 到 java 变量的匹配，但是你的代码必须在编译时使用调试标志。  在这种情况下，我们需要使用ClassPathXmlApplicationContext引导我们的 Spring 应用程序上下文： ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;codingman.xml\u0026#34;); Car car = context.getBean(Car.class); 5. 优点和缺点 与字段注入相比，构造函数注入有一些优点。 第一个好处是可测试性。假设我们要对一个使用字段注入的 Spring bean 进行单元测试： public class UserService { @Autowired private UserRepository userRepository; } 在UserService 实例的构建过程中，我们无法初始化userRepository 状态。实现这一点的唯一方法是通过完全打破封装的反射 API此外，与简单的构造函数调用相比，生成的代码将不太安全。 此外，使用字段注入，我们无法强制执行类级别的不变量，因此可能会在没有正确初始化userRepository的情况下拥有 UserService 实例。因此，我们可能会在这里和那里遇到随机 的NullPointerException 。此外，使用构造函数注入，更容易构建不可变组件。 此外，从 OOP 的角度来看，使用构造函数创建对象实例更为自然。 另一方面，构造函数注入的主要缺点是其冗长，尤其是当 bean 具有少量依赖项时。有时这可能是因祸得福，因为我们可能会更加努力地将依赖项的数量保持在最低限度。 ","permalink":"http://itcodingman.github.io/constructor-injection-in-spring/","tags":["Spring Core Basics","Spring DI"],"title":"Spring中的构造函数依赖注入"},{"categories":["Spring"],"contents":"Spring 控制反转和依赖注入简介 1. 概述 在本教程中，我们将介绍 IoC（控制反转）和 DI（依赖注入）的概念，并了解它们在 Spring 框架中是如何实现的。 2. 什么是控制反转？ 控制反转是软件工程中的一项原则，它将对象或程序部分的控制转移到容器或框架中。我们最常在面向对象编程的上下文中使用它。 与我们的自定义代码调用库的传统编程相比，IoC 使框架能够控制程序的流程并调用我们的自定义代码。为了实现这一点，框架使用内置附加行为的抽象。如果我们想添加自己的行为，我们需要扩展框架的类或插入我们自己的类。 这种架构的优点是：  将任务的执行与其实现分离 更容易在不同的实现之间切换 程序的更大模块化 通过隔离组件或模拟其依赖关系并允许组件通过合约进行通信，从而更轻松地测试程序  我们可以通过各种机制来实现控制反转，例如：策略设计模式、服务定位器模式、工厂模式和依赖注入（DI）。 接下来我们将研究 DI。 3. 什么是依赖注入？ 依赖注入是我们可以用来实现 IoC 的一种模式，其中被反转的控制是设置对象的依赖关系。 将对象与其他对象连接起来，或将对象“注入”到其他对象中，是由汇编程序完成的，而不是由对象本身完成的。 以下是我们如何在传统编程中创建对象依赖项： public class Store { private Item item; public Store() { item = new ItemImpl1(); } } 在上面的示例中，我们需要在Store类本身中实例化Item接口的实现。 通过使用 DI，我们可以重写示例，而无需指定我们想要的Item的实现： public class Store { private Item item; public Store(Item item) { this.item = item; } } 在接下来的部分中，我们将了解如何通过元数据提供Item的实现。 IoC 和 DI 都是简单的概念，但它们对我们构建系统的方式有着深远的影响，因此它们非常值得充分理解。 4. Spring IoC 容器 IoC 容器是实现 IoC 的框架的共同特征。 在 Spring 框架中，接口 ApplicationContext代表 IoC 容器。Spring 容器负责实例化、配置和组装称为bean的对象，以及管理它们的生命周期。 Spring 框架提供了ApplicationContext接口的几种实现：ClassPathXmlApplicationContext和FileSystemXmlApplicationContext用于独立应用程序，WebApplicationContext用于 Web 应用程序。 为了组装 bean，容器使用配置元数据，它可以是 XML 配置或注解的形式。 这是手动实例化容器的一种方法： ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); 要在上面的示例中设置项目属性，我们可以使用元数据。然后容器将读取此元数据并在运行时使用它来组装 bean。 Spring 中的依赖注入可以通过构造函数、setter 或字段来完成。 5. 基于构造函数的依赖注入 在基于构造函数的依赖注入的情况下，容器将调用带有参数的构造函数，每个参数代表我们要设置的依赖项。 Spring 主要按类型解析每个参数，然后是属性名称，以及用于消歧的索引。让我们使用注解查看 bean 的配置及其依赖项： @Configuration public class AppConfig { @Bean public Item item1() { return new ItemImpl1(); } @Bean public Store store() { return new Store(item1()); } } @Configuration注解表明该类是 bean 定义的来源。我们还可以将它添加到多个配置类中。 我们在方法上使用*@Bean*注解来定义一个 bean。如果我们不指定自定义名称，那么 bean 名称将默认为方法名称。 对于具有默认单例范围的 bean，Spring 首先检查 bean 的缓存实例是否已经存在，如果不存在则只创建一个新实例。如果我们使用原型作用域，容器会为每个方法调用返回一个新的 bean 实例。 创建 bean 配置的另一种方法是通过 XML 配置： \u0026lt;bean id=\u0026#34;item1\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;ItemImpl1\u0026#34; index=\u0026#34;0\u0026#34; name=\u0026#34;item\u0026#34; ref=\u0026#34;item1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 6. 基于 Setter 的依赖注入 对于基于 setter 的 DI，容器会在调用无参数构造函数或无参数静态工厂方法实例化 bean 后调用我们类的 setter 方法。让我们使用注解创建这个配置： @Bean public Store store() { Store store = new Store(); store.setItem(item1()); return store; } 我们还可以将 XML 用于相同的 bean 配置： \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;item\u0026#34; ref=\u0026#34;item1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 我们可以为同一个 bean 组合基于构造函数和基于 setter 的注入类型。Spring 文档建议对强制依赖项使用基于构造函数的注入，对可选依赖项使用基于 setter 的注入。 7. 基于字段的依赖注入 对于基于字段的 DI，我们可以通过使用*@Autowired*注释标记依赖项来注入依赖项： public class Store { @Autowired private Item item; } 在构造Store对象时，如果没有构造函数或 setter 方法来注入Item bean，容器将使用反射将Item注入Store。 我们也可以使用XML 配置来实现这一点。 这种方法可能看起来更简单、更干净，但我们不建议使用它，因为它有一些缺点，例如：  该方法使用反射来注入依赖项，这比基于构造函数或基于 setter 的注入成本更高。 使用这种方法继续添加多个依赖项真的很容易。如果我们使用构造函数注入，具有多个参数会让我们认为该类做了不止一件事，这可能违反单一职责原则。  更多关于*@Autowired*注解的信息可以在Wiring In Spring文章中找到。 8. 自动装配依赖 Wiring允许 Spring 容器通过检查已定义的 bean 来自动解决协作 bean 之间的依赖关系。 使用 XML 配置自动装配 bean 有四种模式：  no：默认值——这意味着 bean 不使用自动装配，我们必须显式命名依赖项。 byName：自动装配是基于属性的名称完成的，因此 Spring 将查找与需要设置的属性名称相同的 bean。 byType：类似于byName自动装配，仅基于属性的类型。这意味着 Spring 将寻找具有相同类型属性的 bean 来设置。如果该类型的 bean 不止一个，框架会抛出异常。 constructor：自动装配是基于构造函数参数完成的，这意味着 Spring 将寻找与构造函数参数具有相同类型的 bean。  例如，让我们将上面定义的item1 bean 按类型自动装配到store bean 中： @Bean(autowire = Autowire.BY_TYPE) public class Store { private Item item; public setItem(Item item){ this.item = item; } } 我们还可以使用*@Autowired*注解注入 bean，以便按类型自动装配： public class Store { @Autowired private Item item; } 如果有多个相同类型的 bean，我们可以使用*@Qualifier*注解按名称引用一个 bean： public class Store { @Autowired @Qualifier(\u0026#34;item1\u0026#34;) private Item item; } 现在让我们通过 XML 配置按类型自动装配 bean： \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 接下来，让我们通过 XML将一个名为item的 bean 按名称注入到store bean 的**item属性中： \u0026lt;bean id=\u0026#34;item\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;store\u0026#34; class=\u0026#34;com.codingman.store.Store\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 我们还可以通过构造函数参数或设置器显式定义依赖项来覆盖自动装配。 9. 延迟初始化 Bean 默认情况下，容器在初始化期间创建和配置所有单例 bean。为了避免这种情况，我们可以在 bean 配置中使用值为true的延迟初始化属性： \u0026lt;bean id=\u0026#34;item1\u0026#34; class=\u0026#34;com.codingman.store.ItemImpl1\u0026#34; lazy-init=\u0026#34;true\u0026#34; /\u0026gt; 因此，item1 bean 只会在第一次被请求时被初始化，而不是在启动时被初始化。这样做的好处是更快的初始化时间，但代价是在请求 bean 之前我们不会发现任何配置错误，这可能是应用程序已经运行后的几个小时甚至几天。 ","permalink":"http://itcodingman.github.io/inversion-control-and-dependency-injection-in-spring/","tags":["Spring Core Basics","Spring DI"],"title":"Spring 控制反转和依赖注入简介"},{"categories":["Spring Security","REST"],"contents":"使用 Spring Security 的 REST 服务的基本和摘要式身份验证 1. 概述 本文讨论如何在REST API 的相同 URI 结构上设置基本身份验证和摘要式身份验证。在之前的文章中，我们讨论了另一种保护 REST 服务的方法——基于表单的身份验证，因此基本和摘要式身份验证是自然的选择，也是更 RESTful 的一种。 2. 基本认证的配置 基于表单的身份验证不适合 RESTful 服务的主要原因是 Spring Security 将使用 Sessions——这当然是服务器上的状态，因此REST 中的无状态约束实际上被忽略了。 我们将从设置基本身份验证开始——首先我们从主**安全元素中删除旧的自定义入口点和过滤器： \u0026lt;http create-session=\u0026#34;stateless\u0026#34;\u0026gt; \u0026lt;intercept-url pattern=\u0026#34;/api/admin/**\u0026#34; access=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;http-basic /\u0026gt; \u0026lt;/http\u0026gt; 请注意如何使用单个配置行添加对基本身份验证的支持 -  - 它处理BasicAuthenticationFilter和BasicAuthenticationEntryPoint的创建和连接。 2.1 满足无状态约束——摆脱会话 RESTful 架构风格的主要限制之一是客户端-服务器通信是完全无状态的，正如原始论文所述：  5.1.3 无状态 我们接下来为客户端-服务器交互添加一个约束：通信本质上必须是无状态的，如第 3.4.3 节（图 5-3）中的客户端-无状态-服务器（CSS）样式，这样从客户端到的每个请求服务器必须包含理解请求所需的所有信息，并且不能利用服务器上存储的任何上下文。因此，会话状态完全保留在客户端上。  服务端Session的概念在 Spring Security 中是一个由来已久的概念，直到现在完全移除它一直很困难，尤其是在使用命名空间进行配置的情况下。 然而，Spring Security为命名空间配置增加了一个用于创建会话的新无状态选项，这有效地保证了 Spring 不会创建或使用任何会话。这个新选项的作用是完全从安全过滤器链中删除所有与会话相关的过滤器，确保为每个请求执行身份验证。 3. 摘要认证的配置 从前面的配置开始，设置摘要认证所需的过滤器和入口点将被定义为 bean。然后，摘要入口点将覆盖由\u0026lt;http-basic\u0026gt;在幕后创建的入口点。最后，自定义摘要过滤器将被引入安全过滤器链中，使用安全命名空间的after语义将其直接定位在基本身份验证过滤器之后。 \u0026lt;http create-session=\u0026#34;stateless\u0026#34; entry-point-ref=\u0026#34;digestEntryPoint\u0026#34;\u0026gt; \u0026lt;intercept-url pattern=\u0026#34;/api/admin/**\u0026#34; access=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;http-basic /\u0026gt; \u0026lt;custom-filter ref=\u0026#34;digestFilter\u0026#34; after=\u0026#34;BASIC_AUTH_FILTER\u0026#34; /\u0026gt; \u0026lt;/http\u0026gt; \u0026lt;beans:bean id=\u0026#34;digestFilter\u0026#34; class= \u0026#34;org.springframework.security.web.authentication.www.DigestAuthenticationFilter\u0026#34;\u0026gt; \u0026lt;beans:property name=\u0026#34;userDetailsService\u0026#34; ref=\u0026#34;userService\u0026#34; /\u0026gt; \u0026lt;beans:property name=\u0026#34;authenticationEntryPoint\u0026#34; ref=\u0026#34;digestEntryPoint\u0026#34; /\u0026gt; \u0026lt;/beans:bean\u0026gt; \u0026lt;beans:bean id=\u0026#34;digestEntryPoint\u0026#34; class= \u0026#34;org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint\u0026#34;\u0026gt; \u0026lt;beans:property name=\u0026#34;realmName\u0026#34; value=\u0026#34;Contacts Realm via Digest Authentication\u0026#34;/\u0026gt; \u0026lt;beans:property name=\u0026#34;key\u0026#34; value=\u0026#34;acegi\u0026#34; /\u0026gt; \u0026lt;/beans:bean\u0026gt; \u0026lt;authentication-manager\u0026gt; \u0026lt;authentication-provider\u0026gt; \u0026lt;user-service id=\u0026#34;userService\u0026#34;\u0026gt; \u0026lt;user name=\u0026#34;eparaschiv\u0026#34; password=\u0026#34;eparaschiv\u0026#34; authorities=\u0026#34;ROLE_ADMIN\u0026#34; /\u0026gt; \u0026lt;user name=\u0026#34;user\u0026#34; password=\u0026#34;user\u0026#34; authorities=\u0026#34;ROLE_USER\u0026#34; /\u0026gt; \u0026lt;/user-service\u0026gt; \u0026lt;/authentication-provider\u0026gt; \u0026lt;/authentication-manager\u0026gt; 不幸的是，安全命名空间中不支持自动配置摘要式身份验证，就像可以使用\u0026lt;http-basic\u0026gt;配置基本身份验证一样。因此，必须手动定义必要的 bean 并将其连接到安全配置中。 4. 在同一个Restful服务中同时支持两种认证协议 单独的 Basic 或 Digest 身份验证可以在 Spring Security 中轻松实现；它在相同的 URI 映射上为相同的 RESTful Web 服务支持它们，这为服务的配置和测试引入了新的复杂性。 4.1 匿名请求 使用安全链中的基本过滤器和摘要过滤器，Spring Security 处理匿名请求（不包含身份验证凭据（授权HTTP 标头）的请求）的方式是，两个身份验证过滤器将找不到凭据并继续执行过滤链。然后，查看请求是如何未经过身份验证的，会抛出AccessDeniedException并在ExceptionTranslationFilter中捕获，它会启动摘要入口点，提示客户端输入凭据。 基本过滤器和摘要过滤器的职责都非常狭窄——如果它们无法识别请求中身份验证凭据的类型，它们将继续执行安全过滤器链。正因为如此，Spring Security 可以灵活地配置为支持同一 URI 上的多个身份验证协议。 当请求包含正确的身份验证凭据（基本或摘要）时，将正确使用该协议。但是，对于匿名请求，客户端只会收到摘要式身份验证凭据的提示。这是因为摘要入口点被配置为 Spring Security 链的主要和单一入口点；因此可以将摘要身份验证视为默认设置。 4.2 带有身份验证凭据的请求 带有 Basic 身份验证凭据的请求将由Authorization标头标识，该标头以前缀Basic开头。处理此类请求时，凭据将在基本身份验证过滤器中解码，并且请求将被授权。同样，带有摘要身份验证凭据的请求将使用前缀摘要作为其授权标头。 5. 测试两种场景 在使用基本或摘要进行身份验证后，测试将通过创建新资源来使用 REST 服务： @Test public void givenAuthenticatedByBasicAuth_whenAResourceIsCreated_then201IsReceived(){ // Given  // When  Response response = given() .auth().preemptive().basic( ADMIN_USERNAME, ADMIN_PASSWORD ) .contentType( HttpConstants.MIME_JSON ).body( new Foo( randomAlphabetic( 6 ) ) ) .post( paths.getFooURL() ); // Then  assertThat( response.getStatusCode(), is( 201 ) ); } @Test public void givenAuthenticatedByDigestAuth_whenAResourceIsCreated_then201IsReceived(){ // Given  // When  Response response = given() .auth().digest( ADMIN_USERNAME, ADMIN_PASSWORD ) .contentType( HttpConstants.MIME_JSON ).body( new Foo( randomAlphabetic( 6 ) ) ) .post( paths.getFooURL() ); // Then  assertThat( response.getStatusCode(), is( 201 ) ); } 请注意，使用基本身份验证的测试会抢先将凭据添加到请求中，无论服务器是否已对身份验证提出质疑。这是为了确保服务器不需要向客户端质询凭据，因为如果需要，质询将针对 Digest 凭据，因为这是默认设置。 ","permalink":"http://itcodingman.github.io/basic-and-digest-authentication-for-a-rest-api-with-spring-security/","tags":["Authentication"],"title":"使用 Spring Security 的 REST 服务的基本和摘要式身份验证"},{"categories":["Python","BiliBili"],"contents":"conda的安装和使用、国内源、常用命令 conda的安装和使用、国内源、常用命令 \r","permalink":"http://itcodingman.github.io/conda_install_introduce/","tags":[],"title":"conda的安装和使用、国内源、常用命令"},{"categories":["Python","Youtube"],"contents":"扫雷——pygame项目实战   ","permalink":"http://itcodingman.github.io/pygame_minesweeper/","tags":[],"title":"扫雷——pygame项目实战"},{"categories":["Spring","REST"],"contents":"Spring中的REST分页 1. 概述 本教程将重点介绍使用 Spring MVC 和 Spring Data 在 REST API 中实现分页。 2. 页面作为资源与页面作为表示 在 RESTful 架构的上下文中设计分页时的第一个问题是，是否将页面视为实际资源或只是资源的表示。 将页面本身视为资源会带来许多问题，例如不再能够在调用之间唯一标识资源。这一点，再加上在持久层中，页面不是一个适当的实体，而是一个在必要时构建的持有者，这使得选择变得简单；页面是表示的一部分。 REST 上下文中分页设计的下一个问题是在哪里包含分页信息：  在 URI 路径中：/foo/page/1 URI 查询：/foo?page=1  请记住，页面不是 Resource，因此无法在 URI 中对页面信息进行编码。 我们将使用标准方法通过在 URI 查询中编码分页信息来解决这个问题。 3. 控制器 现在进行实施用于分页的 Spring MVC 控制器很简单： @GetMapping(params = { \u0026#34;page\u0026#34;, \u0026#34;size\u0026#34; }) public List\u0026lt;Foo\u0026gt; findPaginated(@RequestParam(\u0026#34;page\u0026#34;) int page, @RequestParam(\u0026#34;size\u0026#34;) int size, UriComponentsBuilder uriBuilder, HttpServletResponse response) { Page\u0026lt;Foo\u0026gt; resultPage = service.findPaginated(page, size); if (page \u0026gt; resultPage.getTotalPages()) { throw new MyResourceNotFoundException(); } eventPublisher.publishEvent(new PaginatedResultsRetrievedEvent\u0026lt;Foo\u0026gt;( Foo.class, uriBuilder, response, page, resultPage.getTotalPages(), size)); return resultPage.getContent(); } 在此示例中，我们 通过@RequestParam在 Controller 方法中注入两个查询参数size和page。 或者，我们可以使用Pageable对象，它自动映射page、 size和sort参数。此外，PagingAndSortingRepository实体提供了开箱即用的方法，支持使用Pageable作为参数。 我们还注入了 Http Response 和UriComponentsBuilder来帮助实现可发现性，我们通过自定义事件将其解耦。如果这不是 API 的目标，我们可以简单地删除自定义事件。 最后，注意本文的重点只是REST和web层；要深入了解分页的数据访问部分，我们可以查看这篇关于使用 Spring Data 进行分页的文章。 4. REST 分页的可发现性 在分页范围内，满足REST 的 HATEOAS 约束意味着 API 的客户端能够根据导航中的当前页面发现下一页和上一页。为此，我们将使用Link HTTP 标头，以及“下一个”、 “上一个”、“第一个”和“最后一个”链接关系类型。 在 REST 中，可发现性是一个横切关注点，不仅适用于特定操作，还适用于操作类型。例如，每次创建资源时，客户端应该可以发现该资源的 URI。由于此要求与 ANY Resource 的创建相关，因此我们将单独处理它。 正如我们在上一篇文章中讨论的那样，我们将使用事件来解耦这些关注点，重点是 REST 服务的可发现性。在分页的情况下，事件PaginatedResultsRetrievedEvent在控制器层中触发。然后，我们将使用此事件的自定义侦听器实现可发现性。 简而言之，监听器将检查导航是否允许下一页、 上一页、 第一页 和 最后一页。如果是这样，它会将相关的 URI 作为“链接”HTTP Header 添加到响应中。 现在让我们一步一步来。从控制器传递的UriComponentsBuilder仅包含基本 URL（主机、端口和上下文路径）。因此，我们必须添加其余部分： void addLinkHeaderOnPagedResourceRetrieval( UriComponentsBuilder uriBuilder, HttpServletResponse response, Class clazz, int page, int totalPages, int size ){ String resourceName = clazz.getSimpleName().toString().toLowerCase(); uriBuilder.path( \u0026#34;/admin/\u0026#34; + resourceName ); // ...  } 接下来，我们将使用StringJoiner 连接每个链接。我们将使用uriBuilder来生成 URI。让我们看看我们如何处理到下一页的链接： StringJoiner linkHeader = new StringJoiner(\u0026#34;, \u0026#34;); if (hasNextPage(page, totalPages)){ String uriForNextPage = constructNextPageUri(uriBuilder, page, size); linkHeader.add(createLinkHeader(uriForNextPage, \u0026#34;next\u0026#34;)); } 我们看一下 constructNextPageUri方法的逻辑： String constructNextPageUri(UriComponentsBuilder uriBuilder, int page, int size) { return uriBuilder.replaceQueryParam(PAGE, page + 1) .replaceQueryParam(\u0026#34;size\u0026#34;, size) .build() .encode() .toUriString(); } 我们将对我们想要包含的其余 URI 进行类似的处理。 最后，我们将输出添加为响应标头： response.addHeader(\u0026#34;Link\u0026#34;, linkHeader.toString()); 请注意，为简洁起见，仅包含部分代码示例。 5. 分页 分页和可发现性的主要逻辑都包含在小型、集中的集成测试中。与上一篇文章一样，我们将使用 REST-assured 库来使用 REST 服务并验证结果。 这些是分页集成测试的一些示例： @Test public void whenResourcesAreRetrievedPaged_then200IsReceived(){ Response response = RestAssured.get(paths.getFooURL() + \u0026#34;?page=0\u0026amp;size=2\u0026#34;); assertThat(response.getStatusCode(), is(200)); } @Test public void whenPageOfResourcesAreRetrievedOutOfBounds_then404IsReceived(){ String url = getFooURL() + \u0026#34;?page=\u0026#34; + randomNumeric(5) + \u0026#34;\u0026amp;size=2\u0026#34;; Response response = RestAssured.get.get(url); assertThat(response.getStatusCode(), is(404)); } @Test public void givenResourcesExist_whenFirstPageIsRetrieved_thenPageContainsResources(){ createResource(); Response response = RestAssured.get(paths.getFooURL() + \u0026#34;?page=0\u0026amp;size=2\u0026#34;); assertFalse(response.body().as(List.class).isEmpty()); } 6. 分页可发现性 测试分页是否可以被客户发现是相对简单的，尽管有很多内容需要覆盖。 测试将关注当前页面在导航中的位置，以及应该从每个位置发现的不同 URI： @Test public void whenFirstPageOfResourcesAreRetrieved_thenSecondPageIsNext(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToNextPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;next\u0026#34;); assertEquals(getFooURL()+\u0026#34;?page=1\u0026amp;size=2\u0026#34;, uriToNextPage); } @Test public void whenFirstPageOfResourcesAreRetrieved_thenNoPreviousPage(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToPrevPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;prev\u0026#34;); assertNull(uriToPrevPage ); } @Test public void whenSecondPageOfResourcesAreRetrieved_thenFirstPageIsPrevious(){ Response response = RestAssured.get(getFooURL()+\u0026#34;?page=1\u0026amp;size=2\u0026#34;); String uriToPrevPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;prev\u0026#34;); assertEquals(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;, uriToPrevPage); } @Test public void whenLastPageOfResourcesIsRetrieved_thenNoNextPageIsDiscoverable(){ Response first = RestAssured.get(getFooURL()+\u0026#34;?page=0\u0026amp;size=2\u0026#34;); String uriToLastPage = extractURIByRel(first.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;last\u0026#34;); Response response = RestAssured.get(uriToLastPage); String uriToNextPage = extractURIByRel(response.getHeader(\u0026#34;Link\u0026#34;), \u0026#34;next\u0026#34;); assertNull(uriToNextPage); } 7. 获取所有资源 在分页和可发现性的同一主题上，必须做出选择，是允许客户端一次检索系统中的所有资源，还是客户端必须分页请求它们。 如果确定客户端无法通过单个请求检索所有资源，并且需要分页，那么有几个选项可用于响应以获取请求。一种选择是返回 404 ( Not Found ) 并使用Link标头使第一页可发现：  链接=http://localhost:8080/rest/api/admin/foo?page=0\u0026size=2; rel=”first”, http://localhost:8080/rest/api/admin/foo?page=103\u0026size=2; 相对=“最后”  另一种选择是将重定向 303 （请参阅其他）返回到第一页。更保守的方法是简单地为 GET 请求返回 405（不允许的方法）给客户端。 8. 带有Range HTTP 标头的 REST 分页 实现分页的一种相对不同的方式是使用HTTP Range标头、 Range、Content-Range、If-Range、Accept-Ranges和HTTP 状态代码、 206（部分内容）、413（请求实体太大）和416（请求的范围不可满足）。 这种方法的一种观点是，HTTP Range 扩展不用于分页，它们应该由服务器管理，而不是由应用程序管理。基于 HTTP Range 标头扩展实现分页在技术上是可行的，尽管不像本文中讨论的实现那样普遍。 9. Spring Data REST 分页 在 Spring Data 中，如果我们需要从完整的数据集中返回一些结果，我们可以使用任何Pageable存储库方法，因为它总是返回一个Page。将根据页码、页面大小和排序方向返回结果。 Spring Data REST自动识别page, size, sort等URL 参数。 要使用任何存储库的分页方法，我们需要扩展PagingAndSortingRepository： public interface SubjectRepository extends PagingAndSortingRepository\u0026lt;Subject, Long\u0026gt;{} 如果我们调用 http://localhost:8080/subjects， Spring 会自动通过 API添加page, size, sort参数建议： \u0026#34;_links\u0026#34; : { \u0026#34;self\u0026#34; : { \u0026#34;href\u0026#34; : \u0026#34;http://localhost:8080/subjects{?page,size,sort}\u0026#34;, \u0026#34;templated\u0026#34; : true } } 默认情况下，页面大小为 20，但我们可以通过调用类似http://localhost:8080/subjects?page=10 的方法来更改它。 如果我们想在我们自己的自定义存储库 API 中实现分页，我们需要传递一个额外的Pageable参数并确保 API 返回一个Page： @RestResource(path = \u0026#34;nameContains\u0026#34;) public Page\u0026lt;Subject\u0026gt; findByNameContaining(@Param(\u0026#34;name\u0026#34;) String name, Pageable p); 每当我们添加自定义 API 时，都会将/search端点添加到生成的链接中。因此，如果我们调用 http://localhost:8080/subjects/search，我们将看到一个支持分页的端点： \u0026#34;findByNameContaining\u0026#34; : { \u0026#34;href\u0026#34; : \u0026#34;http://localhost:8080/subjects/search/nameContains{?name,page,size,sort}\u0026#34;, \u0026#34;templated\u0026#34; : true } 所有实现 PagingAndSortingRepository的 API都会返回一个Page。如果我们需要从Page返回结果列表， Page的getContent() API提供了作为 Spring Data REST API 结果获取的记录列表。 10. 将List转换为Page 假设我们有一个Pageable对象作为输入，但是我们需要检索的信息包含在一个列表而不是PagingAndSortingRepository中。在这些情况下，我们可能需要将List转换为Page。 例如，假设我们有一个SOAP服务的结果列表： List\u0026lt;Foo\u0026gt; list = getListOfFooFromSoapService(); 我们需要访问发送给我们的Pageable对象指定的特定位置的列表。所以让我们定义开始索引： int start = (int) pageable.getOffset(); 和结束索引： int end = (int) ((start + pageable.getPageSize()) \u0026gt; fooList.size() ? fooList.size() : (start + pageable.getPageSize())); 有了这两个，我们可以创建一个Page来获取它们之间的元素列表： Page\u0026lt;Foo\u0026gt; page = new PageImpl\u0026lt;Foo\u0026gt;(fooList.subList(start, end), pageable, fooList.size()); 而已！我们现在可以将page作为有效结果返回。 请注意，如果我们还想支持排序，我们需要在子列表之前对列表进行排序。 ","permalink":"http://itcodingman.github.io/rest-api-pagination-in-spring/","tags":["Pagination"],"title":"Spring中的REST分页"},{"categories":["Spring","REST"],"contents":"使用 Spring 5 创建 Web 应用程序 1. 概述 本教程说明了如何使用 Spring 创建 Web 应用程序。 我们将研究用于构建应用程序的 Spring Boot 解决方案，并查看非 Spring Boot 方法。 我们将主要使用 Java 配置，但也会看看它们等效的 XML 配置。 2. 使用 Spring Boot 进行设置 2.1 Maven 依赖 首先，我们需要spring-boot-starter-web 依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 该启动器包括：  spring-web和 Spring Web 应用程序所需的spring-webmvc模块 一个 Tomcat 启动器，这样我们就可以直接运行我们的 Web 应用程序，而无需显式安装任何服务器  2.2. 创建一个 Spring Boot 应用程序 开始使用 Spring Boot 最直接的方法是创建一个主类并使用 @SpringBootApplication对其进行注释： @SpringBootApplication public class SpringBootRestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootRestApplication.class, args); } } 此单个注解等效于使用@Configuration、@EnableAutoConfiguration和@ComponentScan。 默认情况下，它将扫描同一包或以下的所有组件。 接下来，对于 Spring beans 的基于 Java 的配置，我们需要创建一个配置类并使用@Configuration注解对其进行注解： @Configuration public class WebConfig { } 这个注解是基于 Java 的 Spring 配置使用的主要工件；它本身使用@Component进行元注释，这使得带注释的类成为标准 bean，因此也是组件扫描的候选对象。 @Configuration类的主要目的是作为 Spring IoC 容器的 bean 定义的来源。更详细的描述请参见官方文档。 让我们也看看使用核心spring-webmvc库的解决方案。 3. 使用 spring-webmvc 进行设置 3.1 Maven 依赖项 首先，我们需要spring-webmvc依赖： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3.2 基于 Java 的 Web 配置 接下来，我们将添加具有@Configuration注解的配置类： @Configuration @EnableWebMvc @ComponentScan(basePackages = \u0026#34;com.codingman.controller\u0026#34;) public class WebConfig { } 在这里，与 Spring Boot 解决方案不同，我们必须显式定义@EnableWebMvc以设置默认 Spring MVC 配置和@ComponentScan以指定要扫描组件的包。 @EnableWebMvc注解提供Spring Web MVC配置，例如设置调度程序 servlet、启用@Controller和@RequestMapping注解以及设置其他默认值。 @ComponentScan配置组件扫描指令，指定要扫描的包。 3.3 初始化器类 接下来，我们需要添加一个实现 WebApplicationInitializer接口的类： public class AppInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext container) throws ServletException { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.scan(\u0026#34;com.codingman\u0026#34;); container.addListener(new ContextLoaderListener(context)); ServletRegistration.Dynamic dispatcher = container.addServlet(\u0026#34;mvc\u0026#34;, new DispatcherServlet(context)); dispatcher.setLoadOnStartup(1); dispatcher.addMapping(\u0026#34;/\u0026#34;); } } 在这里，我们使用 AnnotationConfigWebApplicationContext类创建一个 Spring 上下文，这意味着我们只使用基于注释的配置。然后，我们指定要扫描组件和配置类的包。 最后，我们定义了 Web 应用程序的入口点——DispatcherServlet。 此类可以完全替换Servlet 3.0版本的web.xml文件。 4. XML 配置 让我们快速看一下等效的 XML Web 配置： \u0026lt;context:component-scan base-package=\u0026#34;com.codingman.controller\u0026#34; /\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; 我们可以用上面的WebConfig类替换这个 XML 文件。 要启动应用程序，我们可以使用加载 XML 配置或 web.xml 文件的 Initializer 类。有关这两种方法的更多详细信息，请查看之前的文章。 ","permalink":"http://itcodingman.github.io/bootstraping-a-web-application-with-spring-and-java-based-configuration/","tags":["Spring 5"],"title":"使用 Spring 5 创建 Web 应用程序"},{"categories":["Spring Persistence"],"contents":"使用 Spring 引导 Hibernate 5 1. 概述 在本文中，我们将讨论如何使用 Spring 引导 Hibernate 5，同时使用 Java 和 XML 配置。 文章 Spring Boot with Hibernate 描述了如何在 Spring Boot 中使用 Hibernate。 2. Spring集成 使用本机 Hibernate API引导SessionFactory有点复杂，需要我们编写好几行代码（请查看官方文档）。 幸运的是，Spring支持引导SessionFactory因此我们只需要几行 Java 代码或 XML 配置。 3. Maven依赖 让我们首先将必要的依赖项添加到我们的pom.xml中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.2.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring-orm 模块提供了 Spring 与 Hibernate 的集成： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-orm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为简单起见，我们将使用H2作为我们的数据库： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.197\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 最后，我们将使用Tomcat JDBC 连接池，它比Spring 提供的DriverManagerDataSource更适合生产目的： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-dbcp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4.配置 如前所述，Spring 支持我们引导 Hibernate SessionFactory。 我们所要做的就是定义一些 bean 以及一些参数。 使用 Spring，我们为这些配置提供了两种选择，一种基于 Java 的方式，一种基于 XML 的方式。 4.1。使用 Java 配置 对于将 Hibernate 5 与 Spring 一起使用，自Hibernate 4以来几乎没有变化：我们必须使用包org.springframework.orm.hibernate5中的LocalSessionFactoryBean而不是org.springframework.orm.hibernate4。 与之前的 Hibernate 4 一样，我们必须为LocalSessionFactoryBean、DataSource和PlatformTransactionManager定义 bean ，以及一些 Hibernate 特定的属性。 让我们创建HibernateConfig类来使用 Spring 配置 Hibernate 5： @Configuration @EnableTransactionManagement public class HibernateConf { @Bean public LocalSessionFactoryBean sessionFactory() { LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); sessionFactory.setPackagesToScan( {\u0026#34;com.codingman.hibernate.bootstrap.model\u0026#34; }); sessionFactory.setHibernateProperties(hibernateProperties()); return sessionFactory; } @Bean public DataSource dataSource() { BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\u0026#34;org.h2.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:h2:mem:db;DB_CLOSE_DELAY=-1\u0026#34;); dataSource.setUsername(\u0026#34;sa\u0026#34;); dataSource.setPassword(\u0026#34;sa\u0026#34;); return dataSource; } @Bean public PlatformTransactionManager hibernateTransactionManager() { HibernateTransactionManager transactionManager = new HibernateTransactionManager(); transactionManager.setSessionFactory(sessionFactory().getObject()); return transactionManager; } private final Properties hibernateProperties() { Properties hibernateProperties = new Properties(); hibernateProperties.setProperty( \u0026#34;hibernate.hbm2ddl.auto\u0026#34;, \u0026#34;create-drop\u0026#34;); hibernateProperties.setProperty( \u0026#34;hibernate.dialect\u0026#34;, \u0026#34;org.hibernate.dialect.H2Dialect\u0026#34;); return hibernateProperties; } } 4.2. 使用 XML 配置 作为次要选项，我们还可以使用基于 XML 的配置来配置 Hibernate 5： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;sessionFactory\u0026#34; class=\u0026#34;org.springframework.orm.hibernate5.LocalSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;packagesToScan\u0026#34; value=\u0026#34;com.codingman.hibernate.bootstrap.model\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;hibernateProperties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.hbm2ddl.auto\u0026#34;\u0026gt; create-drop \u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.dialect\u0026#34;\u0026gt; org.hibernate.dialect.H2Dialect \u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;org.h2.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:h2:mem:db;DB_CLOSE_DELAY=-1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.orm.hibernate5.HibernateTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sessionFactory\u0026#34; ref=\u0026#34;sessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 正如我们很容易看到的那样，我们定义的 bean 和参数与前面基于 Java 的配置完全相同。 要将 XML 引导到 Spring 上下文中，如果应用程序配置了 Java 配置，我们可以使用一个简单的 Java 配置文件： @Configuration @EnableTransactionManagement @ImportResource({\u0026#34;classpath:hibernate5Configuration.xml\u0026#34;}) public class HibernateXMLConf { // } 或者，如果整体配置是纯 XML，我们可以简单地将 XML 文件提供给 Spring 上下文。 5. 用法 至此，Hibernate 5 完全配置了 Spring，我们可以在需要时直接注入原始的 Hibernate SessionFactory ： public abstract class BarHibernateDAO { @Autowired private SessionFactory sessionFactory; // ... } 6. 支持的数据库 不幸的是，Hibernate 项目并没有完全提供支持数据库的官方列表。 话虽如此，很容易看出是否支持特定的数据库类型，我们可以查看支持的方言列表。 ","permalink":"http://itcodingman.github.io/hibernate-5-spring/","tags":["Hibernate"],"title":"使用 Spring 引导 Hibernate 5"},{"categories":["Python","BiliBili"],"contents":"PIP安装和使用、国内源、常用命令 PIP安装和使用、国内源、常用命令 \r","permalink":"http://itcodingman.github.io/pip_install_introduce/","tags":[],"title":"PIP安装和使用、国内源、常用命令"},{"categories":["C++","Youtube"],"contents":"C++中地址和引用的区别   ","permalink":"http://itcodingman.github.io/c_plus_point_reference_diffrence/","tags":[],"title":"C++中地址和引用的区别"},{"categories":["Python","Youtube"],"contents":"10分钟学习PyScript   ","permalink":"http://itcodingman.github.io/10_mins_pyscript/","tags":[],"title":"10分钟学习PyScript"},{"categories":["Java","BiliBili"],"contents":"50分钟学习JSP JSP教程主要提供JSP基础知识以及部分常用的JSP进阶知识，大家在学习JSP之前，需要具备一定的HTML及Java基础。 \r","permalink":"http://itcodingman.github.io/50_mins_jsp/","tags":[],"title":"50分钟学习JSP"},{"categories":["Java","BiliBili"],"contents":"Eclipse、Tomcat和Java Web的安装、配置及开发 Eclipse、Tomcat和Java Web的安装、配置及开发 \r","permalink":"http://itcodingman.github.io/eclipse_tomcat_java_web_install_introduce/","tags":[],"title":"Eclipse、Tomcat和Java Web的安装、配置及开发"},{"categories":["Java","Youtube"],"contents":"20分钟学习Ant安装和使用   ","permalink":"http://itcodingman.github.io/20_mins_ant/","tags":[],"title":"20分钟学习Ant安装和使用"},{"categories":["Java","BiliBili"],"contents":"Eclipse和Java的安装 Eclipse和Java的安装 \r","permalink":"http://itcodingman.github.io/eclipse_java_install_introduce/","tags":[],"title":"Eclipse和Java的安装"},{"categories":["Java","Youtube"],"contents":"30分钟学习MyBatis通用CRUD Mapper   ","permalink":"http://itcodingman.github.io/30_mins_mybatis_generic_mapper/","tags":[],"title":"30分钟学习MyBatis通用CRUD Mapper"},{"categories":["Java","BiliBili"],"contents":"100分钟学习Java 这是一门针对初学者的完整课程，学习有关Java的所有知识。包括：语法、语句、字符串、操作符、函数、文件等 \r","permalink":"http://itcodingman.github.io/100_mins_java/","tags":[],"title":"100分钟学习Java"},{"categories":["Java","Spring","Youtube"],"contents":"15分钟学习MyBatis Generator   ","permalink":"http://itcodingman.github.io/15_mins_mybatis_generator/","tags":[],"title":"15分钟学习MyBatis Generator"},{"categories":["Java","BiliBili"],"contents":"Visual Studio Code Java 的安装及使用 VisualStudioCode和Java的安装及使用 \r","permalink":"http://itcodingman.github.io/vscode_java_install_introduce/","tags":[],"title":"Visual Studio Code Java 的安装及使用"},{"categories":["Java","Spring","Youtube"],"contents":"15分钟学习Spring Boot和MyBatis   ","permalink":"http://itcodingman.github.io/15_mins_spring_boot_mybatis/","tags":[],"title":"15分钟学习Spring Boot和MyBatis"},{"categories":["C++","BiliBili"],"contents":"Visaul Studio Code C++ 安装及使用 Visaul Studio Code C++ 安装及使用 \r","permalink":"http://itcodingman.github.io/vscode_c_install_introduce/","tags":[],"title":"Visaul Studio Code C++ 安装及使用"},{"categories":["Java","Spring","Youtube"],"contents":"15分钟学习Spring和MyBatis   ","permalink":"http://itcodingman.github.io/15_mins_spring_mybatis/","tags":[],"title":"15分钟学习Spring和MyBatis"},{"categories":["Python","BiliBili"],"contents":"jupyter notebook安装及使用 Jupyter Notebook是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。 \r","permalink":"http://itcodingman.github.io/jupyter_notebook_install_introduce/","tags":[],"title":"jupyter notebook安装及使用"},{"categories":["Java","Youtube"],"contents":"40分钟学习MyBatis   ","permalink":"http://itcodingman.github.io/40_mins_mybatis/","tags":[],"title":"40分钟学习MyBatis"},{"categories":["C++","BiliBili"],"contents":"100分钟学习C++ 这是一门针对初学者的完整课程，学习有关C++的所有知识。包括：语法、语句、字符串、操作符、函数、文件等 \r","permalink":"http://itcodingman.github.io/100_mins_c/","tags":[],"title":"100分钟学习C++"},{"categories":["Java","Spring","Youtube"],"contents":"40分钟学习Spring Boot Web   ","permalink":"http://itcodingman.github.io/40_mins_spring_boot_web/","tags":[],"title":"40分钟学习Spring Boot Web"},{"categories":["Python","BiliBili"],"contents":"15分钟学习Numpy的通用函数 这是一门针对初学者的完整课程，学习有关NumPy的通用函数知识。包括：ufunc、计算、连接、差分等 \r","permalink":"http://itcodingman.github.io/15_mins_numpy_ufunc/","tags":[],"title":"15分钟学习Numpy的通用函数"},{"categories":["Java","Spring","Youtube"],"contents":"30分钟学习Spring MVC和Thymeleaf   ","permalink":"http://itcodingman.github.io/30_mins_spring_mvc_thymeleaf/","tags":[],"title":"30分钟学习Spring MVC和Thymeleaf"},{"categories":["Python","BiliBili"],"contents":"15分钟学习NumPy和数据分布 这是一门针对初学者的完整课程，学习有关NumPy的数据分布知识。包括：随机数、正态分布、泊松分布等数据分布 \r","permalink":"http://itcodingman.github.io/15_mins_numpy_data_distribution/","tags":[],"title":"15分钟学习NumPy和数据分布"},{"categories":["Java","Youtube"],"contents":"50分钟学习Thymeleaf   ","permalink":"http://itcodingman.github.io/50_mins_thymeleaf/","tags":[],"title":"50分钟学习Thymeleaf"},{"categories":["Python","BiliBili"],"contents":"30分钟学习Python和SciPy 这是一门针对初学者的完整课程，学习有关SciPy的所有知识。包括：常数、优化器、稀疏矩阵、图、空间数据、MatLib、统计等 \r","permalink":"http://itcodingman.github.io/30_mins_scipy/","tags":[],"title":"30分钟学习Python和SciPy"},{"categories":["Java","Youtube"],"contents":"40分钟学习JPA   ","permalink":"http://itcodingman.github.io/40_mins_jpa/","tags":[],"title":"40分钟学习JPA"},{"categories":["Python","BiliBili"],"contents":"30分钟学习Python和NumPy 这是一门针对初学者的完整课程，学习有关NumPy的所有知识。包括：数组、索引、切片、连接、拆分、排序、查询等 \r","permalink":"http://itcodingman.github.io/30_mins_numpy/","tags":[],"title":"30分钟学习Python和NumPy"},{"categories":["Java","Spring","Youtube"],"contents":"10分钟学习Spring Data JPA   ","permalink":"http://itcodingman.github.io/10_mins_spring_data_jpa/","tags":[],"title":"10分钟学习Spring Data JPA"},{"categories":["Python","BiliBili"],"contents":"30分钟学习Python和Matplotlib 这是一门针对初学者的完整课程，学习有关MatplotLib的所有知识。包括：绘图、标记、标签、网格、多图、散点图、柱状图、直方图、饼图等 \r","permalink":"http://itcodingman.github.io/30_mins_matplotlib/","tags":[],"title":"30分钟学习Python和Matplotlib"},{"categories":["Python","BiliBili"],"contents":"30分钟学习Python和Pandas Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。 \r","permalink":"http://itcodingman.github.io/30_mins_pandas/","tags":[],"title":"30分钟学习Python和Pandas"},{"categories":["Java","Spring","Youtube"],"contents":"10分钟学习Spring JPA   ","permalink":"http://itcodingman.github.io/10_mins_spring_jpa/","tags":[],"title":"10分钟学习Spring JPA"},{"categories":["Python","BiliBili"],"contents":"100分钟学习Python 这是一门针对初学者的完整课程，学习有关Python的所有知识。包括：语法、语句、字符串、操作符、函数、文件等 \r","permalink":"http://itcodingman.github.io/100_mins_python/","tags":[],"title":"100分钟学习Python"},{"categories":["Java","Youtube"],"contents":"30分钟学习JDBC   ","permalink":"http://itcodingman.github.io/30_mins_jdbc/","tags":[],"title":"30分钟学习JDBC"},{"categories":["Python","BiliBili"],"contents":"一小时学习Python和Flask 这是一门针对初学者的完整课程，学习有关Flask的所有知识。包括：基础知识（路由、变量及URL规则、 模板、 静态文件、 重定向和错误 ）和高级知识（Cookies及会话、 消息闪现、 WTF表单、文件上传、 SQLAlchemy及数据库、Sjiax）。 \r","permalink":"http://itcodingman.github.io/1_hour_flask/","tags":[],"title":"一小时学习Python和Flask"},{"categories":["Java","Spring","Youtube"],"contents":"10分钟学习Spring Data JDBC   ","permalink":"http://itcodingman.github.io/10_mins_spring_data_jdbc/","tags":[],"title":"10分钟学习Spring Data JDBC"},{"categories":["Java","Spring","Youtube"],"contents":"10分钟学习Spring Boot JDBC   ","permalink":"http://itcodingman.github.io/10_mins_spring_boot_jdbc/","tags":[],"title":"10分钟学习Spring Boot JDBC"},{"categories":["Python","BiliBili"],"contents":"一小时学习Python和Mediapipe 这是一门针对初学者的完整课程，学习有关MediaPipe的所有知识。包括：人脸识别、匹配、手势、姿势、自拍背景等。 \r","permalink":"http://itcodingman.github.io/1_hour_python_mediapipe/","tags":[],"title":"一小时学习Python和Mediapipe"},{"categories":["Java","Spring","Youtube"],"contents":"40分钟学习Spring Boot Spring Boot 教程包括 Spring Boot 的所有主题，例如特性、项目、maven 项目、启动项目向导、Spring Initializr、CLI、应用程序、注释、依赖管理、属性、启动器、执行器等。   ","permalink":"http://itcodingman.github.io/40_mins_spring_boot/","tags":[],"title":"40分钟学习Spring Boot"},{"categories":["Python","BiliBili"],"contents":"一小时学习Python和OpenCV 这是一门针对初学者的完整课程，学习有关OpenCV的所有知识。包括：基础知识（图像和视频的读取、图像变换、图形绘制）和高级知识（色彩空间、位操作、直方图和边缘检测、滤波）。最后部分讲解人脸检测和识别 。 \r","permalink":"http://itcodingman.github.io/1_hour_python_opencv/","tags":[],"title":"一小时学习Python和OpenCV"},{"categories":["Python","Youtube"],"contents":"使用OpenCV和EasyOCR识别车牌   ","permalink":"http://itcodingman.github.io/opencv_easyocr_anpr/","tags":[],"title":"使用OpenCV和EasyOCR识别车牌"},{"categories":["Java","Spring","Youtube"],"contents":"30分钟学习Spring MVC #SpringMVC   ","permalink":"http://itcodingman.github.io/30_mins_spring_mvc_springmvc/","tags":[],"title":"30分钟学习Spring MVC #SpringMVC"},{"categories":["Python","Youtube"],"contents":"10分钟学习TesseractOCR   ","permalink":"http://itcodingman.github.io/10_mins_tesseractocr/","tags":[],"title":"10分钟学习TesseractOCR"},{"categories":["Python","Youtube"],"contents":"10分钟学习EasyOCR   ","permalink":"http://itcodingman.github.io/10_mins_easyocr/","tags":["EasyOCR","OCR"],"title":"10分钟学习EasyOCR"},{"categories":["Java","Youtube"],"contents":"maven安装和使用   ","permalink":"http://itcodingman.github.io/maven_install_introduce/","tags":[],"title":"maven安装和使用"},{"categories":["Java","Spring","Youtube"],"contents":"Spring Tools 4 安装和使用   ","permalink":"http://itcodingman.github.io/spring_tools_install_introduce/","tags":[],"title":"Spring Tools 4 安装和使用"},{"categories":["Java","Spring","Youtube"],"contents":"10分钟学习Spring JDBC   ","permalink":"http://itcodingman.github.io/10_mins_spring_jdbc/","tags":[],"title":"10分钟学习Spring JDBC"},{"categories":["Java","Spring","Youtube"],"contents":"45分钟学习Spring Framework   ","permalink":"http://itcodingman.github.io/45_mins_spring_framework/","tags":[],"title":"45分钟学习Spring Framework"},{"categories":["Java","Youtube"],"contents":"30分钟学习Struts2 Struts 2 教程涵盖了 Struts 2 Framework 的所有主题，并为初学者和有经验的人提供了简化的示例。   ","permalink":"http://itcodingman.github.io/30_mins_struts2/","tags":[],"title":"30分钟学习Struts2"},{"categories":["Python","Youtube"],"contents":"10分钟学习Opencv目标跟踪 Object Tracking Opencv目标跟踪 Object Tracking   ","permalink":"http://itcodingman.github.io/10_mins_opencv_object_tracking/","tags":[],"title":"10分钟学习Opencv目标跟踪 Object Tracking"},{"categories":["Java","Spring","Youtube"],"contents":"Visual Studio Code Spring Boot 的安装及使用 Visual Studio Code和Spring Boot的安装及使用   ","permalink":"http://itcodingman.github.io/vscode_spring_boot_install_introduce/","tags":[],"title":"Visual Studio Code Spring Boot 的安装及使用"},{"categories":["Java","Youtube"],"contents":"一小时学习Servlet 本教程将讲解如何使用 Java Servlet 来开发基于 web 的应用程序。   ","permalink":"http://itcodingman.github.io/1_hour_servlet/","tags":[],"title":"一小时学习Servlet"},{"categories":["Python","Youtube"],"contents":"conda的安装和使用、国内源、常用命令 conda的安装和使用、国内源、常用命令   ","permalink":"http://itcodingman.github.io/conda_install_introduce/","tags":[],"title":"conda的安装和使用、国内源、常用命令"},{"categories":["Python","Youtube"],"contents":"PIP安装和使用、国内源、常用命令 PIP安装和使用、国内源、常用命令   ","permalink":"http://itcodingman.github.io/pip_install_introduce/","tags":[],"title":"PIP安装和使用、国内源、常用命令"},{"categories":["Java","Youtube"],"contents":"50分钟学习JSP JSP教程主要提供JSP基础知识以及部分常用的JSP进阶知识，大家在学习JSP之前，需要具备一定的HTML及Java基础。   ","permalink":"http://itcodingman.github.io/50_mins_jsp/","tags":[],"title":"50分钟学习JSP"},{"categories":["Youtube"],"contents":"20分钟学习web技术 本课程将系统学习Web基础知识及常用功能   ","permalink":"http://itcodingman.github.io/20_mins_web/","tags":[],"title":"20分钟学习web技术"},{"categories":["BiliBili"],"contents":"20分钟学习web技术 本课程将系统学习Web基础知识及常用功能 \r","permalink":"http://itcodingman.github.io/20_mins_web/","tags":[],"title":"20分钟学习web技术"},{"categories":["Java","Youtube"],"contents":"Eclipse、Tomcat和Java Web的安装、配置及开发 Eclipse、Tomcat和Java Web的安装、配置及开发   ","permalink":"http://itcodingman.github.io/eclipse_tomcat_java_web_install_introduce/","tags":[],"title":"Eclipse、Tomcat和Java Web的安装、配置及开发"},{"categories":["Java","Youtube"],"contents":"Eclipse和Java的安装 Eclipse和Java的安装   ","permalink":"http://itcodingman.github.io/eclipse_java_install_introduce/","tags":[],"title":"Eclipse和Java的安装"},{"categories":["Java","Youtube"],"contents":"100分钟学习Java 这是一门针对初学者的完整课程，学习有关Java的所有知识。包括：语法、语句、字符串、操作符、函数、文件等   ","permalink":"http://itcodingman.github.io/100_mins_java/","tags":[],"title":"100分钟学习Java"},{"categories":["Java","Youtube"],"contents":"Visual Studio Code Java 的安装及使用 VisualStudioCode和Java的安装及使用   ","permalink":"http://itcodingman.github.io/vscode_java_install_introduce/","tags":[],"title":"Visual Studio Code Java 的安装及使用"},{"categories":["C++","Youtube"],"contents":"Visaul Studio Code C++ 安装及使用 Visaul Studio Code C++ 安装及使用   ","permalink":"http://itcodingman.github.io/vscode_c_install_introduce/","tags":[],"title":"Visaul Studio Code C++ 安装及使用"},{"categories":["Python","Youtube"],"contents":"jupyter notebook安装及使用 Jupyter Notebook是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。   ","permalink":"http://itcodingman.github.io/jupyter_notebook_install_introduce/","tags":[],"title":"jupyter notebook安装及使用"},{"categories":["C++","Youtube"],"contents":"100分钟学习C++ 这是一门针对初学者的完整课程，学习有关C++的所有知识。包括：语法、语句、字符串、操作符、函数、文件等   ","permalink":"http://itcodingman.github.io/100_mins_c/","tags":[],"title":"100分钟学习C++"},{"categories":["Python","Youtube"],"contents":"15分钟学习Numpy的通用函数 这是一门针对初学者的完整课程，学习有关NumPy的通用函数知识。包括：ufunc、计算、连接、差分等   ","permalink":"http://itcodingman.github.io/15_mins_numpy_ufunc/","tags":[],"title":"15分钟学习Numpy的通用函数"},{"categories":["Python","Youtube"],"contents":"15分钟学习NumPy和数据分布 这是一门针对初学者的完整课程，学习有关NumPy的数据分布知识。包括：随机数、正态分布、泊松分布等数据分布   ","permalink":"http://itcodingman.github.io/15_mins_numpy_data_distribution/","tags":[],"title":"15分钟学习NumPy和数据分布"},{"categories":["Python","Youtube"],"contents":"30分钟学习Python和SciPy 这是一门针对初学者的完整课程，学习有关SciPy的所有知识。包括：常数、优化器、稀疏矩阵、图、空间数据、MatLib、统计等   ","permalink":"http://itcodingman.github.io/30_mins_scipy/","tags":[],"title":"30分钟学习Python和SciPy"},{"categories":["Python","Youtube"],"contents":"30分钟学习Python和NumPy 这是一门针对初学者的完整课程，学习有关NumPy的所有知识。包括：数组、索引、切片、连接、拆分、排序、查询等   ","permalink":"http://itcodingman.github.io/30_mins_numpy/","tags":[],"title":"30分钟学习Python和NumPy"},{"categories":["Python","Youtube"],"contents":"30分钟学习Python和Matplotlib 这是一门针对初学者的完整课程，学习有关MatplotLib的所有知识。包括：绘图、标记、标签、网格、多图、散点图、柱状图、直方图、饼图等   ","permalink":"http://itcodingman.github.io/30_mins_matplotlib/","tags":[],"title":"30分钟学习Python和Matplotlib"},{"categories":["Python","Youtube"],"contents":"100分钟学习Python 这是一门针对初学者的完整课程，学习有关Python的所有知识。包括：语法、语句、字符串、操作符、函数、文件等   ","permalink":"http://itcodingman.github.io/100_mins_python/","tags":[],"title":"100分钟学习Python"},{"categories":["Python","Youtube"],"contents":"30分钟学习Python和Pandas Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。   ","permalink":"http://itcodingman.github.io/30_mins_pandas/","tags":[],"title":"30分钟学习Python和Pandas"},{"categories":["Python","Youtube"],"contents":"一小时学习Python和Mediapipe 这是一门针对初学者的完整课程，学习有关MediaPipe的所有知识。包括：人脸识别、匹配、手势、姿势、自拍背景等。   ","permalink":"http://itcodingman.github.io/1_hour_python_mediapipe/","tags":[],"title":"一小时学习Python和Mediapipe"},{"categories":["Python"],"contents":"一小时学习python和flask 这是一门针对初学者的完整课程，学习有关Flask的所有知识。包括：基础知识（路由、变量及URL规则、 模板、 静态文件、重定向和错误 ）和高级知识（Cookies及会话、 消息闪现、 WTF表单、文件上传、 SQLAlchemy及数据库、Sjiax）。   ","permalink":"http://itcodingman.github.io/1_hour_python_flask/","tags":["Python","Flask"],"title":"一小时学习python和flask"},{"categories":["Python","Youtube"],"contents":"一小时学习Python和Flask 这是一门针对初学者的完整课程，学习有关Flask的所有知识。包括：基础知识（路由、变量及URL规则、 模板、 静态文件、 重定向和错误 ）和高级知识（Cookies及会话、 消息闪现、 WTF表单、文件上传、 SQLAlchemy及数据库、Sjiax）。   ","permalink":"http://itcodingman.github.io/1_hour_flask/","tags":[],"title":"一小时学习Python和Flask"},{"categories":["Python","Youtube"],"contents":"一小时学习Python和OpenCV 这是一门针对初学者的完整课程，学习有关OpenCV的所有知识。包括：基础知识（图像和视频的读取、图像变换、图形绘制）和高级知识（色彩空间、位操作、直方图和边缘检测、滤波）。最后部分讲解人脸检测和识别 。   ","permalink":"http://itcodingman.github.io/1_hour_python_opencv/","tags":[],"title":"一小时学习Python和OpenCV"},{"categories":null,"contents":"使用 Spring 和 Java Config 构建 REST API 一、概述 在本教程中，我们将学习如何**在 Spring 中设置 REST，**包括控制器和 HTTP 响应代码、有效负载编组的配置和内容协商。 进一步阅读： 使用 Spring @ResponseStatus 设置 HTTP 状态码 查看 @ResponseStatus 注释以及如何使用它来设置响应状态代码。 阅读更多→ Spring @Controller 和 @RestController 注解 了解 Spring MVC 中 @Controller 和 @RestController 注解的区别。 阅读更多→ 2. 了解 Spring 中的 REST Spring 框架支持两种创建 RESTful 服务的方式：  将 MVC 与ModelAndView一起使用 使用 HTTP 消息转换器  ModelAndView方法更老，文档更好，但也更冗长且配置繁重。它试图将 REST 范式硬塞到旧模型中，这并非没有问题。Spring 团队明白这一点，并从 Spring 3.0 开始提供一流的 REST 支持。 **新方法基于*HttpMessageConverter* 和注解，更轻量级且易于实现。**配置是最少的，它为我们对 RESTful 服务的期望提供了合理的默认值。 3. Java 配置 @Configuration @EnableWebMvc public class WebConfig{ // } 新的*@EnableWebMvc*注解做了一些有用的事情；具体来说，在 REST 的情况下，它会检测到类路径中 Jackson 和 JAXB 2 的存在，并自动创建和注册默认的 JSON 和 XML 转换器。注解的功能等同于 XML 版本： \u0026lt;mvc:注解驱动 /\u0026gt; 这是一条捷径，尽管它在许多情况下可能很有用，但并不完美。当我们需要更复杂的配置时，可以去掉注解，直接扩展WebMvcConfigurationSupport。 3.1。使用 Spring Boot 如果我们使用*@SpringBootApplication注解，并且spring-webmvc* 库位于类路径上，那么 @EnableWebMvc注解会自动添加，并带有默认的 autoconfiguration。 我们仍然可以通过在@Configuration 注释类上实现WebMvcConfigurer 接口 来将 MVC 功能添加到此配置中 。我们还可以使用 WebMvcRegistrationsAdapter实例来提供我们自己的 RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver 实现。 最后，如果我们想放弃 Spring Boot 的 MVC 特性并声明自定义配置，我们可以使用*@EnableWebMvc*注解来实现。 4. 测试 Spring 上下文 从 Spring 3.1 开始，我们获得了对@Configuration类的一流测试支持： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( classes = {WebConfig.class, PersistenceConfig.class}, loader = AnnotationConfigContextLoader.class) public class SpringContextIntegrationTest { @Test public void contextLoads(){ // When  } } 我们使用*@ContextConfiguration注解指定 Java 配置类。新的AnnotationConfigContextLoader从@Configuration*类加载 bean 定义。 请注意，WebConfig配置类未包含在测试中，因为它需要在未提供的 Servlet 上下文中运行。 4.1。使用 Spring Boot Spring Boot 提供了几个注解来以更直观的方式为我们的测试设置 Spring ApplicationContext 。 我们可以只加载应用程序配置的特定部分，也可以模拟整个上下文启动过程。 例如， 如果我们想在不启动服务器的情况下创建整个上下文，我们可以使用*@SpringBootTest注解。* 有了它，我们就可以添加*@AutoConfigureMockMvc* 来注入 MockMvc 实例并发送 HTTP 请求*：* @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class FooControllerAppIntegrationTest { @Autowired private MockMvc mockMvc; @Test public void whenTestApp_thenEmptyResponse() throws Exception { this.mockMvc.perform(get(\u0026#34;/foos\u0026#34;) .andExpect(status().isOk()) .andExpect(...); } } 为了避免创建整个上下文并只测试我们的 MVC 控制器，我们可以使用 @WebMvcTest： @RunWith(SpringRunner.class) @WebMvcTest(FooController.class) public class FooControllerWebLayerIntegrationTest { @Autowired private MockMvc mockMvc; @MockBean private IFooService service; @Test() public void whenTestMvcController_thenRetrieveExpectedResult() throws Exception { // ...  this.mockMvc.perform(get(\u0026#34;/foos\u0026#34;) .andExpect(...); } } 我们可以在“Spring Boot 中的测试”文章中找到有关此主题的详细信息。 5. 控制器 **@RestController是 RESTful API 的整个 Web 层中的核心工件*。***就本文而言，控制器正在建模一个简单的 REST 资源Foo： @RestController @RequestMapping(\u0026#34;/foos\u0026#34;) class FooController { @Autowired private IFooService service; @GetMapping public List\u0026lt;Foo\u0026gt; findAll() { return service.findAll(); } @GetMapping(value = \u0026#34;/{id}\u0026#34;) public Foo findById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return RestPreconditions.checkFound(service.findById(id)); } @PostMapping @ResponseStatus(HttpStatus.CREATED) public Long create(@RequestBody Foo resource) { Preconditions.checkNotNull(resource); return service.create(resource); } @PutMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.OK) public void update(@PathVariable( \u0026#34;id\u0026#34; ) Long id, @RequestBody Foo resource) { Preconditions.checkNotNull(resource); RestPreconditions.checkNotNull(service.getById(resource.getId())); service.update(resource); } @DeleteMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.OK) public void delete(@PathVariable(\u0026#34;id\u0026#34;) Long id) { service.deleteById(id); } } 正如我们所见，我们使用了一个简单的 Guava 风格的RestPreconditions实用程序： public class RestPreconditions { public static \u0026lt;T\u0026gt; T checkFound(T resource) { if (resource == null) { throw new MyResourceNotFoundException(); } return resource; } } Controller 实现是非公开的，因为它不需要。 通常，控制器是依赖链中的最后一个。它从 Spring 前端控制器（DispatcherServlet）接收 HTTP 请求，并将它们简单地委托给服务层。如果没有必须通过直接引用注入或操作控制器的用例，那么我们可能不希望将其声明为公共的。 请求映射很简单。与任何控制器一样，映射的实际*值*以及 HTTP 方法决定了请求的目标方法。@RequestBody将方法的参数绑定到 HTTP 请求的主体，而*@ResponseBody对响应和返回类型执行相同的操作。* @RestController 是在我们的类*中*包含 *@ResponseBody* 和 *@Controller*注释的简写*。* 他们还确保使用正确的 HTTP 转换器对资源进行编组和解组。将进行内容协商以选择将使用哪一个活动转换器，主要基于Accept标头，尽管也可以使用其他 HTTP 标头来确定表示形式。 6. 映射 HTTP 响应代码 HTTP 响应的状态码是 REST 服务最重要的部分之一，主题很快就会变得非常复杂。正确处理这些可能是服务的成败。 6.1。未映射的请求 如果 Spring MVC 接收到一个没有映射的请求，它认为该请求不允许，并返回一个 405 METHOD NOT ALLOWED 返回给客户端。 在向客户端返回405以指定允许哪些操作时，包含Allow HTTP 标头也是一种很好的做法。这是 Spring MVC 的标准行为，不需要任何额外的配置。 6.2. 有效的映射请求 对于任何具有映射的请求，Spring MVC 认为该请求有效并以 200 OK 响应，如果没有另外指定其他状态代码。 正因为如此，控制器为create、update和delete操作声明了不同的**@ResponseStatus，但没有为get声明，它确实应该返回默认的 200 OK。 6.3. 客户端错误 在客户端错误的情况下，自定义异常被定义并映射到适当的错误代码。 简单地从 web 层的任何层抛出这些异常将确保 Spring 在 HTTP 响应上映射相应的状态代码： @ResponseStatus(HttpStatus.BAD_REQUEST) public class BadRequestException extends RuntimeException { // } @ResponseStatus(HttpStatus.NOT_FOUND) public class ResourceNotFoundException extends RuntimeException { // } 这些异常是 REST API 的一部分，因此，我们应该只在与 REST 对应的适当层中使用它们；例如，如果存在 DAO/DAL 层，则不应直接使用异常。 另请注意，这些不是检查异常，而是符合 Spring 实践和习惯用法的运行时异常。 6.4. 使用*@ExceptionHandler* 将自定义异常映射到特定状态代码的另一个选项是在控制器中使用*@ExceptionHandler*注释。这种方法的问题在于注释仅适用于定义它的控制器。这意味着我们需要在每个控制器中单独声明它们。 当然，在 Spring 和 Spring Boot 中处理错误的方法更多，提供了更大的灵活性。 7. 额外的 Maven 依赖 除了标准 Web 应用程序所需的spring-webmvc依赖项之外，我们还需要为 REST API 设置内容编组和解组： \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 我们将使用这些库将 REST 资源的表示形式转换为 JSON 或 XML。 7.1。使用 Spring Boot 如果我们想检索 JSON 格式的资源，Spring Boot 提供了对不同库的支持，即 Jackson、Gson 和 JSON-B。 我们可以通过简单地在类路径中包含任何映射库来执行自动配置。 通常，如果我们正在开发一个 Web 应用程序，我们只需添加 *spring-boot-starter-web*依赖项并依赖它来将所有必要的工件包含到我们的项目中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Spring Boot 默认使用 Jackson。 如果我们想以 XML 格式序列化我们的资源，我们必须将 Jackson XML 扩展 ( jackson-dataformat-xml ) 添加到我们的依赖项中，或者通过使用回退到 JAXB 实现（JDK 中默认提供） 我们资源上的*@XmlRootElement*注释。 8. 结论 本文说明了如何使用 Spring 和基于 Java 的配置来实现和配置 REST 服务。 在本系列的下一篇文章中，我们将重点介绍API 的可发现性、高级内容协商以及使用资源的其他表示。 本文中的所有代码都可以在 Github 上找到。这是一个基于 Maven 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/building-a-restful-web-service-with-spring-and-java-based-configuration/","tags":null,"title":""},{"categories":null,"contents":"Spring REST API 的实体到 DTO 转换 一、概述 在本教程中，我们将处理需要在 Spring 应用程序的内部实体和发布回客户端的外部**DTO （数据传输对象）之间发生的转换。** 进一步阅读： Spring 的 RequestBody 和 ResponseBody 注解 了解 Spring @RequestBody 和 @ResponseBody 注释。 阅读更多→ MapStruct 快速指南 使用 MapStruct 的快速实用指南 阅读更多→ 2. 模型映射器 让我们首先介绍我们将用于执行此实体-DTO 转换的主库*ModelMapper*。 我们将在pom.xml中需要这个依赖： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.modelmapper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;modelmapper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 要检查此库是否有更新版本，[请转到此处](https://search.maven.org/classic/#search|gav|1|g%3A\u0026quot;org.modelmapper\u0026quot; AND a%3A\u0026quot;modelmapper\u0026quot;)。 然后我们将在 Spring 配置中定义ModelMapper bean： @Bean public ModelMapper modelMapper() { return new ModelMapper(); } 3. DTO 接下来我们介绍一下这个双面问题的DTO端，Post DTO： public class PostDto { private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm\u0026#34;); private Long id; private String title; private String url; private String date; private UserDto user; public Date getSubmissionDateConverted(String timezone) throws ParseException { dateFormat.setTimeZone(TimeZone.getTimeZone(timezone)); return dateFormat.parse(this.date); } public void setSubmissionDate(Date date, String timezone) { dateFormat.setTimeZone(TimeZone.getTimeZone(timezone)); this.date = dateFormat.format(date); } // standard getters and setters } 请注意，两个自定义日期相关方法处理客户端和服务器之间来回的日期转换：  getSubmissionDateConverted()方法将日期字符串转换为服务器时区中的日期，以在持久的Post实体中使用它 setSubmissionDate()方法是在当前用户时区将 DTO 的日期设置为Post的日期  4.服务层 现在让我们看一下服务级别操作，它显然适用于实体（而不是 DTO）： public List\u0026lt;Post\u0026gt; getPostsList( int page, int size, String sortDir, String sort) { PageRequest pageReq = PageRequest.of(page, size, Sort.Direction.fromString(sortDir), sort); Page\u0026lt;Post\u0026gt; posts = postRepository .findByUser(userService.getCurrentUser(), pageReq); return posts.getContent(); } 接下来我们将看一下服务之上的层，即控制器层。这是实际发生转换的地方。 5.控制器层 接下来让我们检查一个标准控制器实现，为Post资源公开简单的 REST API。 我们将在这里展示一些简单的 CRUD 操作：创建、更新、获取一个和获取所有。鉴于操作非常简单，我们对 Entity-DTO 转换方面特别感兴趣： @Controller class PostRestController { @Autowired private IPostService postService; @Autowired private IUserService userService; @Autowired private ModelMapper modelMapper; @GetMapping @ResponseBody public List\u0026lt;PostDto\u0026gt; getPosts(...) { //...  List\u0026lt;Post\u0026gt; posts = postService.getPostsList(page, size, sortDir, sort); return posts.stream() .map(this::convertToDto) .collect(Collectors.toList()); } @PostMapping @ResponseStatus(HttpStatus.CREATED) @ResponseBody public PostDto createPost(@RequestBody PostDto postDto) { Post post = convertToEntity(postDto); Post postCreated = postService.createPost(post)); return convertToDto(postCreated); } @GetMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseBody public PostDto getPost(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return convertToDto(postService.getPostById(id)); } @PutMapping(value = \u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.OK) public void updatePost(@PathVariable(\u0026#34;id\u0026#34;) Long id, @RequestBody PostDto postDto) { if(!Objects.equals(id, postDto.getId())){ throw new IllegalArgumentException(\u0026#34;IDs don\u0026#39;t match\u0026#34;); } Post post = convertToEntity(postDto); postService.updatePost(post); } } 这是我们从*Post*实体到*PostDto*的转换： private PostDto convertToDto(Post post) { PostDto postDto = modelMapper.map(post, PostDto.class); postDto.setSubmissionDate(post.getSubmissionDate(), userService.getCurrentUser().getPreference().getTimezone()); return postDto; } 这是从 DTO 到实体的转换： private Post convertToEntity(PostDto postDto) throws ParseException { Post post = modelMapper.map(postDto, Post.class); post.setSubmissionDate(postDto.getSubmissionDateConverted( userService.getCurrentUser().getPreference().getTimezone())); if (postDto.getId() != null) { Post oldPost = postService.getPostById(postDto.getId()); post.setRedditID(oldPost.getRedditID()); post.setSent(oldPost.isSent()); } return post; } 如我们所见，在模型映射器的帮助下，**转换逻辑快速而简单。**我们正在使用映射器的地图API，并且无需编写任何转换逻辑即可转换数据。 6. 单元测试 最后，让我们做一个非常简单的测试，以确保实体和 DTO 之间的转换工作正常： public class PostDtoUnitTest { private ModelMapper modelMapper = new ModelMapper(); @Test public void whenConvertPostEntityToPostDto_thenCorrect() { Post post = new Post(); post.setId(1L); post.setTitle(randomAlphabetic(6)); post.setUrl(\u0026#34;www.test.com\u0026#34;); PostDto postDto = modelMapper.map(post, PostDto.class); assertEquals(post.getId(), postDto.getId()); assertEquals(post.getTitle(), postDto.getTitle()); assertEquals(post.getUrl(), postDto.getUrl()); } @Test public void whenConvertPostDtoToPostEntity_thenCorrect() { PostDto postDto = new PostDto(); postDto.setId(1L); postDto.setTitle(randomAlphabetic(6)); postDto.setUrl(\u0026#34;www.test.com\u0026#34;); Post post = modelMapper.map(postDto, Post.class); assertEquals(postDto.getId(), post.getId()); assertEquals(postDto.getTitle(), post.getTitle()); assertEquals(postDto.getUrl(), post.getUrl()); } } 7. 结论 在本文中，我们详细介绍了简化从 Entity 到 DTO 以及在 Spring REST API 中从 DTO 到 Entity 的转换，方法是使用模型映射器库而不是手动编写这些转换。 示例的完整源代码可在GitHub 项目中找到。 ","permalink":"http://itcodingman.github.io/entity-to-and-from-dto-for-a-java-spring-application/","tags":null,"title":""},{"categories":null,"contents":"Spring 持久性教程 Spring 和 JPA/休眠  *休眠 5 与 Spring* *在 Spring Boot 中以编程方式配置数据源* *与 Spring 和 JPA 的事务 （流行）* *Spring中的事务传播和隔离@Transactional （流行）* *Spring中的程序化事务管理* *JPA/Hibernate 持久化上下文* *带有 Spring 和 Hibernate 的 DAO* *JPA 和 Spring 的 DAO* *使用 Spring 和 Java 泛型简化 DAO* *显示来自 Spring Boot 的 Hibernate/JPA SQL 语句* *使用 Spring Boot 加载初始数据的快速指南*  春季数据 JPA  *带有 Spring Setup 的 JPA（流行）* *Spring Data JPA 简介 （通俗）* *Spring Data JPA @Query （流行）* *Spring Data JPA @Modifying 注解* *Spring Data – CrudRepository save() 方法* *Spring Data JPA Repositories 中的派生查询方法（流行）* *Spring Data JPA 删除和关系* *Spring Data JPA 和 Null 参数 * *带有 H2 数据库的 Spring Boot （流行）* *禁用 Spring Data 自动配置* *@DynamicUpdate 与 Spring Data JPA * *Spring JPA 存储库中的 LIKE 查询* *使用 Spring Data JPA 按日期和时间查询实体* *使用 JPA 和 Spring Data JPA 限制查询结果* *使用 Spring Data JPA 进行分页和排序 （流行）* *使用 Spring Data 对查询结果进行排序* *从 Spring Data JPA 存储库调用存储过程* *使用 JPA、Hibernate 和 Spring Data JPA 进行审计* *Spring Data 中 save() 和 saveAll() 的性能差异* *如何使用 Spring JPA 实现软删除* *使用 JPA 返回自动生成的 ID*  其他 Spring 持久性技术  *使用 Liquibase 安全地发展您的数据库架构* *Liquibase 回滚简介* *使用 Flyway 进行数据库迁移* *使用 Spring Data 的 Spring Boot 应用程序中的 DynamoDB* *MyBatis 与 Spring* *使用 Kotlin 和 JPA* *Spring JDBC（流行）* *在 JdbcTemplate IN 子句中使用值列表* *Spring Data REST 简介* *Spring Data JDBC简介*  春季数据 MongoDB  *Spring Data MongoDB 简介* *Spring Data MongoDB 中的查询指南* *Spring Data MongoDB——索引、注释和转换器* *Spring Data MongoDB 中的自定义级联* *Spring Data Reactive Repositories with MongoDB* *使用嵌入式 MongoDB 进行 Spring Boot 集成测试* *Spring Data MongoDB 事务*  其他 Spring 教程  REST with Spring 教程 如何使用 Spring 构建 REST 服务 Spring 异常教程 Spring 中一些最常见的异常示例——为什么会发生以及如何快速解决它们 Spring 的安全性如何保护 MVC 项目、登录和注销、如何使用 OAuth 保护 REST 服务。  ","permalink":"http://itcodingman.github.io/persistence-with-spring-series/","tags":null,"title":""},{"categories":null,"contents":"使用 Spring 进行项目配置 目录  **1.**配置必须是特定于环境的 **2.每个环境的.properties文件 **3.**弹簧配置 **4.**在每个环境中设置属性 **5.**测试和 Maven **6.**更进一步 **7.**结论  1. 配置必须是特定于环境的 配置必须是特定于环境的——这是不争的事实。如果不是这种情况，那么它就不是配置，我们只会在代码中硬编码值。 对于 Spring 应用程序，您可以使用多种解决方案——从简单的解决方案一直到超级灵活、高度复杂的替代方案。 一个更常见和直接的解决方案是灵活使用属性文件和Spring 提供的一流属性支持。 作为概念证明，出于本文的目的，我们将了解一种特定类型的属性——数据库配置。将一种类型的数据库配置用于生产，另一种用于测试，另一种用于开发环境是非常有意义的。 2.每个环境的*.properties文件* 让我们开始我们的概念证明——通过定义我们想要定位的环境：    开发 分期 生产    720 接下来 – 让我们创建 3 个属性文件 – 每个环境一个：  持久性-dev.properties 持久性-staging.properties 持久性生产.properties  在典型的 Maven 应用程序中，它们可以驻留在src/main/resources中，但是无论它们在哪里，它们都需要在部署应用程序时在类路径中可用。 一个重要的旁注——将所有属性文件置于版本控制之下，使配置更加透明和可重复。这与将配置放在磁盘上的某个地方并简单地将 Spring 指向它们相反。 3. 弹簧配置 在 Spring 中，我们将根据环境包含正确的文件： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\u0026#34;\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34; classpath*:*persistence-${envTarget}.properties\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 当然，Java 配置也可以做到这一点： @PropertySource({ \u0026#34;classpath:persistence-${envTarget:dev}.properties\u0026#34; }) 这种方法允许灵活地拥有多个**.properties*文件以用于特定的、集中的目的。例如——在我们的例子中，持久性 Spring 配置导入持久性属性——这非常有意义。安全配置将导入与安全相关的属性等。 4. 在每个环境中设置属性 最终的、可部署的战争将包含所有属性文件——对于持久性， persistence-*.properties的三个变体。由于文件实际上命名不同，因此不必担心意外包含错误的文件。我们将设置*envTarget*变量，从而从多个现有变体中选择我们想要的实例。 envTarget变量可以在操作系统/环境中设置或作为 JVM 命令行的参数*：* -DenvTarget=dev 5. 测试和 Maven 对于需要启用持久性的集成测试——我们只需在 pom.xml 中设置envTarget属性： \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;systemPropertyVariables\u0026gt; \u0026lt;envTarget\u0026gt;h2_test\u0026lt;/envTarget\u0026gt; \u0026lt;/systemPropertyVariables\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; 对应的persistence-h2_test.properties文件可以放在src/test/resources中，这样它就只会用于测试，而不是在运行时不必要地包含和部署在 war 中。 6. 更进一步 如果需要，有几种方法可以在此解决方案中增加额外的灵活性。 一种这样的方法是对属性文件的名称使用更复杂的编码，不仅指定要使用它们的环境，还指定更多信息（例如持久性提供程序）。例如，我们可能会使用以下类型的属性：persistence-h2.properties、persistence-mysql.properties ，或者更具体的：persistence-dev_h2.properties、persistence-staging_mysql.properties、persistence-production_amazonRDS.properties。 这种命名约定的优势——它只是一个约定，因为整体方法没有任何变化——只是透明。现在仅通过查看名称就可以更清楚地了解配置的作用：  *persistence-dev_h2.properties*：开发环境的持久性提供程序是一个轻量级的内存 H2 数据库 *persistence-staging_mysql.properties*：暂存环境的持久性提供程序是一个 MySQL 实例 *persistence-production_amazon_rds.propertie*：生产环境的持久性提供程序是 Amazon RDS  7. 结论 本文讨论了在 Spring 中进行环境特定配置的灵活解决方案。可以在此处找到使用配置文件的替代解决方案。 解决方案的实现可以在GitHub 项目中找到——这是一个基于 Maven 的项目，因此应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/project-configuration-with-spring/","tags":null,"title":""},{"categories":null,"contents":"Spring 和 Spring Boot 的属性 1. 概述 本教程将展示如何 通过 Java 配置和*@PropertySource*在 Spring 中设置和使用属性。 我们还将看到属性在 Spring Boot 中是如何工作的。 2. 通过注解注册一个属性文件 Spring 3.1 还引入了新的*@PropertySource*注解作为向环境添加属性源的便捷机制。 我们可以将此注解与*@Configuration*注解结合使用： @Configuration @PropertySource(\u0026#34;classpath:foo.properties\u0026#34;) public class PropertiesWithJavaConfig { //... } 注册新属性文件的另一种非常有用的方法是使用占位符，它允许我们在运行时动态选择正确的文件： @PropertySource({ \u0026#34;classpath:persistence-${envTarget:mysql}.properties\u0026#34; }) ... 2.1。定义多个属性位置 根据Java 8 约定， @PropertySource注释是可重复的。因此，如果我们使用 Java 8 或更高版本，我们可以使用这个注解来定义多个属性位置： @PropertySource(\u0026#34;classpath:foo.properties\u0026#34;) @PropertySource(\u0026#34;classpath:bar.properties\u0026#34;) public class PropertiesWithJavaConfig { //... } 当然，*我们也可以使用@PropertySources注解，指定一个@PropertySource*数组。**这适用于任何受支持的 Java 版本，而不仅仅是 Java 8 或更高版本： @PropertySources({ @PropertySource(\u0026#34;classpath:foo.properties\u0026#34;), @PropertySource(\u0026#34;classpath:bar.properties\u0026#34;) }) public class PropertiesWithJavaConfig { //... } 在任何一种情况下，值得注意的是，如果发生属性名称冲突，最后读取的源优先。 3. 使用/注入属性 *使用@Value*注释****注入属性很简单： @Value( \u0026#34;${jdbc.url}\u0026#34; ) private String jdbcUrl; 我们还可以为属性指定一个默认值： @Value( \u0026#34;${jdbc.url:aDefaultUrl}\u0026#34; ) private String jdbcUrl; Spring 3.1 中添加的新PropertySourcesPlaceholderConfigurer在 bean 定义属性值和*@Value*注释中解析 ${…} 占位符。 最后，我们可以使用*Environment* API 获取属性的值 ： @Autowired private Environment env; ... dataSource.setUrl(env.getProperty(\u0026#34;jdbc.url\u0026#34;)); 4. Spring Boot 的属性 在我们进入更高级的属性配置选项之前，让我们花一些时间来看看 Spring Boot 中的新属性支持。 一般来说，与标准 Spring 相比，这种新的支持涉及更少的配置，这当然是 Boot 的主要目标之一。 4.1。*application.properties：*默认属性文件 Boot 将其典型的约定优于配置方法应用于属性文件。这意味着我们可以简单地将*application.properties*文件放在我们的*src/main/resources* 目录中，它会被自动检测到。然后我们可以像往常一样从中注入任何加载的属性。 因此，通过使用此默认文件，我们不必显式注册PropertySource ，甚至不必提供属性文件的路径。 如果需要，我们还可以使用环境属性在运行时配置不同的文件： java -jar app.jar --spring.config.location=classpath:/another-location.properties 从Spring Boot 2.3开始，我们还可以为配置文件指定通配符位置。 例如，我们可以将 spring.config.location 属性设置为 config/*/： java -jar app.jar --spring.config.location=config/*/ 这样，Spring Boot 将在我们的 jar 文件之外查找与*config/*/ 目录模式匹配的配置文件。*当我们有多个配置属性来源时，这会派上用场。 从2.4.0版本开始，Spring Boot 支持使用多文档属性文件，类似于YAML的设计： baeldung.customProperty=defaultValue #--- baeldung.customProperty=overriddenValue 请注意，对于属性文件，三破折号表示法前面有一个注释字符 ( # )。 4.2. 环境特定的属性文件 如果我们需要针对不同的环境，Boot 中有一个内置机制。 *我们可以简单的在*src/main/resources目录下定义一个*application-environment.properties*文件，然后设置一个相同环境名的 Spring profile。 例如，如果我们定义一个“暂存”环境，这意味着我们必须定义一个暂存配置文件，然后定义application-staging.properties。 此 env 文件将被加载，**并将优先于默认属性文件。**注意还是会加载默认文件，只是当发生属性冲突时，环境特定的属性文件优先。 4.3. 测试特定的属性文件 当我们的应用程序正在测试时，我们可能还需要使用不同的属性值。 Spring Boot 通过在测试运行期间查看我们的*src/test/resources* 目录来为我们处理这个问题。同样，默认属性仍然可以正常注入，但如果发生冲突，默认属性将被这些属性覆盖。 4.4. *@TestPropertySource*注解 如果我们需要对测试属性进行更精细的控制，那么我们可以使用*@TestPropertySource*注释。 这允许我们为特定的测试上下文设置测试属性，优先于默认属性源： @RunWith(SpringRunner.class) @TestPropertySource(\u0026#34;/foo.properties\u0026#34;) public class FilePropertyInjectionUnitTest { @Value(\u0026#34;${foo}\u0026#34;) private String foo; @Test public void whenFilePropertyProvided_thenProperlyInjected() { assertThat(foo).isEqualTo(\u0026#34;bar\u0026#34;); } } 如果我们不想使用文件，我们可以直接指定名称和值： @RunWith(SpringRunner.class) @TestPropertySource(properties = {\u0026#34;foo=bar\u0026#34;}) public class PropertyInjectionUnitTest { @Value(\u0026#34;${foo}\u0026#34;) private String foo; @Test public void whenPropertyProvided_thenProperlyInjected() { assertThat(foo).isEqualTo(\u0026#34;bar\u0026#34;); } } *我们也可以使用@SpringBootTest*注解的*properties*参数来实现类似的效果： @RunWith(SpringRunner.class) @SpringBootTest( properties = {\u0026#34;foo=bar\u0026#34;}, classes = SpringBootPropertiesTestApplication.class) public class SpringBootPropertyInjectionIntegrationTest { @Value(\u0026#34;${foo}\u0026#34;) private String foo; @Test public void whenSpringBootPropertyProvided_thenProperlyInjected() { assertThat(foo).isEqualTo(\u0026#34;bar\u0026#34;); } } 4.5. 分层属性 如果我们有组合在一起的属性，我们可以使用*@ConfigurationProperties*注释，它将这些属性层次结构映射到 Java 对象图中。 让我们使用一些用于配置数据库连接的属性： database.url=jdbc:postgresql:/localhost:5432/instance database.username=foo database.password=bar 然后让我们使用注解将它们映射到数据库对象： @ConfigurationProperties(prefix = \u0026#34;database\u0026#34;) public class Database { String url; String username; String password; // standard getters and setters } Spring Boot 再次应用它的约定而不是配置方法，在属性名称及其对应字段之间自动映射。我们需要提供的只是属性前缀。 如果您想深入了解配置属性，请查看我们的深度文章。 4.6. 替代方案：YAML 文件 Spring 还支持 YAML 文件。 所有相同的命名规则都适用于特定于测试的、特定于环境的和默认属性文件。唯一的区别是文件扩展名和对我们类路径上的SnakeYAML库的依赖。 YAML 特别适合分层属性存储；以下属性文件： database.url=jdbc:postgresql:/localhost:5432/instance database.username=foo database.password=bar secret: foo 与以下 YAML 文件同义： database: url: jdbc:postgresql:/localhost:5432/instance username: foo password: bar secret: foo 还值得一提的是 YAML 文件不支持*@PropertySource*注解，所以如果我们需要使用这个注解，它会限制我们使用属性文件。 另一个值得注意的点是，在 2.4.0 版本中，Spring Boot 改变了从多文档 YAML 文件加载属性的方式。以前，它们的添加顺序基于配置文件激活顺序。然而，在新版本中，框架遵循我们之前为*.properties*文件指出的相同排序规则；在文件中声明较低的属性将简单地覆盖那些较高的属性。 此外，在此版本中，无法再从特定于配置文件的文档中激活配置文件，从而使结果更加清晰和可预测。 4.7. 导入其他配置文件 在 2.4.0 版本之前，Spring Boot 允许使用spring.config.location和 spring.config.additional-location 属性包含其他配置文件，但它们有一定的限制。例如，必须在启动应用程序之前定义它们（作为环境或系统属性，或使用命令行参数），因为它们在流程的早期使用。 在上述版本中，**我们可以使用 *application.properties* 或 *application.yml 文件中的**spring.config.import*属性来轻松包含其他文件。**这个属性支持一些有趣的特性：  添加多个文件或目录 可以从类路径或外部目录加载文件 指示如果找不到文件或者它是否是可选文件，则启动过程是否应该失败 导入无扩展名文件  让我们看一个有效的例子： spring.config.import=classpath:additional-application.properties, classpath:additional-application[.yml], optional:file:./external.properties, classpath:additional-application-properties/ 注意：为了清楚起见，我们在这里使用换行符格式化了这个属性。 Spring 会将导入视为紧接在导入声明下方插入的新文档。 4.8. 命令行参数的属性 除了使用文件，我们还可以直接在命令行中传递属性： java -jar app.jar --property=\u0026#34;value\u0026#34; 我们也可以通过系统属性来做到这一点，这些属性在*-jar*命令之前而不是之后提供： java -Dproperty.name=\u0026#34;value\u0026#34; -jar app.jar 4.9. 来自环境变量的属性 Spring Boot 还将检测环境变量，将它们视为属性： export name=value java -jar app.jar 4.10。属性值的随机化 如果我们不想要确定性属性值，我们可以使用*RandomValuePropertySource* 来随机化属性值： random.number=${random.int} random.long=${random.long} random.uuid=${random.uuid} 4.11。其他类型的财产来源 Spring Boot 支持多种属性源，实现了经过深思熟虑的排序以允许明智的覆盖。值得参考官方文档，这超出了本文的范围。 5. 使用原始 Bean 进行配置 — *PropertySourcesPlaceholderConfigurer* 除了将属性获取到 Spring 中的便捷方法外，我们还可以手动定义和注册属性配置 bean。 使用*PropertySourcesPlaceholderConfigurer*可以让我们完全控制配置，但缺点是更冗长且大多数时候是不必要的。 让我们看看如何使用 Java 配置定义这个 bean： @Bean public static PropertySourcesPlaceholderConfigurer properties(){ PropertySourcesPlaceholderConfigurer pspc = new PropertySourcesPlaceholderConfigurer(); Resource[] resources = new ClassPathResource[ ] { new ClassPathResource( \u0026#34;foo.properties\u0026#34; ) }; pspc.setLocations( resources ); pspc.setIgnoreUnresolvablePlaceholders( true ); return pspc; } 6. 父子上下文中的属性 这个问题一次又一次地出现：当我们的Web 应用程序有父上下文和子上下文时会发生什么？父上下文可能有一些共同的核心功能和 bean，然后是一个（或多个）子上下文，可能包含特定于 servlet 的 bean。 在这种情况下，定义属性文件并将它们包含在这些上下文中的最佳方法是什么？以及如何最好地从 Spring 中检索这些属性？ 我们将给出一个简单的细分。 如果文件是在父上下文中定义的：   @Value在子上下文中工作：是   @Value在父上下文中工作：是   子上下文中的environment.getProperty：是   父上下文中的environment.getProperty：是   如果文件在子上下文中定义：   @Value在子上下文中工作：是   @Value在父上下文中工作：否   子上下文中的environment.getProperty：是   父上下文中的environment.getProperty：否   7. 结论 本文展示了在 Spring 中使用属性和属性文件的几个示例。 ","permalink":"http://itcodingman.github.io/properties-with-spring/","tags":null,"title":""},{"categories":null,"contents":"Spring REST API + OAuth2 + Angular 一、概述 在本教程中，我们将使用 OAuth2 保护 REST API，并从一个简单的 Angular 客户端使用它。 我们要构建的应用程序将包含三个独立的模块：  授权服务器 资源服务器 UI 授权码：使用授权码流程的前端应用程序  **我们将在 Spring Security 5 中使用 OAuth 堆栈。**如果您想使用 Spring Security OAuth legacy stack，请查看之前的这篇文章：Spring REST API + OAuth2 + Angular（使用 Spring Security OAuth Legacy Stack）。 进一步阅读： 将 JWT 与 Spring Security OAuth 结合使用 在 Spring Security 5 中使用 JWT 令牌的指南。 阅读更多→ OAuth2.0 和动态客户端注册（使用 Spring Security OAuth 遗留堆栈） 了解如何使用 Spring Security 和 OAuth2 动态定义客户端。 阅读更多→ 让我们直接跳进去。 2. OAuth2授权服务器（AS） 简单地说，授权服务器是一个发布授权令牌的应用程序。 以前，Spring Security OAuth 堆栈提供了将授权服务器设置为 Spring 应用程序的可能性。但该项目已被弃用，主要是因为 OAuth 是一个开放标准，拥有许多成熟的供应商，例如 Okta、Keycloak 和 ForgeRock，仅举几例。 其中，我们将使用Keycloak。它是由 Red Hat 管理的开源身份和访问管理服务器，由 JBoss 用 Java 开发。它不仅支持 OAuth2，还支持其他标准协议，例如 OpenID Connect 和 SAML。 对于本教程，我们将在 Spring Boot 应用程序中设置嵌入式 Keycloak 服务器。 3. 资源服务器（RS） 现在让我们讨论资源服务器；这本质上是 REST API，我们最终希望能够使用它。 3.1。Maven 配置 我们的资源服务器的 pom 与之前的授权服务器 pom 非常相似，没有 Keycloak 部分，并具有额外的*spring-boot-starter-oauth2-resource-server*依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-oauth2-resource-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3.2. 安全配置 由于我们使用的是 Spring Boot，因此我们可以使用 Boot 属性定义所需的最低配置。 我们将在application.yml文件中执行此操作： server: port: 8081 servlet: context-path: /resource-server spring: security: oauth2: resourceserver: jwt: issuer-uri: http://localhost:8083/auth/realms/baeldung jwk-set-uri: http://localhost:8083/auth/realms/baeldung/protocol/openid-connect/certs 在这里，我们指定我们将使用 JWT 令牌进行授权。 jwk *-set-uri*属性指向包含公钥的 URI，以便我们的资源服务器可以验证令牌的完整性。 issuer-uri属性表示验证令牌颁发者（即授权服务器）的附加安全措施。但是，添加此属性还要求授权服务器应该在我们启动资源服务器应用程序之前运行。 接下来，让我们为 API 设置安全配置以保护端点： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.cors() .and() .authorizeRequests() .antMatchers(HttpMethod.GET, \u0026#34;/user/info\u0026#34;, \u0026#34;/api/foos/**\u0026#34;) .hasAuthority(\u0026#34;SCOPE_read\u0026#34;) .antMatchers(HttpMethod.POST, \u0026#34;/api/foos\u0026#34;) .hasAuthority(\u0026#34;SCOPE_write\u0026#34;) .anyRequest() .authenticated() .and() .oauth2ResourceServer() .jwt(); } } 正如我们所见，对于我们的 GET 方法，我们只允许具有读取范围的请求。对于 POST 方法，请求者除了read之外还需要有写权限。但是，对于任何其他端点，该请求应该只通过任何用户进行身份验证。 此外，**oauth2ResourceServer *()***方法指定这是一个资源服务器，带有*jwt()*格式的令牌。 这里要注意的另一点是使用方法*cors()*来允许请求上的 Access-Control 标头。这一点尤其重要，因为我们正在处理一个 Angular 客户端，并且我们的请求将来自另一个源 URL。 3.4. 模型和存储库 接下来，让我们为我们的模型Foo定义一个**javax.persistence.Entity： @Entity public class Foo { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; // constructor, getters and setters } 然后我们需要一个Foo的存储库。我们将使用 Spring 的PagingAndSortingRepository： public interface IFooRepository extends PagingAndSortingRepository\u0026lt;Foo, Long\u0026gt; { } 3.4. 服务与实施 之后，我们将为我们的 API 定义并实现一个简单的服务： public interface IFooService { Optional\u0026lt;Foo\u0026gt; findById(Long id); Foo save(Foo foo); Iterable\u0026lt;Foo\u0026gt; findAll(); } @Service public class FooServiceImpl implements IFooService { private IFooRepository fooRepository; public FooServiceImpl(IFooRepository fooRepository) { this.fooRepository = fooRepository; } @Override public Optional\u0026lt;Foo\u0026gt; findById(Long id) { return fooRepository.findById(id); } @Override public Foo save(Foo foo) { return fooRepository.save(foo); } @Override public Iterable\u0026lt;Foo\u0026gt; findAll() { return fooRepository.findAll(); } } 3.5. 示例控制器 现在让我们实现一个简单的控制器，通过 DTO公开我们的Foo资源： @RestController @RequestMapping(value = \u0026#34;/api/foos\u0026#34;) public class FooController { private IFooService fooService; public FooController(IFooService fooService) { this.fooService = fooService; } @CrossOrigin(origins = \u0026#34;http://localhost:8089\u0026#34;) @GetMapping(value = \u0026#34;/{id}\u0026#34;) public FooDto findOne(@PathVariable Long id) { Foo entity = fooService.findById(id) .orElseThrow(() -\u0026gt; new ResponseStatusException(HttpStatus.NOT_FOUND)); return convertToDto(entity); } @GetMapping public Collection\u0026lt;FooDto\u0026gt; findAll() { Iterable\u0026lt;Foo\u0026gt; foos = this.fooService.findAll(); List\u0026lt;FooDto\u0026gt; fooDtos = new ArrayList\u0026lt;\u0026gt;(); foos.forEach(p -\u0026gt; fooDtos.add(convertToDto(p))); return fooDtos; } protected FooDto convertToDto(Foo entity) { FooDto dto = new FooDto(entity.getId(), entity.getName()); return dto; } } 注意上面*@CrossOrigin*的使用；这是控制器级别的配置，我们需要允许来自我们的 Angular 应用程序的 CORS 在指定的 URL 上运行。 这是我们的FooDto： public class FooDto { private long id; private String name; } 4. 前端——设置 现在，我们将研究一个简单的客户端 Angular 前端实现，它将访问我们的 REST API。 我们将首先使用Angular CLI来生成和管理我们的前端模块。 首先，我们安装node 和 npm，因为 Angular CLI 是一个 npm 工具。 然后我们需要使用frontend-maven-plugin来使用 Maven 构建我们的 Angular 项目： \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.github.eirslett\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;frontend-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;nodeVersion\u0026gt;v6.10.2\u0026lt;/nodeVersion\u0026gt; \u0026lt;npmVersion\u0026gt;3.10.10\u0026lt;/npmVersion\u0026gt; \u0026lt;workingDirectory\u0026gt;src/main/resources\u0026lt;/workingDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;install node and npm\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;install-node-and-npm\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;npm install\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;npm\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;npm run build\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;npm\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;arguments\u0026gt;run build\u0026lt;/arguments\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 最后，使用 Angular CLI 生成一个新模块： ng new oauthApp 在下一节中，我们将讨论 Angular 应用程序逻辑。 5. 使用 Angular 的授权代码流 我们将在此处使用 OAuth2 授权代码流程。 我们的用例：客户端应用程序从授权服务器请求代码并显示登录页面。**一旦用户提供了他们的有效凭证并提交，授权服务器就会给我们代码。**然后前端客户端使用它来获取访问令牌。 5.1。家庭组件 让我们从我们的主要组件HomeComponent开始，所有动作都从这里开始： @Component({ selector: \u0026#39;home-header\u0026#39;, providers: [AppService], template: `\u0026lt;div class=\u0026#34;container\u0026#34; \u0026gt; \u0026lt;button *ngIf=\u0026#34;!isLoggedIn\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; (click)=\u0026#34;login()\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt; Login\u0026lt;/button\u0026gt; \u0026lt;div *ngIf=\u0026#34;isLoggedIn\u0026#34; class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Welcome !!\u0026lt;/span\u0026gt; \u0026lt;a class=\u0026#34;btn btn-default pull-right\u0026#34;(click)=\u0026#34;logout()\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;Logout\u0026lt;/a\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;foo-details\u0026gt;\u0026lt;/foo-details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;` }) export class HomeComponent { public isLoggedIn = false; constructor(private _service: AppService) { } ngOnInit() { this.isLoggedIn = this._service.checkCredentials(); let i = window.location.href.indexOf(\u0026#39;code\u0026#39;); if(!this.isLoggedIn \u0026amp;\u0026amp; i != -1) { this._service.retrieveToken(window.location.href.substring(i + 5)); } } login() { window.location.href = \u0026#39;http://localhost:8083/auth/realms/baeldung/protocol/openid-connect/auth? response_type=code\u0026amp;scope=openid%20write%20read\u0026amp;client_id=\u0026#39; + this._service.clientId + \u0026#39;\u0026amp;redirect_uri=\u0026#39;+ this._service.redirectUri; } logout() { this._service.logout(); } } 一开始，当用户没有登录时，只出现登录按钮。单击此按钮后，用户将导航到 AS 的授权 URL，他们在其中键入用户名和密码。成功登录后，用户将使用授权代码重定向回来，然后我们使用此代码检索访问令牌。 5.2. 应用服务 现在让我们看看*AppService——位于app.service.ts——*它包含服务器交互的逻辑：  retrieveToken()：使用授权码获取访问令牌 saveToken()：使用 ng2-cookies 库将我们的访问令牌保存在 cookie 中 getResource()：使用其 ID 从服务器获取 Foo 对象 checkCredentials() : 检查用户是否登录 logout()：删除访问令牌cookie并注销用户  export class Foo { constructor(public id: number, public name: string) { } } @Injectable() export class AppService { public clientId = \u0026#39;newClient\u0026#39;; public redirectUri = \u0026#39;http://localhost:8089/\u0026#39;; constructor(private _http: HttpClient) { } retrieveToken(code) { let params = new URLSearchParams(); params.append(\u0026#39;grant_type\u0026#39;,\u0026#39;authorization_code\u0026#39;); params.append(\u0026#39;client_id\u0026#39;, this.clientId); params.append(\u0026#39;client_secret\u0026#39;, \u0026#39;newClientSecret\u0026#39;); params.append(\u0026#39;redirect_uri\u0026#39;, this.redirectUri); params.append(\u0026#39;code\u0026#39;,code); let headers = new HttpHeaders({\u0026#39;Content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded; charset=utf-8\u0026#39;}); this._http.post(\u0026#39;http://localhost:8083/auth/realms/baeldung/protocol/openid-connect/token\u0026#39;, params.toString(), { headers: headers }) .subscribe( data =\u0026gt; this.saveToken(data), err =\u0026gt; alert(\u0026#39;Invalid Credentials\u0026#39;)); } saveToken(token) { var expireDate = new Date().getTime() + (1000 * token.expires_in); Cookie.set(\u0026#34;access_token\u0026#34;, token.access_token, expireDate); console.log(\u0026#39;Obtained Access token\u0026#39;); window.location.href = \u0026#39;http://localhost:8089\u0026#39;; } getResource(resourceUrl) : Observable\u0026lt;any\u0026gt; { var headers = new HttpHeaders({ \u0026#39;Content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded; charset=utf-8\u0026#39;, \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer \u0026#39;+Cookie.get(\u0026#39;access_token\u0026#39;)}); return this._http.get(resourceUrl, { headers: headers }) .catch((error:any) =\u0026gt; Observable.throw(error.json().error || \u0026#39;Server error\u0026#39;)); } checkCredentials() { return Cookie.check(\u0026#39;access_token\u0026#39;); } logout() { Cookie.delete(\u0026#39;access_token\u0026#39;); window.location.reload(); } } 在retrieveToken方法中，我们使用我们的客户端凭据和基本身份验证将POST发送到*/openid-connect/token*端点以获取访问令牌。参数以 URL 编码格式发送。获得访问令牌后，我们将其存储在 cookie 中。 cookie 存储在这里尤为重要，因为我们仅将 cookie 用于存储目的，而不是直接驱动身份验证过程。这有助于防止跨站点请求伪造 (CSRF) 攻击和漏洞。 5.3. Foo 组件 最后，我们的FooComponent来显示我们的 Foo 详细信息： @Component({ selector: \u0026#39;foo-details\u0026#39;, providers: [AppService], template: `\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;col-sm-12\u0026#34;\u0026gt;Foo Details\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;col-sm-12\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;col-sm-3\u0026#34;\u0026gt;ID\u0026lt;/label\u0026gt; \u0026lt;span\u0026gt;{{foo.id}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-12\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;col-sm-3\u0026#34;\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;span\u0026gt;{{foo.name}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-sm-12\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; (click)=\u0026#34;getFoo()\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;New Foo\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;` }) export class FooComponent { public foo = new Foo(1,\u0026#39;sample foo\u0026#39;); private foosUrl = \u0026#39;http://localhost:8081/resource-server/api/foos/\u0026#39;; constructor(private _service:AppService) {} getFoo() { this._service.getResource(this.foosUrl+this.foo.id) .subscribe( data =\u0026gt; this.foo = data, error =\u0026gt; this.foo.name = \u0026#39;Error\u0026#39;); } } 5.5. 应用组件 我们简单的AppComponent作为根组件： @Component({ selector: \u0026#39;app-root\u0026#39;, template: `\u0026lt;nav class=\u0026#34;navbar navbar-default\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;navbar-header\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;navbar-brand\u0026#34; href=\u0026#34;/\u0026#34;\u0026gt;Spring Security Oauth - Authorization Code\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt;` }) export class AppComponent { } 还有我们包装所有组件、服务和路由的AppModule ： @NgModule({ declarations: [ AppComponent, HomeComponent, FooComponent ], imports: [ BrowserModule, HttpClientModule, RouterModule.forRoot([ { path: \u0026#39;\u0026#39;, component: HomeComponent, pathMatch: \u0026#39;full\u0026#39; }], {onSameUrlNavigation: \u0026#39;reload\u0026#39;}) ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 7. 运行前端 \\1. 要运行我们的任何前端模块，我们需要先构建应用程序： mvn clean install \\2. 然后我们需要导航到我们的 Angular 应用目录： cd src/main/resources \\3. 最后，我们将启动我们的应用程序： npm start 服务器将默认在端口 4200 上启动；要更改任何模块的端口，请更改： \u0026#34;start\u0026#34;: \u0026#34;ng serve\u0026#34; 在*package.json 中；*例如，要使其在端口 8089 上运行，请添加： \u0026#34;start\u0026#34;: \u0026#34;ng serve --port 8089\u0026#34; 8. 结论 在本文中，我们学习了如何使用 OAuth2 授权我们的应用程序。 本教程的完整实现可以在GitHub 项目中找到。 ","permalink":"http://itcodingman.github.io/securing-a-restful-web-service-with-spring-security/","tags":null,"title":""},{"categories":null,"contents":"Spring 的安全性 正如您所期望的 那样，Spring Security教程 的重点是 Spring Security。 如果您有兴趣构建注册流程并了解一些框架基础知识，请从注册系列开始。 然后，深入探索身份验证和其他 Spring Security 内部。 最后，看看一些更高级的主题，例如 OAuth 支持。 向 Spring Security 注册  Spring Security 注册教程 使用 Spring Security 构建注册流程。  使用 Spring Security 进行身份验证  *Spring Security 表单登录* *Spring Security - 基本身份验证（流行）* *表单登录 - 错误处理和本地化* *登出* *登录后重定向到不同的页面* *记得我* *Spring Security 身份验证提供程序* *如何使用 Spring Security 手动验证用户身份* *Spring Security 的额外登录字段* *Spring Security 自定义 AuthenticationFailureHandler* *使用 Spring Security 防止暴力验证尝试* *带有 React 的 Spring Security 登录页面*  核心弹簧安全  *使用 Maven 的 Spring 安全性* *Spring Security 中检索用户信息 （流行）* *Spring 安全表达式简介* *Spring Security - 安全无，过滤器无，访问permitAll* *会话管理 （流行）* *Spring方法安全性介绍（普及）* *Spring Boot 安全自动配置* *Spring Security 5 中的默认密码编码器* *查找已注册的 Spring Security 过滤器* *使用 CORS Preflights 和 Spring Security 修复 401* *防止 Spring 应用程序中的跨站点脚本 (XSS)*  带有 Spring Security 的 OAuth2  Spring Security OAuth 2 指南 通过 Spring Security 了解 OAuth2，同时使用 Spring Security 5 堆栈以及 Spring Security OAuth 遗留堆栈。  其他 Spring 教程  REST with Spring 教程 如何使用 Spring 构建 REST 服务 Persistence with Spring Tutorial 如何使用 Spring 和 Hibernate、JPA、Spring Data 等构建应用程序的持久层 Spring Exceptions Tutorial Spring 中的常见异常以及示例——它们为什么会发生以及如何快速解决它们  ","permalink":"http://itcodingman.github.io/security-spring/","tags":null,"title":""},{"categories":null,"contents":"Spring 中的接线：@Autowired、@Resource 和 @Inject 一、概述 在本 Spring Framework 教程中，我们将演示如何使用与依赖注入相关的注解，即*@Resource*、@Inject和*@Autowired*注解。这些注解为类提供了一种声明性的方式来解决依赖关系： @Autowired ArbitraryClass arbObject; 与直接实例化它们相反（命令式）： ArbitraryClass arbObject = new ArbitraryClass(); 三个注解中有两个属于 Java 扩展包：javax.annotation.Resource和javax.inject.Inject。@Autowired注解属于org.springframework.beans.factory.annotation包。 这些注解中的每一个都可以通过字段注入或 setter 注入来解决依赖关系。我们将使用一个简化但实用的示例来演示三个注释之间的区别，基于每个注释所采用的执行路径。 示例将重点介绍如何在集成测试期间使用三个注入注解。测试所需的依赖可以是任意文件或任意类。 进一步阅读： Spring中的构造函数依赖注入 使用 Spring 快速实用地介绍基于构造函数的注入。 阅读更多→ Spring 控制反转和依赖注入简介 快速介绍控制反转和依赖注入的概念，然后使用 Spring 框架进行简单演示 阅读更多→ 在抽象类中使用 @Autowired 了解在抽象类和具体类上使用 @Autowired 的区别 阅读更多→ 2. @ ***Resource***注解 @Resource注释是JSR-250注释集合的一部分，并与 Jakarta EE 一起打包。此注解具有以下执行路径，按优先级列出：  按名称匹配 按类型匹配 按预选赛匹配  这些执行路径适用于 setter 和 field 注入。 2.1。现场注入 我们可以通过使用@Resource注释来注释实例变量来通过字段注入来解决依赖关系。 2.1.1。按名称匹配 我们将使用以下集成测试来演示按名称匹配字段注入： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceNameType.class) public class FieldResourceInjectionIntegrationTest { @Resource(name=\u0026#34;namedFile\u0026#34;) private File defaultFile; @Test public void givenResourceAnnotation_WhenOnField_ThenDependencyValid(){ assertNotNull(defaultFile); assertEquals(\u0026#34;namedFile.txt\u0026#34;, defaultFile.getName()); } } 让我们看一下代码。在FieldResourceInjectionTest集成测试中，在第 7 行，我们通过将 bean 名称作为属性值传递给*@Resource*注释来按名称解析依赖项： @Resource(name=\u0026#34;namedFile\u0026#34;) private File defaultFile; 此配置将使用按名称匹配执行路径解析依赖关系。我们必须在ApplicationContextTestResourceNameType应用程序上下文中定义 bean namedFile 。 注意 bean id 和对应的引用属性值必须匹配： @Configuration public class ApplicationContextTestResourceNameType { @Bean(name=\u0026#34;namedFile\u0026#34;) public File namedFile() { File namedFile = new File(\u0026#34;namedFile.txt\u0026#34;); return namedFile; } } 如果我们未能在应用程序上下文中定义 bean，它将导致org.springframework.beans.factory.NoSuchBeanDefinitionException被抛出。我们可以通过更改ApplicationContextTestResourceNameType应用程序上下文中传递给**@Bean注解的属性值，或者更改FieldResourceInjectionTest集成测试中传递给*@Resource*注解的属性值来证明这一点。 2.1.2. 按类型匹配 为了演示按类型匹配的执行路径，我们只删除FieldResourceInjectionTest集成测试第 7 行的属性值： @Resource private File defaultFile; 然后我们再次运行测试。 测试仍然会通过，因为如果*@Resource*注释没有接收到 bean 名称作为属性值，Spring 框架将继续进行下一级优先级，按类型匹配，以尝试解决依赖关系。 2.1.3。按预选赛匹配 为了演示 match-by-qualifier 执行路径，将修改集成测试场景，以便在ApplicationContextTestResourceQualifier应用程序上下文中定义两个 bean： @Configuration public class ApplicationContextTestResourceQualifier { @Bean(name=\u0026#34;defaultFile\u0026#34;) public File defaultFile() { File defaultFile = new File(\u0026#34;defaultFile.txt\u0026#34;); return defaultFile; } @Bean(name=\u0026#34;namedFile\u0026#34;) public File namedFile() { File namedFile = new File(\u0026#34;namedFile.txt\u0026#34;); return namedFile; } } 我们将使用QualifierResourceInjectionTest集成测试来演示逐个匹配的依赖关系解析。在这种情况下，需要将特定的 bean 依赖注入到每个引用变量中： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceQualifier.class) public class QualifierResourceInjectionIntegrationTest { @Resource private File dependency1; @Resource private File dependency2; @Test public void givenResourceAnnotation_WhenField_ThenDependency1Valid(){ assertNotNull(dependency1); assertEquals(\u0026#34;defaultFile.txt\u0026#34;, dependency1.getName()); } @Test public void givenResourceQualifier_WhenField_ThenDependency2Valid(){ assertNotNull(dependency2); assertEquals(\u0026#34;namedFile.txt\u0026#34;, dependency2.getName()); } } 当我们运行集成测试时，会抛出org.springframework.beans.factory.NoUniqueBeanDefinitionException 。**这会发生，因为应用程序上下文将找到两个类型为File的 bean 定义，并且不知道哪个 bean 应该解决依赖关系。 要解决这个问题，我们需要参考QualifierResourceInjectionTest集成测试的第 7 行到第 10 行： @Resource private File dependency1; @Resource private File dependency2; 我们必须添加以下代码行： @Qualifier(\u0026#34;defaultFile\u0026#34;) @Qualifier(\u0026#34;namedFile\u0026#34;) 使代码块如下所示： @Resource @Qualifier(\u0026#34;defaultFile\u0026#34;) private File dependency1; @Resource @Qualifier(\u0026#34;namedFile\u0026#34;) private File dependency2; 当我们再次运行集成测试时，它应该会通过。我们的测试表明，即使我们在应用程序上下文中定义了多个 bean，我们也可以使用*@Qualifier*注释通过允许我们将特定的依赖项注入到一个类中来消除任何混淆。 2.2. 二传手注入 在字段上注入依赖项时所采用的执行路径也适用于基于 setter 的注入。 2.2.1。按名称匹配 唯一的区别是MethodResourceInjectionTest集成测试有一个 setter 方法： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceNameType.class) public class MethodResourceInjectionIntegrationTest { private File defaultFile; @Resource(name=\u0026#34;namedFile\u0026#34;) protected void setDefaultFile(File defaultFile) { this.defaultFile = defaultFile; } @Test public void givenResourceAnnotation_WhenSetter_ThenDependencyValid(){ assertNotNull(defaultFile); assertEquals(\u0026#34;namedFile.txt\u0026#34;, defaultFile.getName()); } } 我们通过注解引用变量的相应 setter 方法，通过 setter 注入来解决依赖关系。然后我们将bean依赖的名称作为属性值传递给*@Resource*注解： private File defaultFile; @Resource(name=\u0026#34;namedFile\u0026#34;) protected void setDefaultFile(File defaultFile) { this.defaultFile = defaultFile; } 在本例中，我们将重用namedFile bean 依赖项。bean 名称和相应的属性值必须匹配。 当我们运行集成测试时，它将通过。 为了让我们验证按名称匹配执行路径是否解决了依赖关系，我们需要将传递给*@Resource注解的属性值更改为我们选择的值并再次运行测试。这一次，测试将失败并出现NoSuchBeanDefinitionException*。 2.2.2。按类型匹配 为了演示基于 setter、按类型匹配的执行，我们将使用MethodByTypeResourceTest集成测试： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceNameType.class) public class MethodByTypeResourceIntegrationTest { private File defaultFile; @Resource protected void setDefaultFile(File defaultFile) { this.defaultFile = defaultFile; } @Test public void givenResourceAnnotation_WhenSetter_ThenValidDependency(){ assertNotNull(defaultFile); assertEquals(\u0026#34;namedFile.txt\u0026#34;, defaultFile.getName()); } } 当我们运行这个测试时，它会通过。 为了让我们验证按类型匹配的执行路径是否解决了File依赖关系，我们需要将defaultFile变量的类类型更改为另一个类类型，如String。然后我们可以再次执行MethodByTypeResourceTest集成测试，这次会抛出NoSuchBeanDefinitionException 。 该异常验证是否确实使用了按类型匹配来解决文件依赖关系。NoSuchBeanDefinitionException确认引用变量名称不需要与 bean 名称匹配。相反，依赖解析取决于 bean 的类类型与引用变量的类类型匹配。 2.2.3。按预选赛匹配 我们将使用MethodByQualifierResourceTest集成测试来演示 match-by-qualifier 执行路径： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestResourceQualifier.class) public class MethodByQualifierResourceIntegrationTest { private File arbDependency; private File anotherArbDependency; @Test public void givenResourceQualifier_WhenSetter_ThenValidDependencies(){ assertNotNull(arbDependency); assertEquals(\u0026#34;namedFile.txt\u0026#34;, arbDependency.getName()); assertNotNull(anotherArbDependency); assertEquals(\u0026#34;defaultFile.txt\u0026#34;, anotherArbDependency.getName()); } @Resource @Qualifier(\u0026#34;namedFile\u0026#34;) public void setArbDependency(File arbDependency) { this.arbDependency = arbDependency; } @Resource @Qualifier(\u0026#34;defaultFile\u0026#34;) public void setAnotherArbDependency(File anotherArbDependency) { this.anotherArbDependency = anotherArbDependency; } } 我们的测试表明，即使我们在应用程序上下文中定义了特定类型的多个 bean 实现，我们也可以使用*@Qualifier注释和@Resource*注释来解决依赖关系。 类似于基于字段的依赖注入，如果我们在一个应用上下文中定义多个bean，我们必须使用 @Qualifier 注解来指定使用哪个bean来解析依赖，否则会抛出NoUniqueBeanDefinitionException 。 3. *@Inject*注解 @Inject注释属于JSR-330注释集合。此注解具有以下执行路径，按优先级列出：  按类型匹配 按预选赛匹配 按名称匹配  这些执行路径适用于 setter 和 field 注入。为了让我们访问*@Inject注解，我们必须将javax.inject*库声明为 Gradle 或 Maven 依赖项。 对于 Gradle： testCompile group: \u0026#39;javax.inject\u0026#39;, name: \u0026#39;javax.inject\u0026#39;, version: \u0026#39;1\u0026#39; 对于 Maven： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.inject\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.inject\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3.1。现场注入 3.1.1。按类型匹配 我们将修改集成测试示例以使用另一种类型的依赖项，即ArbitraryDependency类。ArbitraryDependency类依赖仅作为一个简单的依赖，并没有进一步的意义： @Component public class ArbitraryDependency { private final String label = \u0026#34;Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 这是有问题的FieldInjectTest集成测试： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestInjectType.class) public class FieldInjectIntegrationTest { @Inject private ArbitraryDependency fieldInjectDependency; @Test public void givenInjectAnnotation_WhenOnField_ThenValidDependency(){ assertNotNull(fieldInjectDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, fieldInjectDependency.toString()); } } 与*@Resource注解首先按名称解析依赖关系不同，@* Inject注解的默认行为是按类型解析依赖关系。 这意味着即使类引用变量名称与 bean 名称不同，依赖关系仍然会被解析，前提是 bean 是在应用程序上下文中定义的。请注意以下测试中引用变量名称的方式： @Inject private ArbitraryDependency fieldInjectDependency; 与应用程序上下文中配置的 bean 名称不同： @Bean public ArbitraryDependency injectDependency() { ArbitraryDependency injectDependency = new ArbitraryDependency(); return injectDependency; } 当我们执行测试时，我们能够解决依赖关系。 3.1.2。按预选赛匹配 如果一个特定的类类型有多个实现，并且某个类需要一个特定的 bean，该怎么办？让我们修改集成测试示例，使其需要另一个依赖项。 在此示例中，我们将ArbitraryDependency类（在按类型匹配示例中使用）进行子类化，以创建AnotherArbitraryDependency类： public class AnotherArbitraryDependency extends ArbitraryDependency { private final String label = \u0026#34;Another Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 每个测试用例的目标是确保我们将每个依赖项正确地注入每个引用变量中： @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; 我们可以使用FieldQualifierInjectTest集成测试来演示限定符匹配： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestInjectQualifier.class) public class FieldQualifierInjectIntegrationTest { @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; @Test public void givenInjectQualifier_WhenOnField_ThenDefaultFileValid(){ assertNotNull(defaultDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, defaultDependency.toString()); } @Test public void givenInjectQualifier_WhenOnField_ThenNamedFileValid(){ assertNotNull(defaultDependency); assertEquals(\u0026#34;Another Arbitrary Dependency\u0026#34;, namedDependency.toString()); } } 如果我们在应用程序上下文中有多个特定类的实现，并且FieldQualifierInjectTest集成测试尝试以下面列出的方式注入依赖项，则会抛出NoUniqueBeanDefinitionException ： @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; 抛出这个异常是 Spring 框架指出某个类有多个实现的方式，它对使用哪一个感到困惑。为了阐明混淆，我们可以转到FieldQualifierInjectTest集成测试的第 7 行和第 10 行： @Inject private ArbitraryDependency defaultDependency; @Inject private ArbitraryDependency namedDependency; 我们可以将所需的 bean 名称传递给*@Qualifier注释，我们将其与@Inject*注释一起使用。这就是代码块现在的样子： @Inject @Qualifier(\u0026#34;defaultFile\u0026#34;) private ArbitraryDependency defaultDependency; @Inject @Qualifier(\u0026#34;namedFile\u0026#34;) private ArbitraryDependency namedDependency; @Qualifier注解在接收 bean 名称时要求严格匹配。我们必须确保将 bean 名称正确传递给Qualifier，否则将抛出*NoUniqueBeanDefinitionException 。*如果我们再次运行测试，它应该会通过。 3.1.3. 按名称匹配 用于演示按名称匹配的FieldByNameInjectTest集成测试类似于按类型匹配执行路径。唯一的区别是现在我们需要一个特定的 bean，而不是一个特定的类型。在此示例中，我们再次对ArbitraryDependency类进行子类化以生成YetAnotherArbitraryDependency类： public class YetAnotherArbitraryDependency extends ArbitraryDependency { private final String label = \u0026#34;Yet Another Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 为了演示按名称匹配的执行路径，我们将使用以下集成测试： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestInjectName.class) public class FieldByNameInjectIntegrationTest { @Inject @Named(\u0026#34;yetAnotherFieldInjectDependency\u0026#34;) private ArbitraryDependency yetAnotherFieldInjectDependency; @Test public void givenInjectQualifier_WhenSetOnField_ThenDependencyValid(){ assertNotNull(yetAnotherFieldInjectDependency); assertEquals(\u0026#34;Yet Another Arbitrary Dependency\u0026#34;, yetAnotherFieldInjectDependency.toString()); } } 我们列出应用程序上下文： @Configuration public class ApplicationContextTestInjectName { @Bean public ArbitraryDependency yetAnotherFieldInjectDependency() { ArbitraryDependency yetAnotherFieldInjectDependency = new YetAnotherArbitraryDependency(); return yetAnotherFieldInjectDependency; } } 如果我们运行集成测试，它将通过。 为了验证我们是否通过按名称匹配执行路径注入了依赖项，我们需要将传入*@Named注释的值**yetAnotherFieldInjectDependency更改为我们选择的另一个名称。当我们再次运行测试时，会抛出NoSuchBeanDefinitionException 。* 3.2. 二传手注入 @Inject注解的基于设置器的注入类似于用于基于*@Resource*设置器的注入的方法。我们不是注释引用变量，而是注释相应的 setter 方法。基于字段的依赖注入所遵循的执行路径也适用于基于 setter 的注入。 4. *@Autowired*注解 @Autowired注解的行为类似于*@Inject注解。唯一的区别是@Autowired*注解是 Spring 框架的一部分。此注解与@Inject注解具有相同的执行路径，按优先顺序列出：  按类型匹配 按预选赛匹配 按名称匹配  这些执行路径适用于 setter 和 field 注入。 4.1。现场注入 4.1.1。按类型匹配 用于演示*@Autowired按类型匹配执行路径的集成测试示例将类似于用于演示@Inject按类型匹配执行路径的测试。我们使用以下FieldAutowiredTest集成测试来演示使用@Autowired*注释的按类型匹配： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestAutowiredType.class) public class FieldAutowiredIntegrationTest { @Autowired private ArbitraryDependency fieldDependency; @Test public void givenAutowired_WhenSetOnField_ThenDependencyResolved() { assertNotNull(fieldDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, fieldDependency.toString()); } } 我们列出了此集成测试的应用程序上下文： @Configuration public class ApplicationContextTestAutowiredType { @Bean public ArbitraryDependency autowiredFieldDependency() { ArbitraryDependency autowiredFieldDependency = new ArbitraryDependency(); return autowiredFieldDependency; } } 我们使用此集成测试来证明按类型匹配优先于其他执行路径。注意FieldAutowiredTest集成测试第 8 行的引用变量名称： @Autowired private ArbitraryDependency fieldDependency; 这与应用程序上下文中的 bean 名称不同： @Bean public ArbitraryDependency autowiredFieldDependency() { ArbitraryDependency autowiredFieldDependency = new ArbitraryDependency(); return autowiredFieldDependency; } 当我们运行测试时，它应该通过了。 为了确认依赖确实是使用 match-by-type 执行路径解决的，我们需要更改fieldDependency引用变量的类型并再次运行集成测试。这一次，FieldAutowiredTest集成测试将失败，并引发NoSuchBeanDefinitionException。这验证了我们使用了按类型匹配来解决依赖关系。 4.1.2. 按预选赛匹配 如果我们遇到在应用程序上下文中定义了多个 bean 实现的情况怎么办： @Configuration public class ApplicationContextTestAutowiredQualifier { @Bean public ArbitraryDependency autowiredFieldDependency() { ArbitraryDependency autowiredFieldDependency = new ArbitraryDependency(); return autowiredFieldDependency; } @Bean public ArbitraryDependency anotherAutowiredFieldDependency() { ArbitraryDependency anotherAutowiredFieldDependency = new AnotherArbitraryDependency(); return anotherAutowiredFieldDependency; } } 如果我们执行以下FieldQualifierAutowiredTest集成测试，将抛出NoUniqueBeanDefinitionException ： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestAutowiredQualifier.class) public class FieldQualifierAutowiredIntegrationTest { @Autowired private ArbitraryDependency fieldDependency1; @Autowired private ArbitraryDependency fieldDependency2; @Test public void givenAutowiredQualifier_WhenOnField_ThenDep1Valid(){ assertNotNull(fieldDependency1); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, fieldDependency1.toString()); } @Test public void givenAutowiredQualifier_WhenOnField_ThenDep2Valid(){ assertNotNull(fieldDependency2); assertEquals(\u0026#34;Another Arbitrary Dependency\u0026#34;, fieldDependency2.toString()); } } 异常是由于应用程序上下文中定义的两个 bean 引起的歧义。Spring 框架不知道哪个 bean 依赖项应该自动装配到哪个引用变量。我们可以通过在FieldQualifierAutowiredTest集成测试的第 7 行和第 10 行添加*@Qualifier*注释来解决此问题： @Autowired private FieldDependency fieldDependency1; @Autowired private FieldDependency fieldDependency2; 使代码块如下所示： @Autowired @Qualifier(\u0026#34;autowiredFieldDependency\u0026#34;) private FieldDependency fieldDependency1; @Autowired @Qualifier(\u0026#34;anotherAutowiredFieldDependency\u0026#34;) private FieldDependency fieldDependency2; 当我们再次运行测试时，它将通过。 4.1.3。按名称匹配 我们将使用相同的集成测试场景来演示使用@Autowired注释注入字段依赖项的按名称匹配执行路径。当按名称自动装配依赖项时，@ComponentScan注释必须与应用程序上下文ApplicationContextTestAutowiredName一起使用： @Configuration @ComponentScan(basePackages={\u0026#34;com.codingman.dependency\u0026#34;}) public class ApplicationContextTestAutowiredName { } 我们使用*@ComponentScan注解在包中搜索已使用@Component 注解进行注解的Java类*。例如，在应用程序上下文中，将扫描com.codingman.dependency包以查找已使用*@Component注释进行注释的类。在这种情况下，Spring 框架必须检测带有@Component注解的ArbitraryDependency*类： @Component(value=\u0026#34;autowiredFieldDependency\u0026#34;) public class ArbitraryDependency { private final String label = \u0026#34;Arbitrary Dependency\u0026#34;; public String toString() { return label; } } 传递到*@Component注释的属性值autowiredFieldDependency告诉 Spring 框架ArbitraryDependency类是一个名为autowiredFieldDependency的组件。为了让@Autowired注解通过名称解析依赖，组件名称必须与FieldAutowiredNameTest*集成测试中定义的字段名称相对应；请参考第8行： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( loader=AnnotationConfigContextLoader.class, classes=ApplicationContextTestAutowiredName.class) public class FieldAutowiredNameIntegrationTest { @Autowired private ArbitraryDependency autowiredFieldDependency; @Test public void givenAutowiredAnnotation_WhenOnField_ThenDepValid(){ assertNotNull(autowiredFieldDependency); assertEquals(\u0026#34;Arbitrary Dependency\u0026#34;, autowiredFieldDependency.toString()); } } 当我们运行FieldAutowiredNameTest集成测试时，它将通过。 但是我们怎么知道*@Autowired注解确实调用了按名称匹配的执行路径呢？我们可以将引用变量autowiredFieldDependency*的名称更改为我们选择的另一个名称，然后再次运行测试。 这一次，测试将失败并抛出NoUniqueBeanDefinitionException。类似的检查是将*@Component属性值autowiredFieldDependency更改为我们选择的另一个值并再次运行测试。NoUniqueBeanDefinitionException也会*被抛出。 这个异常证明如果我们使用不正确的 bean 名称，将找不到有效的 bean。这就是我们知道调用了按名称匹配执行路径的方式。 4.2. 二传手注入 @Autowired注解的基于设置器的注入类似于为基于*@Resource*设置器的注入演示的方法。我们不是用@Inject注解来注解引用变量，而是注解对应的setter。基于字段的依赖注入所遵循的执行路径也适用于基于 setter 的注入。 5. 应用这些注释 这就提出了应该使用哪种注释以及在什么情况下使用的问题。这些问题的答案取决于相关应用程序面临的设计场景，以及开发人员希望如何利用基于每个注释的默认执行路径的多态性。 5.1。通过多态性在应用程序范围内使用单例 如果设计是这样的应用程序行为基于接口或抽象类的实现，并且这些行为在整个应用程序中使用，那么我们可以使用*@Inject或@Autowired*注解。 这种方法的好处是，当我们升级应用程序或应用补丁来修复错误时，可以将类换出，而对整体应用程序行为的负面影响最小。在这种情况下，主要的默认执行路径是按类型匹配。 5.2. 通过多态进行细粒度的应用程序行为配置 如果设计使得应用程序具有复杂的行为，每个行为都基于不同的接口/抽象类，并且这些实现中的每一个的使用因应用程序而异，那么我们可以使用*@Resource*注解。在这种情况下，主要的默认执行路径是按名称匹配。 5.3. 依赖注入应该由 Jakarta EE 平台单独处理 如果 Jakarta EE 平台而不是 Spring 注入所有依赖项的设计要求，那么选择是在*@Resource注释和@Inject*注释之间进行选择。我们应该根据需要哪个默认执行路径来缩小两个注释之间的最终决定。 5.4. 依赖注入应该由 Spring 框架单独处理 如果要求所有依赖项都由 Spring 框架处理，则唯一的选择是*@Autowired*注释。 5.5. 讨论总结 下表总结了我们的讨论。    设想 @资源 @注入 @自动连线     通过多态性在应用程序范围内使用单例 ✗ ✔ ✔   通过多态进行细粒度的应用程序行为配置 ✔ ✗ ✗   依赖注入应该由 Jakarta EE 平台单独处理 ✔ ✔ ✗   依赖注入应该由 Spring Framework 单独处理 ✗ ✗ ✔    六，结论 在本文中，我们旨在更深入地了解每个注释的行为。了解每个注释的行为方式将有助于更好的整体应用程序设计和维护。 讨论期间使用的代码可以在GitHub上找到。 ","permalink":"http://itcodingman.github.io/spring-annotations-resource-inject-autowire/","tags":null,"title":""},{"categories":null,"contents":"Spring @Autowired 指南 一、概述 从 Spring 2.5 开始，该框架引入了注解驱动的依赖注入。此功能的主要注释是*@Autowired* 。 它允许 Spring 解析协作 bean 并将其注入到我们的 bean 中。 进一步阅读： Spring 组件扫描 了解 Spring 组件扫描背后的机制，以及如何根据自己的需要对其进行调整 阅读更多→ Spring 控制反转和依赖注入简介 快速介绍控制反转和依赖注入的概念，然后使用 Spring 框架进行简单演示 阅读更多→ 在本教程中，我们将首先了解如何启用自动装配以及自动装配 bean 的 各种 方法。之后，我们将讨论使用***@Qualifier*注解解决 bean 冲突**，以及潜在的异常情况。 2. 启用*@Autowired*注解 Spring 框架支持自动依赖注入。换句话说，通过在 Spring 配置文件中声明所有 bean 依赖项，Spring 容器可以自动装配协作 bean 之间的关系。这称为*Spring bean 自动装配*。 要在我们的应用程序中使用基于 Java 的配置，让我们启用注解驱动注入 来加载我们的 Spring 配置： @Configuration @ComponentScan(\u0026#34;com.codingman.autowire.sample\u0026#34;) public class AppConfig {} 或者，[**注解](/spring-contextannotation-contextcomponentscan#:~:text=The can resolve.)主要用于激活 Spring XML 文件中的依赖注入注解。 此外，Spring Boot 引入了*@SpringBootApplication*注解。此单个注释等效于使用*@Configuration*、@EnableAutoConfiguration和 @ComponentScan。 让我们在应用程序的主类中使用这个注解： @SpringBootApplication class VehicleFactoryApplication { public static void main(String[] args) { SpringApplication.run(VehicleFactoryApplication.class, args); } } 因此，当我们运行这个 Spring Boot 应用程序时，它会自动扫描当前包及其子包中的组件。因此它将在 Spring 的应用程序上下文中注册它们，并允许我们使用*@Autowired*注入 bean 。 3. 使用*@Autowired* 启用注解注入后，我们可以对属性、设置器和构造器使用自动装配。 3.1。*@Autowired*属性 让我们看看如何使用*@Autowired*注释属性。这消除了对 getter 和 setter 的需要。 首先，让我们定义一个fooFormatter bean： @Component(\u0026#34;fooFormatter\u0026#34;) public class FooFormatter { public String format() { return \u0026#34;foo\u0026#34;; } } 然后，我们将在字段定义上使用*@Autowired将此 bean 注入FooService bean：* @Component public class FooService { @Autowired private FooFormatter fooFormatter; } 因此，Spring在创建FooService时会注入fooFormatter。 3.2. 设置器上的*@Autowired* 现在让我们尝试在 setter 方法上添加*@Autowired注解。* 在以下示例中，在创建FooService时使用 FooFormatter的实例调用 setter 方法： public class FooService { private FooFormatter fooFormatter; @Autowired public void setFooFormatter(FooFormatter fooFormatter) { this.fooFormatter = fooFormatter; } } 3.3. *@Autowired*在构造函数上 最后，让我们在构造函数上使用*@Autowired*。 我们将看到Spring 将 FooFormatter 的实例作为FooService**构造函数的参数注入： public class FooService { private FooFormatter fooFormatter; @Autowired public FooService(FooFormatter fooFormatter) { this.fooFormatter = fooFormatter; } } 4. @Autowired和可选依赖 构建 bean 时，@Autowired依赖项应该可用。否则，如果 Spring 无法解析 bean 进行布线，它将抛出异常。 因此，它会阻止 Spring 容器成功启动，但以下形式除外： Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.autowire.sample.FooDAO] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} 为了解决这个问题，我们需要声明一个所需类型的 bean： public class FooService { @Autowired(required = false) private FooDAO dataAccessor; } 5. Autowire消歧 默认情况下，Spring 按类型解析*@Autowired*条目。如果容器中有多个相同类型的 bean 可用，框架将抛出一个致命异常。 为了解决这个冲突，我们需要明确地告诉 Spring 我们要注入哪个 bean。 5.1。*@Qualifier*自动装配 例如，让我们看看如何使用@Qualifier注解来指示所需的 bean。 首先，我们将定义 2 个Formatter类型的 bean ： @Component(\u0026#34;fooFormatter\u0026#34;) public class FooFormatter implements Formatter { public String format() { return \u0026#34;foo\u0026#34;; } } @Component(\u0026#34;barFormatter\u0026#34;) public class BarFormatter implements Formatter { public String format() { return \u0026#34;bar\u0026#34;; } } 现在让我们尝试将Formatter bean 注入FooService类： public class FooService { @Autowired private Formatter formatter; } 在我们的示例中，有两个可用于 Spring 容器的Formatter的具体实现。因此， Spring 在构造*FooService**时会抛出*NoUniqueBeanDefinitionException*异常： * Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [com.autowire.sample.Formatter] is defined: expected single matching bean but found 2: barFormatter,fooFormatter 我们可以通过使用*@Qualifier*注解缩小实现范围来避免这种情况： public class FooService { @Autowired @Qualifier(\u0026#34;fooFormatter\u0026#34;) private Formatter formatter; } 当有多个相同类型的 bean 时，最好使用*@Qualifier*来避免歧义。 请注意，@Qualifier 注释的值与我们的 FooFormatter**实现的*@Component*注释中声明的名称匹配。 5.2. 通过自定义限定符自动装配 Spring 还允许我们创建自己的自定义*@Qualifier*注释。为此，我们应该提供带有定义的*@Qualifier*注释： @Qualifier @Target({ ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) public @interface FormatterType { String value(); } 然后我们可以在各种实现中使用FormatterType 来指定自定义值： @FormatterType(\u0026#34;Foo\u0026#34;) @Component public class FooFormatter implements Formatter { public String format() { return \u0026#34;foo\u0026#34;; } } @FormatterType(\u0026#34;Bar\u0026#34;) @Component public class BarFormatter implements Formatter { public String format() { return \u0026#34;bar\u0026#34;; } } 最后，我们的自定义 Qualifier 注解已准备好用于自动装配： @Component public class FooService { @Autowired @FormatterType(\u0026#34;Foo\u0026#34;) private Formatter formatter; } *@Target*元注释中指定的值限制了应用限定符的位置，在我们的示例中是字段、方法、类型和参数。 5.3. 按名称自动装配 **Spring 使用 bean 的名称作为默认限定符值。**它将检查容器并查找具有确切名称的 bean 作为属性来自动装配它。 因此，在我们的示例中，Spring 将fooFormatter属性名称与FooFormatter实现相匹配。因此，它在构造FooService时注入了该特定实现： public class FooService { @Autowired private Formatter fooFormatter; } 六，结论 在本文中，我们讨论了自动装配以及使用它的不同方式。我们还研究了解决由丢失 bean 或不明确 bean 注入引起的两种常见自动装配异常的方法。 本文的源代码可在GitHub 项目上找到。 ","permalink":"http://itcodingman.github.io/spring-autowire/","tags":null,"title":""},{"categories":null,"contents":"Spring Bean 注解 一、概述 在本教程中，我们将讨论用于定义不同类型bean的最常见的 Spring bean 注释。 有几种方法可以在 Spring 容器中配置 bean。首先，我们可以使用 XML 配置声明它们。我们还可以在配置类中使用*@Bean注解来声明 bean。* 最后，我们可以使用org.springframework.stereotype包中的注释之一标记该类，并将其余部分留给组件扫描。 2. 组件扫描 如果启用了组件扫描，Spring 可以自动扫描包中的 bean。 @ComponentScan配置要扫描哪些包以查找具有注释配置的类。我们可以使用basePackages或value参数之一直接指定基本包名称（ value是basePackages的别名）： @Configuration @ComponentScan(basePackages = \u0026#34;com.codingman.annotations\u0026#34;) class VehicleFactoryConfig {} 此外，我们可以使用basePackageClasses参数指向基础包中的类： @Configuration @ComponentScan(basePackageClasses = VehicleFactoryConfig.class) class VehicleFactoryConfig {} 这两个参数都是数组，因此我们可以为每个参数提供多个包。 如果未指定参数，则扫描从存在*@ComponentScan*注释类的同一包中进行。 @ComponentScan利用了 Java 8 的重复注解特性，这意味着我们可以用它多次标记一个类： @Configuration @ComponentScan(basePackages = \u0026#34;com.codingman.annotations\u0026#34;) @ComponentScan(basePackageClasses = VehicleFactoryConfig.class) class VehicleFactoryConfig {} 或者，我们可以使用*@ComponentScans指定多个@ComponentScan*配置： @Configuration @ComponentScans({ @ComponentScan(basePackages = \u0026#34;com.codingman.annotations\u0026#34;), @ComponentScan(basePackageClasses = VehicleFactoryConfig.class) }) class VehicleFactoryConfig {} 使用XML 配置时，配置组件扫描同样简单： \u0026lt;context:component-scan base-package=\u0026#34;com.codingman\u0026#34; /\u0026gt; 3. *@组件* @Component是一个类级别的注解。在组件扫描期间，Spring Framework 会自动检测带有*@Component 注释的类：* @Component class CarUtility { // ... } 默认情况下，此类的 bean 实例与具有小写首字母的类名称具有相同的名称。此外，我们可以使用此注解的可选值参数指定不同的名称。 由于*@Repository*、@Service、@Configuration和*@Controller都是@Component*的元注释，它们共享相同的 bean 命名行为。Spring 还会在组件扫描过程中自动拾取它们。 4. *@存储库* DAO 或 Repository 类通常代表应用程序中的数据库访问层，应使用*@Repository 进行注释：* @Repository class VehicleRepository { // ... } 使用此注释的一个优点是它启用了自动持久性异常转换。当使用持久性框架（例如 Hibernate）时，在带有*@Repository注释的类中抛出的本机异常将自动转换为 Spring 的DataAccessExeption*的子类。 要启用异常翻译，我们需要声明我们自己的PersistenceExceptionTranslationPostProcessor bean： @Bean public PersistenceExceptionTranslationPostProcessor exceptionTranslation() { return new PersistenceExceptionTranslationPostProcessor(); } 请注意，在大多数情况下，Spring 会自动执行上述步骤。 或者通过 XML 配置： \u0026lt;bean class= \u0026#34;org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\u0026#34;/\u0026gt; 5. *@服务* 应用程序的业务逻辑通常驻留在服务层中，因此我们将使用*@Service* 注解来指示一个类属于该层： @Service public class VehicleService { // ... } 6. *@控制器* @Controller是一个类级别的注解，它告诉 Spring Framework 这个类作为Spring MVC 中的一个控制器： @Controller public class VehicleController { // ... } 7. @配置 配置类可以包含使用*@Bean*注释的bean 定义方法： @Configuration class VehicleFactoryConfig { @Bean Engine engine() { return new Engine(); } } 8. 刻板印象注释和 AOP 当我们使用 Spring 原型注解时，很容易创建一个指向所有具有特定原型的类的切入点。 例如，假设我们想从 DAO 层测量方法的执行时间。我们将利用*@Repository*原型创建以下方面（使用AspectJ 注释）： @Aspect @Component public class PerformanceAspect { @Pointcut(\u0026#34;within(@org.springframework.stereotype.Repository *)\u0026#34;) public void repositoryClassMethods() {}; @Around(\u0026#34;repositoryClassMethods()\u0026#34;) public Object measureMethodExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.nanoTime(); Object returnValue = joinPoint.proceed(); long end = System.nanoTime(); String methodName = joinPoint.getSignature().getName(); System.out.println( \u0026#34;Execution of \u0026#34; + methodName + \u0026#34; took \u0026#34; + TimeUnit.NANOSECONDS.toMillis(end - start) + \u0026#34; ms\u0026#34;); return returnValue; } } 在此示例中，我们创建了一个切入点，该切入点匹配使用*@Repository注释的类中的所有方法。然后我们使用@Around*通知来定位那个切入点，并确定被拦截方法调用的执行时间。 此外，使用这种方法，我们可以将日志记录、性能管理、审计和其他行为添加到每个应用程序层。 9. 结论 在本文中，我们检查了 Spring 原型注解并讨论了它们各自代表的语义类型。 我们还学习了如何使用组件扫描来告诉容器在哪里可以找到带注释的类。 最后，我们了解了这些注释如何导致一个干净的、分层的设计以及应用程序的关注点之间的分离。它们还使配置更小，因为我们不再需要手动显式定义 bean。 像往常一样，这些示例可以在 GitHub 上找到。 ","permalink":"http://itcodingman.github.io/spring-bean-annotations/","tags":null,"title":""},{"categories":null,"contents":"Spring Bean 范围快速指南 一、概述 在这个快速教程中，我们将了解 Spring 框架中不同类型的 bean 作用域。 bean 的范围定义了该 bean 在我们使用它的上下文中的生命周期和可见性。 最新版本的 Spring 框架定义了 6 种作用域：  单身人士 原型 要求 会议 应用 网络套接字  最后提到的四个范围，request、session、application和websocket，仅在 web 感知应用程序中可用。 进一步阅读： 什么是 Spring Bean？ 关于 Spring Bean 是什么的快速实用的解释。 阅读更多→ Spring Bean 注解 了解如何以及何时使用标准 Spring bean 注释 - @Component、@Repository、@Service 和 @Controller。 阅读更多→ 2. 单例范围 当我们使用单例范围定义 bean 时，容器会创建该 bean 的单个实例；对该 bean 名称的所有请求都将返回相同的对象，该对象被缓存。对对象的任何修改都将反映在对 bean 的所有引用中。如果未指定其他范围，则此范围是默认值。 让我们创建一个Person实体来举例说明作用域的概念： public class Person { private String name; // standard constructor, getters and setters } 之后，我们使用*@Scope注释定义具有单例*范围的 bean： @Bean @Scope(\u0026#34;singleton\u0026#34;) public Person personSingleton() { return new Person(); } 我们还可以通过以下方式使用常量而不是String值： @Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON) 现在我们可以继续编写一个测试，表明引用同一个 bean 的两个对象将具有相同的值，即使它们中只有一个改变了它们的状态，因为它们都引用了同一个 bean 实例： private static final String NAME = \u0026#34;John Smith\u0026#34;; @Test public void givenSingletonScope_whenSetName_thenEqualNames() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;scopes.xml\u0026#34;); Person personSingletonA = (Person) applicationContext.getBean(\u0026#34;personSingleton\u0026#34;); Person personSingletonB = (Person) applicationContext.getBean(\u0026#34;personSingleton\u0026#34;); personSingletonA.setName(NAME); Assert.assertEquals(NAME, personSingletonB.getName()); ((AbstractApplicationContext) applicationContext).close(); } 此示例中的scopes.xml文件应包含所用 bean 的 xml 定义： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;personSingleton\u0026#34; class=\u0026#34;com.codingman.scopes.Person\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 3.原型范围 每次从容器请求时，具有原型作用域的 bean都会返回不同的实例。它是通过将值原型设置为 bean 定义中的*@Scope*注解来定义的： @Bean @Scope(\u0026#34;prototype\u0026#34;) public Person personPrototype() { return new Person(); } 我们也可以像在单例作用域中那样使用常量： @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) 我们现在将编写一个与之前类似的测试，显示两个对象在 原型 范围内请求相同的 bean 名称。它们将具有不同的状态，因为它们不再引用同一个 bean 实例： private static final String NAME = \u0026#34;John Smith\u0026#34;; private static final String NAME_OTHER = \u0026#34;Anna Jones\u0026#34;; @Test public void givenPrototypeScope_whenSetNames_thenDifferentNames() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;scopes.xml\u0026#34;); Person personPrototypeA = (Person) applicationContext.getBean(\u0026#34;personPrototype\u0026#34;); Person personPrototypeB = (Person) applicationContext.getBean(\u0026#34;personPrototype\u0026#34;); personPrototypeA.setName(NAME); personPrototypeB.setName(NAME_OTHER); Assert.assertEquals(NAME, personPrototypeA.getName()); Assert.assertEquals(NAME_OTHER, personPrototypeB.getName()); ((AbstractApplicationContext) applicationContext).close(); } scopes.xml文件类似于上一节中介绍的文件，同时为具有原型作用域的 bean 添加xml定义： \u0026lt;bean id=\u0026#34;personPrototype\u0026#34; class=\u0026#34;com.codingman.scopes.Person\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 4. Web 感知范围 如前所述，有四个附加范围仅在 Web 感知应用程序上下文中可用。我们在实践中较少使用这些。 请求范围为单个 HTTP 请求创建一个 bean 实例，而 s会话范围为一个 HTTP 会话创建一个 bean 实例。 应用程序范围为ServletContext的生命周期创建 bean 实例，而websocket范围为特定的WebSocket会话创建它。 让我们创建一个用于实例化 bean 的类： public class HelloMessageGenerator { private String message; // standard getter and setter } 4.1。请求范围 我们可以使用*@Scope注释定义具有请求*范围的 bean： @Bean @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator requestScopedBean() { return new HelloMessageGenerator(); } proxyMode属性是必要的*，*因为在 Web 应用程序上下文的实例化时刻，没有活动请求。Spring 创建一个代理作为依赖注入，并在请求中需要它时实例化目标 bean。 我们还可以使用*@RequestScope*组合注释作为上述定义的快捷方式： @Bean @RequestScope public HelloMessageGenerator requestScopedBean() { return new HelloMessageGenerator(); } 接下来，我们可以定义一个控制器，该控制器具有对requestScopedBean的注入引用。我们需要访问同一个请求两次以测试 Web 特定范围。 如果我们在每次运行请求时都显示该消息，我们可以看到该值被重置为**null，即使它后来在方法中被更改。这是因为每个请求都返回了不同的 bean 实例。 @Controller public class ScopesController { @Resource(name = \u0026#34;requestScopedBean\u0026#34;) HelloMessageGenerator requestScopedBean; @RequestMapping(\u0026#34;/scopes/request\u0026#34;) public String getRequestScopeMessage(final Model model) { model.addAttribute(\u0026#34;previousMessage\u0026#34;, requestScopedBean.getMessage()); requestScopedBean.setMessage(\u0026#34;Good morning!\u0026#34;); model.addAttribute(\u0026#34;currentMessage\u0026#34;, requestScopedBean.getMessage()); return \u0026#34;scopesExample\u0026#34;; } } 4.2. 会话范围 我们可以用类似的方式定义具有会话范围的 bean： @Bean @Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator sessionScopedBean() { return new HelloMessageGenerator(); } 还有一个专用的组合注释，我们可以使用它来简化 bean 定义： @Bean @SessionScope public HelloMessageGenerator sessionScopedBean() { return new HelloMessageGenerator(); } 接下来我们定义一个引用sessionScopedBean的控制器。同样，我们需要运行两个请求以显示消息字段的值对于会话是相同的。 在这种情况下，当第一次发出请求时，值消息为*空。*但是，一旦更改，该值将保留给后续请求，因为为整个会话返回相同的 bean 实例。 @Controller public class ScopesController { @Resource(name = \u0026#34;sessionScopedBean\u0026#34;) HelloMessageGenerator sessionScopedBean; @RequestMapping(\u0026#34;/scopes/session\u0026#34;) public String getSessionScopeMessage(final Model model) { model.addAttribute(\u0026#34;previousMessage\u0026#34;, sessionScopedBean.getMessage()); sessionScopedBean.setMessage(\u0026#34;Good afternoon!\u0026#34;); model.addAttribute(\u0026#34;currentMessage\u0026#34;, sessionScopedBean.getMessage()); return \u0026#34;scopesExample\u0026#34;; } } 4.3. 适用范围 应用程序范围为ServletContext的生命周期创建 bean 实例。 这类似于单例范围，但在 bean 的范围方面有一个非常重要的区别。 当 bean 是应用程序作用域时，bean 的同一个实例在同一个**ServletContext中运行的多个基于 servlet 的应用程序之间共享，而单例作用域 bean 的作用域仅限于单个应用程序上下文。 让我们创建具有应用程序范围的 bean ： @Bean @Scope( value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator applicationScopedBean() { return new HelloMessageGenerator(); } 类似于请求和会话范围，我们可以使用更短的版本： @Bean @ApplicationScope public HelloMessageGenerator applicationScopedBean() { return new HelloMessageGenerator(); } 现在让我们创建一个引用这个 bean 的控制器： @Controller public class ScopesController { @Resource(name = \u0026#34;applicationScopedBean\u0026#34;) HelloMessageGenerator applicationScopedBean; @RequestMapping(\u0026#34;/scopes/application\u0026#34;) public String getApplicationScopeMessage(final Model model) { model.addAttribute(\u0026#34;previousMessage\u0026#34;, applicationScopedBean.getMessage()); applicationScopedBean.setMessage(\u0026#34;Good afternoon!\u0026#34;); model.addAttribute(\u0026#34;currentMessage\u0026#34;, applicationScopedBean.getMessage()); return \u0026#34;scopesExample\u0026#34;; } } 在这种情况下，一旦在applicationScopedBean中设置，值消息将保留给所有后续请求、会话，甚至对于将访问此 bean 的不同 servlet 应用程序，只要它在相同的ServletContext 中运行。 4.4. WebSocket 范围 最后，让我们使用websocket范围创建 bean ： @Bean @Scope(scopeName = \u0026#34;websocket\u0026#34;, proxyMode = ScopedProxyMode.TARGET_CLASS) public HelloMessageGenerator websocketScopedBean() { return new HelloMessageGenerator(); } 首次访问时，WebSocket范围的 bean 存储在WebSocket会话属性中。每当在整个WebSocket会话期间访问该 bean 时，都会返回该 bean 的相同实例。 我们也可以说它表现出单例行为，但仅限于WebSocket**会话。 5. 结论 在本文中，我们讨论了 Spring 提供的不同 bean 范围以及它们的预期用途。 本文的实现可以在GitHub 项目中找到。 ","permalink":"http://itcodingman.github.io/spring-bean-scopes/","tags":null,"title":""},{"categories":null,"contents":"什么是 Spring Bean？ 一、概述 Bean 是 Spring Framework 的一个关键概念。因此，理解这个概念对于掌握框架并以有效的方式使用它至关重要。 不幸的是，**对于 Spring bean 究竟是什么这个简单问题，并没有明确的答案。**一些解释太低了以至于错过了大局，而另一些解释太模糊了。 本教程将尝试阐明该主题，从官方文档中的描述开始。 进一步阅读： 为什么选择 Spring 作为您的 Java 框架？ Spring 框架主要价值主张的快速实用概述。 阅读更多→ 了解 Spring 中的 getBean() 了解 Spring 的 BeanFactory.getBean() 方法的不同变体，用于从 Spring 容器中检索 bean 实例 阅读更多→ 2. bean定义 这是Spring Framework 文档中 bean 的定义 ： 在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。bean 是由 Spring IoC 容器实例化、组装和管理的对象。 这个定义简洁明了，**但没有详细说明一个重要元素：Spring IoC 容器。**让我们仔细看看它是什么以及它带来的好处。 3. 控制反转 简单地说，控制反转(IoC) 是**一个对象定义其依赖关系而不创建它们的过程。**该对象将构建此类依赖项的工作委托给 IoC 容器。 在深入研究 IoC 之前，让我们先声明几个域类。 3.1。领域类 假设我们有一个类声明： public class Company { private Address address; public Company(Address address) { this.address = address; } // getter, setter and other properties } 这个类需要一个 Address类型的协作者： public class Address { private String street; private int number; public Address(String street, int number) { this.street = street; this.number = number; } // getters and setters } 3.2. 传统方法 通常，我们使用类的构造函数创建对象： Address address = new Address(\u0026#34;High Street\u0026#34;, 1000); Company company = new Company(address); 这种方法没有任何问题，但是以更好的方式管理依赖关系不是很好吗？ 想象一个有几十个甚至几百个类的应用程序。有时我们希望在整个应用程序中共享一个类的单个实例，有时我们需要为每个用例提供一个单独的对象，等等。 管理如此多的对象简直就是一场噩梦。这就是控制反转来拯救的地方。 对象可以从 IoC 容器中检索其依赖项，而不是自己构建依赖项。我们需要做的就是为容器提供适当的配置元数据。 3.3. 豆配置 首先，让我们用*@Component注解来装饰Company类：* @Component public class Company { // this body is the same as before } 这是一个向 IoC 容器提供 bean 元数据的配置类： @Configuration @ComponentScan(basePackageClasses = Company.class) public class Config { @Bean public Address getAddress() { return new Address(\u0026#34;High Street\u0026#34;, 1000); } } 配置类产生一个 Address类型的 bean 。它还带有*@ComponentScan注释，它指示容器在包含Company*类的包中查找 bean。 当 Spring IoC 容器构造这些类型的对象时，所有对象都称为 Spring bean，因为它们由 IoC 容器管理。 3.4. 国际奥委会在行动 由于我们在配置类中定义了 bean，我们需要*AnnotationConfigApplicationContext*类的实例来构建容器： ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); 快速测试验证我们的 bean 的存在和属性值： Company company = context.getBean(\u0026#34;company\u0026#34;, Company.class); assertEquals(\u0026#34;High Street\u0026#34;, company.getAddress().getStreet()); assertEquals(1000, company.getAddress().getNumber()); 结果证明 IoC 容器已经正确地创建和初始化了 bean。 4。结论 本文简要介绍了 Spring bean 及其与 IoC 容器的关系。 完整的源代码可以在 GitHub 上找到。 ","permalink":"http://itcodingman.github.io/spring-bean/","tags":null,"title":""},{"categories":null,"contents":"Spring Boot 2 中的 Max-HTTP-Header-Size 一、概述 Spring Boot Web 应用程序默认包含一个预配置的嵌入式 Web 服务器。但是，在某些情况下，我们希望修改默认配置以满足自定义要求。 在本教程中，我们将了解如何在 Spring Boot 2.x 应用程序的application.properties文件中为请求标头设置和使用max-http-header-size属性。 2. Max-HTTP-Header-Size Spring Boot 支持Tomcat、Undertow和Jetty作为嵌入式服务器。通常，我们在 Spring Boot 应用程序中的application.properties文件或application.yaml文件中编写服务器配置。 大多数 Web 服务器都有自己的 HTTP 请求标头大小限制。HTTP 标头值受服务器实现的限制。在 Spring Boot 应用程序中，最大 HTTP 标头大小是使用server.max-http-header-size配置的。 Tomcat 和 Jetty 的实际默认值为 8kB，Undertow 的默认值为 1MB。 要修改最大 HTTP 标头大小，我们将属性添加到application.properties文件中： server.max-http-header-size=20000 对于application.yaml格式也是如此： server:max-http-header-size:20000从 Spring Boot 2.1 开始，我们现在将使用DataSize可解析值： server.max-http-header-size=10KB 3.请求头太大 假设在总 HTTP 标头大小大于max-http-header-size值的情况下发送请求。服务器以“400 Bad request”错误拒绝该请求。在下一个示例中，我们将在日志文件中看到此错误。 让我们创建一个控制器，它有一个名为 token 的标头属性： @RestController @RequestMapping(value = \u0026#34;/request-header-test\u0026#34;) public class MaxHttpHeaderSizeController { @GetMapping public boolean testMaxHTTPHeaderSize(@RequestHeader(value = \u0026#34;token\u0026#34;) String token) { return true; } } 接下来，让我们在application.properties文件中添加一些属性： ## Server connections configuration\rserver.tomcat.threads.max=200\rserver.connection-timeout=5s\rserver.max-http-header-size=8KB\rserver.tomcat.max-swallow-size=2MB\rserver.tomcat.max-http-post-size=2MB 当我们在令牌中传递一个大小大于 8kb的字符串值时，我们将得到 400 错误，如下所示：  在日志中，我们看到以下错误： 19:41:50.757 [http-nio-8080-exec-7] INFO o.a.coyote.http11.Http11Processor - Error parsing HTTP request header Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level. java.lang.IllegalArgumentException: Request header is too large ... 4.解决方案 我们可以根据需要在application.properties文件中增加max-http-header-size属性的值。 在上面的程序中，我们可以将它的值从默认的 8kb 升级到 40KB，这样就可以解决问题了。 server.max-http-header-size=40KB 现在，服务器将处理请求并返回 200 响应，如下所示：  因此，每当标头大小超过服务器列出的默认值时，我们将看到服务器返回 400-Bad Request 并显示错误“请求标头太大”。如上例所示，我们必须覆盖应用程序配置文件中的max-http-header-size值以匹配请求标头长度。 通常，当使用的令牌由于加密而非常长时，请求标头可能会变得太大。 5. 结论 在本教程中，我们学习了如何在 Spring Boot 应用程序的应用程序配置文件中使用max-http-header-size属性。 然后，我们看到了当我们传递一个超过这个大小的请求头时会发生什么，以及如何在我们的application.properties中增加**max-http-header-size 的大小。 与往常一样，这些示例的源代码可在 GitHub 上获得。 ","permalink":"http://itcodingman.github.io/spring-boot-max-http-header-size/","tags":null,"title":""},{"categories":null,"contents":"Spring 中的 @Component 与 @Repository 和 @Service 一、简介 在本快速教程中，我们将了解Spring Framework 中*@Component、@Repository和@Service注释之间的区别。* 进一步阅读： Spring @Autowired 指南 Springs @Autowired 注解和限定符最常见用法指南 阅读更多→ Spring @Qualifier 注解 @Autowired 单独有时不足以消除依赖关系。您可以使用 @Qualifier 注释更准确地连接。@Primary 也可以提供帮助。 阅读更多→ 2. Spring注解 在大多数典型应用程序中，我们有不同的层，如数据访问、表示、服务、业务等。 此外，在每一层中，我们都有各种 bean。为了自动检测这些 bean，Spring 使用类路径扫描注解。 然后它在ApplicationContext中注册每个 bean 。 以下是其中一些注释的快速概述：  @Component是任何 Spring 管理的组件的通用构造型。 @Service在服务层注释类。 @Repository在持久层注释类，它将充当数据库存储库。  我们已经有一篇关于这些注释的扩展文章，所以我们将重点放在它们之间的区别上。 3. 有什么不同？ **这些刻板印象之间的主要区别在于它们用于不同的分类。**当我们注释一个类进行自动检测时，我们应该使用各自的原型。 现在让我们更详细地了解它们。 3.1。 *@零件* 我们可以在整个应用程序中使用 @Component 将 bean 标记为 Spring 的托管组件。Spring 只会使用*@Component获取和注册bean，一般不会查找@Service* 和 @Repository。 它们在ApplicationContext中注册，因为它们使用*@Component*注释： @Component public @interface Service { } @Component public @interface Repository { } @Service 和 @Repository是*@Component*的特例。它们在技术上是相同的，但我们将它们用于不同的目的。 3.2. *@Repository* *@Repository*的工作是捕获特定于持久性的异常并将它们作为 Spring 的统一未检查异常之一重新抛出。 为此，Spring 提供了PersistenceExceptionTranslationPostProcessor，我们需要将其添加到我们的应用程序上下文中（如果我们使用 Spring Boot，则已经包括在内）： \u0026lt;bean class= \u0026#34;org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\u0026#34;/\u0026gt; 这个 bean 后处理器为任何使用 @Repository 注释的 bean 添加了一个顾问。 3.3. *@服务* 我们用@Service 标记bean 以表明它们持有业务逻辑。该注解除了用于服务层外，没有其他特殊用途。 4。结论 在本文中，我们了解了*@Component、@Repository*和*@Service*注释之间的区别。我们分别检查了每个注释以了解它们的使用领域。 总之，根据图层约定选择注释总是一个好主意。 ","permalink":"http://itcodingman.github.io/spring-component-repository-service/","tags":null,"title":""},{"categories":null,"contents":"Spring @Controller 和 @RestController 注解 一、概述 在这个简短的教程中，我们将讨论Spring MVC 中*@Controller和@RestController注解之间的区别。* 我们可以将第一个注解用于传统的 Spring 控制器，它已经成为框架的一部分很长时间了。 Spring 4.0 引入了*@RestController注解，以简化 RESTful Web 服务的创建。这是一个方便的注解，结合了*@Controller*和*@ResponseBody*，它消除了使用@ResponseBody*注解对控制器类的每个请求处理方法进行注解的需要。 进一步阅读： 春季请求映射 Spring @RequestMapping - 基本示例、@RequestParam、@PathVariable、标头映射 阅读更多→ Spring @RequestParam 注解 Spring 的 @RequestParam 注解的详细指南 阅读更多→ 2. Spring MVC @Controller 我们可以使用*@Controller*注解来注解经典控制器。这只是 @Component类的一个特化，它允许我们通过类路径扫描自动检测实现类。 我们通常将 @Controller与*@RequestMapping*注解结合使用，用于请求处理方法。 让我们看一个 Spring MVC 控制器的快速示例： @Controller @RequestMapping(\u0026#34;books\u0026#34;) public class SimpleBookController { @GetMapping(\u0026#34;/{id}\u0026#34;, produces = \u0026#34;application/json\u0026#34;) public @ResponseBody Book getBook(@PathVariable int id) { return findBookById(id); } private Book findBookById(int id) { // ...  } } 我们用@ResponseBody注释了请求处理方法。此注释支持将返回对象自动序列化到HttpResponse中。 3. Spring MVC @RestController @RestController是控制器的专用版本。它包括*@Controller和@ResponseBody*注释，因此简化了控制器的实现： @RestController @RequestMapping(\u0026#34;books-rest\u0026#34;) public class SimpleBookRestController { @GetMapping(\u0026#34;/{id}\u0026#34;, produces = \u0026#34;application/json\u0026#34;) public Book getBook(@PathVariable int id) { return findBookById(id); } private Book findBookById(int id) { // ...  } } 控制器使用*@RestController*注解进行注解；因此，*不需要@ResponseBody*。 控制器类的每个请求处理方法都会自动将返回对象序列化为HttpResponse。 4。结论 在本文中，我们检查了 Spring 框架中可用的经典和专用 REST 控制器。 示例的完整源代码可在GitHub 项目中找到。这是一个 Maven 项目，因此可以按原样导入和使用。 ","permalink":"http://itcodingman.github.io/spring-controller-vs-restcontroller/","tags":null,"title":""},{"categories":null,"contents":"Spring 核心注解 一、概述 我们可以使用org.springframework.beans.factory.annotation 和 org.springframework.context.annotation包中的注释来利用 Spring DI 引擎的功能。 我们经常将这些称为“Spring 核心注释”，我们将在本教程中回顾它们。 2. DI 相关注解 2.1。@自动连线 我们可以使用*@Autowired*来标记 Spring 将要解析和注入的依赖项。我们可以将此注解与构造函数、setter 或字段注入一起使用。 构造函数注入： class Car { Engine engine; @Autowired Car(Engine engine) { this.engine = engine; } } 二传手注入： class Car { Engine engine; @Autowired void setEngine(Engine engine) { this.engine = engine; } } 现场注入： class Car { @Autowired Engine engine; } @Autowired有一个名为required的**布尔参数，默认值为true。当找不到合适的 bean 进行连接时，它会调整 Spring 的行为。当true时，抛出异常，否则，什么都没有连接。 请注意，如果我们使用构造函数注入，则所有构造函数参数都是必需的。 从 4.3 版开始，除非我们声明至少两个构造函数，否则我们不需要显式使用*@Autowired注释构造函数。* 有关更多详细信息，请访问我们关于@Autowired和构造函数注入的文章。 2.2. @豆 @Bean标记了一个实例化 Spring bean 的工厂方法： @Bean Engine engine() { return new Engine(); } 当需要返回类型的新实例时，Spring 会调用这些方法。 生成的 bean 与工厂方法具有相同的名称。如果我们想以不同的方式命名它，我们可以使用这个注解的name或value参数（参数value是参数name的别名）： @Bean(\u0026#34;engine\u0026#34;) Engine getEngine() { return new Engine(); } 请注意，所有使用*@Bean注释的方法都必须在@Configuration*类中。 2.3. @Qualifier 我们使用*@Qualifier和@Autowired*来提供我们想要在模棱两可的情况下使用的bean id 或bean 名称。 例如，以下两个 bean 实现了相同的接口： class Bike implements Vehicle {} class Car implements Vehicle {} 如果 Spring 需要注入一个Vehicle bean，它最终会得到多个匹配的定义。在这种情况下，我们可以使用@Qualifier注释显式地提供 bean 的名称。 使用构造函数注入： @Autowired Biker(@Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle) { this.vehicle = vehicle; } 使用 setter 注入： @Autowired void setVehicle(@Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle) { this.vehicle = vehicle; } 或者： @Autowired @Qualifier(\u0026#34;bike\u0026#34;) void setVehicle(Vehicle vehicle) { this.vehicle = vehicle; } 使用字段注入： @Autowired @Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle; 更详细的描述，请阅读这篇文章。 2.4. @必需的 @Required在 setter 方法上标记我们希望通过 XML 填充的依赖项： @Required void setColor(String color) { this.color = color; } \u0026lt;bean class=\u0026#34;com.codingman.annotations.Bike\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;green\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 否则，将抛出BeanInitializationException 。 2.5. @价值 我们可以使用@Value将属性值注入到 bean 中。它与构造函数、设置器和字段注入兼容。 构造函数注入： Engine(@Value(\u0026#34;8\u0026#34;) int cylinderCount) { this.cylinderCount = cylinderCount; } 二传手注入： @Autowired void setCylinderCount(@Value(\u0026#34;8\u0026#34;) int cylinderCount) { this.cylinderCount = cylinderCount; } 或者： @Value(\u0026#34;8\u0026#34;) void setCylinderCount(int cylinderCount) { this.cylinderCount = cylinderCount; } 现场注入： @Value(\u0026#34;8\u0026#34;) int cylinderCount; 当然，注入静态值是没有用的。因此，我们可以在*@Value中使用占位符字符串来连接外部源中定义的**值，例如，在.properties或.yaml*文件中。 让我们假设以下*.properties*文件： engine.fuelType=petrol 我们可以使用以下内容注入engine.fuelType的值： @Value(\u0026#34;${engine.fuelType}\u0026#34;) String fuelType; 即使在 SpEL 中，我们也可以使用*@Value*。更多高级示例可以在我们关于*@Value*的文章中找到。 2.6. @取决于 我们可以使用这个注解让Spring在被注解的bean之前初始化其他bean。通常，这种行为是自动的，基于 bean 之间的显式依赖关系。 我们只有在依赖是隐式的时候才需要这个注解，例如 JDBC 驱动加载或者静态变量初始化。 我们可以在依赖类上使用*@DependsOn来指定依赖bean 的名称。注释的value*参数需要一个包含依赖 bean 名称的数组： @DependsOn(\u0026#34;engine\u0026#34;) class Car implements Vehicle {} 或者，如果我们使用*@Bean注解定义 bean，则工厂方法应该使用@DependsOn*进行注解： @Bean @DependsOn(\u0026#34;fuel\u0026#34;) Engine engine() { return new Engine(); } 2.7. @懒惰的 当我们想要懒惰地初始化我们的bean时，我们使用@Lazy 。默认情况下，Spring 在应用程序上下文的启动/引导时急切地创建所有单例 bean。 但是，在某些情况下，我们需要在请求时创建 bean，而不是在应用程序启动时。 这个注解的行为会根据我们准确放置的位置而有所不同。我们可以装上：  一个*@Bean*注释的 bean 工厂方法，用于延迟方法调用（因此创建 bean） 一个*@Configuration类和所有包含的@Bean*方法都会受到影响 一个*@Component类，它不是一个@Configuration*类，这个bean 将被延迟初始化 @Autowired构造函数、设置器或字段，用于延迟加载依赖项本身（通过代理）  此注释有一个名为value的参数，默认值为true。覆盖默认行为很有用。 例如，当全局设置为惰性时，将 bean 标记为预加载，或者在标有*@Lazy的**@Configuration类中配置特定的 @Bean*方法以预加载： @Configuration @Lazy class VehicleFactoryConfig { @Bean @Lazy(false) Engine engine() { return new Engine(); } } 如需进一步阅读，请访问本文。 2.8. @抬头 使用*@Lookup*注释的方法告诉 Spring 在我们调用它时返回该方法的返回类型的实例。 有关注释的详细信息可以在本文中找到。 2.9。@基本的 有时我们需要定义多个相同类型的bean。在这些情况下，注入将不成功，因为 Spring 不知道我们需要哪个 bean。 我们已经看到了处理这种情况的一个选项：用*@Qualifier*标记所有连接点并指定所需bean 的名称。 然而，大多数时候我们需要一个特定的 bean 而很少需要其他的。我们可以使用*@Primary来简化这种情况：如果我们用**@Primary*****标记最常用的bean，**它将在不合格的注入点上被选中： @Component @Primary class Car implements Vehicle {} @Component class Bike implements Vehicle {} @Component class Driver { @Autowired Vehicle vehicle; } @Component class Biker { @Autowired @Qualifier(\u0026#34;bike\u0026#34;) Vehicle vehicle; } 在前面的示例中，汽车是主要车辆。因此，在Driver类中，Spring 注入了一个Car bean。当然，在Biker bean 中，字段vehicle的值将是Bike对象，因为它是合格的。 2.10。@范围 我们使用*@Scope来定义@Component类或@Bean定义的范围。它可以是单例、原型、请求、会话、globalSession*或一些自定义范围。 例如： @Component @Scope(\u0026#34;prototype\u0026#34;) class Engine {} 3. 上下文配置注解 我们可以使用本节中描述的注释来配置应用程序上下文。 3.1。@轮廓 如果我们希望 Spring**仅在特定配置文件处于活动状态时*使用*@Component*类或*@Bean**方法，我们可以用@Profile标记它。我们可以使用注解的value参数配置配置文件的名称： @Component @Profile(\u0026#34;sportDay\u0026#34;) class Bike implements Vehicle {} 您可以在本文中阅读有关配置文件的更多信息。 3.2. @进口 我们可以使用**特定的*@Configuration*类而无需使用此注解进行组件扫描。*我们可以为这些类提供@Import的value*参数： @Import(VehiclePartSupplier.class) class VehicleFactoryConfig {} 3.3. @ImportResource 我们可以使用此注解**导入 XML 配置。**我们可以使用位置参数指定 XML 文件位置，或者使用它的别名，值参数： @Configuration @ImportResource(\u0026#34;classpath:/annotations.xml\u0026#34;) class VehicleFactoryConfig {} 3.4. @PropertySource 使用此注解，我们可以为应用程序设置定义属性文件： @Configuration @PropertySource(\u0026#34;classpath:/annotations.properties\u0026#34;) class VehicleFactoryConfig {} @PropertySource利用 Java 8 重复注释功能，这意味着我们可以多次使用它标记一个类： @Configuration @PropertySource(\u0026#34;classpath:/annotations.properties\u0026#34;) @PropertySource(\u0026#34;classpath:/vehicle-factory.properties\u0026#34;) class VehicleFactoryConfig {} 3.5. @PropertySources 我们可以使用这个注解来指定多个*@PropertySource*配置： @Configuration @PropertySources({ @PropertySource(\u0026#34;classpath:/annotations.properties\u0026#34;), @PropertySource(\u0026#34;classpath:/vehicle-factory.properties\u0026#34;) }) class VehicleFactoryConfig {} 请注意，从 Java 8 开始，我们可以通过上述重复注释功能实现相同的功能。 4。结论 在本文中，我们看到了最常见的 Spring 核心注解的概述。我们看到了如何配置 bean 连接和应用程序上下文，以及如何标记类以进行组件扫描。 像往常一样，这些示例可以在 GitHub 上找到。 ","permalink":"http://itcodingman.github.io/spring-core-annotations/","tags":null,"title":""},{"categories":null,"contents":"JPA 和 Spring 的 DAO 一、概述 本文将展示如何使用 Spring 和 JPA 实现 DAO。有关核心 JPA 配置，请参阅有关 JPA with Spring 的文章。 2. 不再有 Spring 模板 从 Spring 3.1 开始，已弃用JpaTemplate和相应的JpaDaoSupport 以支持使用本机 Java Persistence API。 此外，这两个类仅与 JPA 1 相关（来自JpaTemplate javadoc）：  请注意，此类没有升级到 JPA 2.0，也永远不会升级。  因此，现在最好的做法是直接使用 Java Persistence API而不是JpaTemplate。 2.1. 没有模板的异常翻译 JpaTemplate的职责之一是异常转换——将低级异常转换为更高级别的通用 Spring 异常。 如果没有模板，异常翻译仍然可以为所有使用 @Repository 注释的 DAO启用并完全正常运行。Spring 使用 bean 后处理器实现这一点，该后处理器将使用容器中找到的所有PersistenceExceptionTranslator通知所有**@Repository bean 。 同样重要的是要注意异常转换机制使用代理——为了让 Spring 能够围绕 DAO 类创建代理，这些代理不能被声明为final。 3. DAO 首先，我们将为所有 DAO 实现基础层——一个使用泛型并设计为可扩展的抽象类： public abstract class AbstractJpaDAO\u0026lt; T extends Serializable \u0026gt; { private Class\u0026lt; T \u0026gt; clazz; @PersistenceContext EntityManager entityManager; public final void setClazz( Class\u0026lt; T \u0026gt; clazzToSet ){ this.clazz = clazzToSet; } public T findOne( long id ){ return entityManager.find( clazz, id ); } public List\u0026lt; T \u0026gt; findAll(){ return entityManager.createQuery( \u0026#34;from \u0026#34; + clazz.getName() ) .getResultList(); } public void create( T entity ){ entityManager.persist( entity ); } public T update( T entity ){ return entityManager.merge( entity ); } public void delete( T entity ){ entityManager.remove( entity ); } public void deleteById( long entityId ){ T entity = findOne( entityId ); delete( entity ); } } 这里主要有趣的方面是EntityManager*的*注入方式——使用标准的*@PersistenceContext注释。在后台，这是由PersistenceAnnotationBeanPostProcessor*处理的——它处理注释，从包含中检索 JPA 实体管理器并注入它。 持久化后处理器要么通过在配置中定义显式创建，要么通过在命名空间配置中定义context:annotation-config或context:component-scan自动创建。 另外，请注意实体Class在构造函数中传递以用于通用操作： @Repository public class FooDAO extends AbstractJPADAO\u0026lt; Foo \u0026gt; implements IFooDAO{ public FooDAO(){ setClazz(Foo.class ); } } 4。结论 本教程说明了如何使用 Spring 和 JPA 设置 DAO 层，同时使用基于 XML 和 Java 的配置。我们还讨论了为什么不使用JpaTemplate以及如何用EntityManager替换它。最终结果是一个轻量级、干净的 DAO 实现，编译时几乎不依赖 Spring。 这个简单项目的实现可以在GitHub 项目中找到——这是一个基于 Maven 的项目，所以它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-dao-jpa/","tags":null,"title":""},{"categories":null,"contents":"Spring Data Cassandra简介 一、概述 本文是使用 Spring Data 使用 Cassandra 的实用介绍。 我们将从基础开始，通过配置和编码，最终构建一个完整的 Spring Data Cassandra 模块。 进一步阅读： 使用 Cassandra、Astra 和 Stargate 构建仪表板 了解如何使用 DataStax Astra 构建仪表板，这是一种由 Apache Cassandra 和 Stargate API 提供支持的数据库即服务。 阅读更多→ 使用 Cassandra、Astra、REST 和 GraphQL 构建仪表板——记录状态更新 使用 Cassandra 存储时间序列数据的示例。 阅读更多→ 使用 Cassandra、Astra 和 CQL 构建仪表板——映射事件数据 了解如何根据存储在 Astra 数据库中的数据在交互式地图上显示事件。 阅读更多→ 2.Maven依赖 让我们首先使用 Maven在pom.xml中定义依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.datastax.cassandra\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-driver-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3. Cassandra的配置 我们将在整个过程中使用 Java 配置风格来配置 Cassandra 集成。 3.1。主要配置（弹簧） 我们将为此使用 Java 配置风格。让我们从主要的配置类开始——当然是通过类级别的*@Configuration*注解驱动的： @Configuration public class CassandraConfig extends AbstractCassandraConfiguration { @Override protected String getKeyspaceName() { return \u0026#34;testKeySpace\u0026#34;; } @Bean public CassandraClusterFactoryBean cluster() { CassandraClusterFactoryBean cluster = new CassandraClusterFactoryBean(); cluster.setContactPoints(\u0026#34;127.0.0.1\u0026#34;); cluster.setPort(9142); return cluster; } @Bean public CassandraMappingContext cassandraMapping() throws ClassNotFoundException { return new BasicCassandraMappingContext(); } } 注意带有默认实现的新 bean - *BasicCassandraMappingContext 。*这是在它们的对象和它们的持久格式之间映射持久实体所必需的。 并且由于默认实现足够强大，我们可以直接使用它。 3.2. 主要配置（Spring Boot） 让我们通过application.properties进行 Cassandra 配置： spring.data.cassandra.keyspace-name=testKeySpace spring.data.cassandra.port=9142 spring.data.cassandra.contact-points=127.0.0.1 我们完成了！这就是我们在使用 Spring Boot 时所需要的。 3.3. Cassandra 连接属性 我们必须配置三个强制设置来设置 Cassandra 客户端的连接。 我们必须设置 Cassandra 服务器作为联系点运行的主机名*。端口*只是服务器中请求的侦听端口。KeyspaceName是定义节点上数据复制的命名空间，它基于 Cassandra 相关概念。 4. Cassandra 存储库 我们将使用CassandraRepository作为数据访问层。这遵循 Spring Data repository 抽象，该抽象专注于抽象出跨不同持久性机制实现数据访问层所需的代码。 4.1。创建*Cassandra 存储库* 让我们创建要在配置中使用的CassandraRepository： @Repository public interface BookRepository extends CassandraRepository\u0026lt;Book\u0026gt; { // } 4.2. *CassandraRepository*的配置 现在，我们可以扩展第 3.1 节中的配置，在 CassandraConfig 中添加*@EnableCassandraRepositories*类级别注释来标记我们在第 4.1 节中创建的 Cassandra Repository ： @Configuration @EnableCassandraRepositories( basePackages = \u0026#34;com.codingman.spring.data.cassandra.repository\u0026#34;) public class CassandraConfig extends AbstractCassandraConfiguration { // } 5. 实体 让我们快速看一下实体——我们将要使用的模型类。该类被注释并定义了嵌入模式下元数据 Cassandra 数据表创建的附加参数。 使用*@Table*注解，bean 直接映射到 Cassandra 数据表。此外，每个属性都被定义为一种主键或简单列： @Table public class Book { @PrimaryKeyColumn( name = \u0026#34;isbn\u0026#34;, ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING) private UUID id; @PrimaryKeyColumn( name = \u0026#34;title\u0026#34;, ordinal = 0, type = PrimaryKeyType.PARTITIONED) private String title; @PrimaryKeyColumn( name = \u0026#34;publisher\u0026#34;, ordinal = 1, type = PrimaryKeyType.PARTITIONED) private String publisher; @Column private Set\u0026lt;String\u0026gt; tags = new HashSet\u0026lt;\u0026gt;(); // standard getters and setters } 6. 使用嵌入式服务器进行测试 6.1。Maven 依赖项 如果要在嵌入式模式下运行 Cassandra（无需手动安装单独的 Cassandra 服务器），则需要将cassandra-unit相关依赖项添加到pom.xml中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.cassandraunit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-unit-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.9.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.cassandraunit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-unit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.cassandraunit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cassandra-unit-shaded\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.9.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hectorclient\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hector-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0-0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以使用嵌入式 Cassandra 服务器来测试此应用程序。主要优点是您不想显式安装 Cassandra。 这个嵌入式服务器也与 Spring JUnit 测试兼容。在这里，我们可以使用*@RunWith注解与嵌入式服务器一起设置SpringJUnit4ClassRunner 。*因此，无需运行外部 Cassandra 服务即可实现完整的测试套件。 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = CassandraConfig.class) public class BookRepositoryIntegrationTest { // } 6.2. 启动和停止服务器 如果您正在运行外部 Cassandra 服务器，则可以忽略此部分。 我们必须为整个测试套件启动一次服务器，因此服务器启动方法用*@BeforeClass*注释标记： @BeforeClass public static void startCassandraEmbedded() { EmbeddedCassandraServerHelper.startEmbeddedCassandra(); Cluster cluster = Cluster.builder() .addContactPoints(\u0026#34;127.0.0.1\u0026#34;).withPort(9142).build(); Session session = cluster.connect(); } 接下来，我们必须确保在测试套件执行完成后服务器停止： @AfterClass public static void stopCassandraEmbedded() { EmbeddedCassandraServerHelper.cleanEmbeddedCassandra(); } 6.3. 清洁数据表 最好在每次测试执行之前删除并创建数据表，以避免由于早期测试执行中的操纵数据而导致意外结果。 现在我们可以在服务器启动时创建数据表： @Before public void createTable() { adminTemplate.createTable( true, CqlIdentifier.cqlId(DATA_TABLE_NAME), Book.class, new HashMap\u0026lt;String, Object\u0026gt;()); } 并在每个测试用例执行后丢弃： @After public void dropTable() { adminTemplate.dropTable(CqlIdentifier.cqlId(DATA_TABLE_NAME)); } 7. 使用*CassandraRepository 进行数据访问* 我们可以直接使用上面创建的BookRepository来持久化、操作和获取 Cassandra 数据库中的数据。 7.1。保存一本新书 我们可以将一本新书保存到我们的书店： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); 然后我们可以检查数据库中插入的书的可用性： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); assertEquals(javaBook.getId(), books.iterator().next().getId()); 7.2. 更新现有书籍 Lat 从插入一本新书开始： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); 让我们按标题获取这本书： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); 那我们改一下书名： javaBook.setTitle(\u0026#34;Head First Java Second Edition\u0026#34;); bookRepository.save(ImmutableSet.of(javaBook)); 最后让我们检查一下数据库中的标题是否更新： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java Second Edition\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); assertEquals( javaBook.getTitle(), updateBooks.iterator().next().getTitle()); 7.3. 删除现有书籍 插入一本新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); 然后删除新输入的书： bookRepository.delete(javaBook); 现在我们可以检查删除： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findByTitleAndPublisher( \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;); assertNotEquals(javaBook.getId(), books.iterator().next().getId()); 这将导致从代码中抛出 NoSuchElementException 以确保该书已被删除。 7.4. 查找所有书籍 先插入一本新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); Book dPatternBook = new Book( UUIDs.timeBased(), \u0026#34;Head Design Patterns\u0026#34;,\u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); bookRepository.save(ImmutableSet.of(javaBook)); bookRepository.save(ImmutableSet.of(dPatternBook)); 查找所有书籍： Iterable\u0026lt;Book\u0026gt; books = bookRepository.findAll(); 然后我们可以检查数据库中可用书籍的数量： int bookCount = 0; for (Book book : books) bookCount++; assertEquals(bookCount, 2); 8. 结论 我们通过使用CassandraRepository数据访问机制的最常见方法，对带有 Spring 数据的 Cassandra 进行了基本的动手介绍。 上述代码片段和示例的实现可以在我的 GitHub 项目中找到——这是一个基于 Eclipse 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-data-cassandra-tutorial/","tags":null,"title":""},{"categories":null,"contents":"使用 Spring Data 中的 CassandraTemplate 一、概述 这是 Spring Data Cassandra 文章系列的第二篇。在本文中，我们将主要关注数据访问层中的CassandraTemplate和 CQL 查询。您可以在该系列的第一篇文章中阅读有关 Spring Data Cassandra 的更多信息。 Cassandra Query Language (CQL) 是 Cassandra 数据库的查询语言，CqlTemplate是 Spring Data Cassandra 中的低级数据访问模板——它方便地公开与数据操作相关的操作以执行 CQL 语句。 CassandraTemplate构建在低级CqlTemplate 之上，并提供了一种简单的方法来查询域对象并将对象映射到 Cassandra 中的持久数据结构。 让我们从配置开始，然后深入研究使用这两个模板的示例。 进一步阅读： 使用 Cassandra、Astra 和 Stargate 构建仪表板 了解如何使用 DataStax Astra 构建仪表板，这是一种由 Apache Cassandra 和 Stargate API 提供支持的数据库即服务。 阅读更多→ 使用 Cassandra、Astra、REST 和 GraphQL 构建仪表板——记录状态更新 使用 Cassandra 存储时间序列数据的示例。 阅读更多→ 使用 Cassandra、Astra 和 CQL 构建仪表板——映射事件数据 了解如何根据存储在 Astra 数据库中的数据在交互式地图上显示事件。 阅读更多→ 2. *Cassandra模板*配置 CassandraTemplate在 Spring 上下文中可用，因为我们的主要 Cassandra Spring 配置正在扩展 AbstractCassandraConfiguration： @Configuration @EnableCassandraRepositories(basePackages = \u0026#34;com.codingman.spring.data.cassandra.repository\u0026#34;) public class CassandraConfig extends AbstractCassandraConfiguration { ... } 然后我们可以在模板中进行简单的连接——或者通过它的确切类型，CassandraTemplate，或者作为更通用的接口CassandraOperations： @Autowired private CassandraOperations cassandraTemplate; 3. 使用*CassandraTemplate 进行数据访问* 让我们使用上面在数据访问层模块中定义的CassandraTemplate来处理数据持久化。 3.1。保存一本新书 我们可以将一本新书保存到我们的书店： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); 然后我们可以检查数据库中插入的书的可用性： Select select = QueryBuilder.select().from(\u0026#34;book\u0026#34;) .where(QueryBuilder.eq(\u0026#34;title\u0026#34;, \u0026#34;Head First Java\u0026#34;)) .and(QueryBuilder.eq(\u0026#34;publisher\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;)); Book retrievedBook = cassandraTemplate.selectOne(select, Book.class); 我们在这里使用Select QueryBuilder，映射到 cassandraTemplate 中的selectOne ( )。我们将在 CQL 查询部分更深入地讨论QueryBuilder。 3.2. 保存多本书 我们可以使用列表一次将多本书保存到我们的书店： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); Book dPatternBook = new Book( UUIDs.timeBased(), \u0026#34;Head Design Patterns\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); List\u0026lt;Book\u0026gt; bookList = new ArrayList\u0026lt;Book\u0026gt;(); bookList.add(javaBook); bookList.add(dPatternBook); cassandraTemplate.insert(bookList); 3.3. 更新现有书籍 Lat 从插入一本新书开始： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); 我们来取书： Select select = QueryBuilder.select().from(\u0026#34;book\u0026#34;); Book retrievedBook = cassandraTemplate.selectOne(select, Book.class); 然后让我们为检索到的书添加一些额外的标签： retrievedBook.setTags(ImmutableSet.of(\u0026#34;Java\u0026#34;, \u0026#34;Programming\u0026#34;)); cassandraTemplate.update(retrievedBook); 3.4. 删除插入的书 让我们插入一本新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); 然后删除这本书： cassandraTemplate.delete(javaBook); 3.5. 删除所有书籍 现在让我们插入一些新书： Book javaBook = new Book( UUIDs.timeBased(), \u0026#34;Head First Java\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); Book dPatternBook = new Book( UUIDs.timeBased(), \u0026#34;Head Design Patterns\u0026#34;, \u0026#34;O\u0026#39;Reilly Media\u0026#34;, ImmutableSet.of(\u0026#34;Computer\u0026#34;, \u0026#34;Software\u0026#34;)); cassandraTemplate.insert(javaBook); cassandraTemplate.insert(dPatternBook); 然后删除所有书籍： cassandraTemplate.deleteAll(Book.class); 4. 使用 CQL 查询的数据访问 始终可以使用 CQL 查询在数据访问层中进行数据操作。CQL 查询处理由CqlTemplate类执行，允许我们根据需要执行自定义查询。 但是，由于CassandraTemplate类是CqlTemplate的扩展，我们可以直接使用它来执行这些查询。 让我们看看我们可以使用 CQL 查询来操作数据的不同方法。 4.1。使用*查询构建器* QueryBuilder可用于为数据库中的数据操作构建查询。几乎所有标准操作都可以使用开箱即用的构建块构建： Insert insertQueryBuider = QueryBuilder.insertInto(\u0026#34;book\u0026#34;) .value(\u0026#34;isbn\u0026#34;, UUIDs.timeBased()) .value(\u0026#34;title\u0026#34;, \u0026#34;Head First Java\u0026#34;) .value(\u0026#34;publisher\u0026#34;, \u0026#34;OReilly Media\u0026#34;) .value(\u0026#34;tags\u0026#34;, ImmutableSet.of(\u0026#34;Software\u0026#34;)); cassandraTemplate.execute(insertQueryBuider); 如果您仔细查看代码片段，您可能会注意到使用了execute()方法而不是相关的操作类型（插入、删除等）。这是因为查询的类型是由QueryBuilder 的输出定义的。 4.2. 使用*PreparedStatements* 尽管PreparedStatements可用于任何情况，但通常建议将此机制用于多个插入以进行高速摄取。 PreparedStatement只准备一次，有助于确保高性能： UUID uuid = UUIDs.timeBased(); String insertPreparedCql = \u0026#34;insert into book (isbn, title, publisher, tags) values (?, ?, ?, ?)\u0026#34;; List\u0026lt;Object\u0026gt; singleBookArgsList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;?\u0026gt;\u0026gt; bookList = new ArrayList\u0026lt;\u0026gt;(); singleBookArgsList.add(uuid); singleBookArgsList.add(\u0026#34;Head First Java\u0026#34;); singleBookArgsList.add(\u0026#34;OReilly Media\u0026#34;); singleBookArgsList.add(ImmutableSet.of(\u0026#34;Software\u0026#34;)); bookList.add(singleBookArgsList); cassandraTemplate.ingest(insertPreparedCql, bookList); 4.3. 使用 CQL 语句 我们可以直接使用CQL语句查询数据，如下： UUID uuid = UUIDs.timeBased(); String insertCql = \u0026#34;insert into book (isbn, title, publisher, tags) values (\u0026#34; + uuid + \u0026#34;, \u0026#39;Head First Java\u0026#39;, \u0026#39;OReilly Media\u0026#39;, {\u0026#39;Software\u0026#39;})\u0026#34;; cassandraTemplate.execute(insertCql); 5. 结论 在本文中，我们研究了使用 Spring Data Cassandra 的各种数据操作策略，包括CassandraTemplate和 CQL 查询。 上述代码片段和示例的实现可以在我的 GitHub 项目中找到——这是一个基于 Maven 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-data-cassandratemplate-cqltemplate/","tags":null,"title":""},{"categories":null,"contents":"Spring JPA – 多个数据库 一、概述 在本教程中，我们将为具有多个数据库的 Spring Data JPA 系统实现一个简单的 Spring 配置。 进一步阅读： Spring Data JPA – 派生删除方法 了解如何定义 Spring Data 的 deleteBy 和 removeBy 方法 阅读更多→ 在 Spring Boot 中以编程方式配置数据源 了解如何以编程方式配置 Spring Boot DataSource，从而避开 Spring Boot 的自动 DataSource 配置算法。 阅读更多→ 2. 实体 首先，让我们创建两个简单的实体，每个实体都存在于一个单独的数据库中。 这是第一个用户 实体： package com.codingman.multipledb.model.user; @Entity @Table(schema = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int id; private String name; @Column(unique = true, nullable = false) private String email; private int age; } 这是第二个实体Product： package com.codingman.multipledb.model.product; @Entity @Table(schema = \u0026#34;products\u0026#34;) public class Product { @Id private int id; private String name; private double price; } 我们可以看到这**两个实体也被放置在独立的包中。**当我们进入配置时，这将很重要。 3. JPA 存储库 接下来，让我们看一下我们的两个 JPA 存储库UserRepository： package com.codingman.multipledb.dao.user; public interface UserRepository extends JpaRepository\u0026lt;User, Integer\u0026gt; { } 和ProductRepository： package com.codingman.multipledb.dao.product; public interface ProductRepository extends JpaRepository\u0026lt;Product, Integer\u0026gt; { } 再次注意我们如何在不同的包中创建这两个存储库。 4.用Java配置JPA 现在我们将了解实际的 Spring 配置。我们将首先设置两个配置类——一个用于*User*，另一个用于*Product*。 在每个配置类中，我们需要为User定义以下接口：  数据源 实体管理器工厂（用户实体管理器） 事务管理器（用户事务管理器）  让我们从查看用户配置开始： @Configuration @PropertySource({ \u0026#34;classpath:persistence-multiple-db.properties\u0026#34; }) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.user\u0026#34;, entityManagerFactoryRef = \u0026#34;userEntityManager\u0026#34;, transactionManagerRef = \u0026#34;userTransactionManager\u0026#34; ) public class PersistenceUserConfiguration { @Autowired private Environment env; @Bean @Primary public LocalContainerEntityManagerFactoryBean userEntityManager() { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(userDataSource()); em.setPackagesToScan( new String[] { \u0026#34;com.codingman.multipledb.model.user\u0026#34; }); HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter(); em.setJpaVendorAdapter(vendorAdapter); HashMap\u0026lt;String, Object\u0026gt; properties = new HashMap\u0026lt;\u0026gt;(); properties.put(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;, env.getProperty(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;)); properties.put(\u0026#34;hibernate.dialect\u0026#34;, env.getProperty(\u0026#34;hibernate.dialect\u0026#34;)); em.setJpaPropertyMap(properties); return em; } @Primary @Bean public DataSource userDataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName( env.getProperty(\u0026#34;jdbc.driverClassName\u0026#34;)); dataSource.setUrl(env.getProperty(\u0026#34;user.jdbc.url\u0026#34;)); dataSource.setUsername(env.getProperty(\u0026#34;jdbc.user\u0026#34;)); dataSource.setPassword(env.getProperty(\u0026#34;jdbc.pass\u0026#34;)); return dataSource; } @Primary @Bean public PlatformTransactionManager userTransactionManager() { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory( userEntityManager().getObject()); return transactionManager; } } 请注意我们如何通过使用 @Primary 注释 bean 定义来使用userTransactionManager作为我们的Primary *TransactionManager*。每当我们要隐式或显式地注入事务管理器而不指定哪个名称时，这都会很有帮助。 接下来，让我们讨论PersistenceProductConfiguration，我们在其中定义了类似的 bean： @Configuration @PropertySource({ \u0026#34;classpath:persistence-multiple-db.properties\u0026#34; }) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.product\u0026#34;, entityManagerFactoryRef = \u0026#34;productEntityManager\u0026#34;, transactionManagerRef = \u0026#34;productTransactionManager\u0026#34; ) public class PersistenceProductConfiguration { @Autowired private Environment env; @Bean public LocalContainerEntityManagerFactoryBean productEntityManager() { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(productDataSource()); em.setPackagesToScan( new String[] { \u0026#34;com.codingman.multipledb.model.product\u0026#34; }); HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter(); em.setJpaVendorAdapter(vendorAdapter); HashMap\u0026lt;String, Object\u0026gt; properties = new HashMap\u0026lt;\u0026gt;(); properties.put(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;, env.getProperty(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;)); properties.put(\u0026#34;hibernate.dialect\u0026#34;, env.getProperty(\u0026#34;hibernate.dialect\u0026#34;)); em.setJpaPropertyMap(properties); return em; } @Bean public DataSource productDataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName( env.getProperty(\u0026#34;jdbc.driverClassName\u0026#34;)); dataSource.setUrl(env.getProperty(\u0026#34;product.jdbc.url\u0026#34;)); dataSource.setUsername(env.getProperty(\u0026#34;jdbc.user\u0026#34;)); dataSource.setPassword(env.getProperty(\u0026#34;jdbc.pass\u0026#34;)); return dataSource; } @Bean public PlatformTransactionManager productTransactionManager() { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory( productEntityManager().getObject()); return transactionManager; } } 5. 简单测试 最后，让我们测试一下我们的配置。 为此，我们将创建每个实体的实例并确保它已创建： @RunWith(SpringRunner.class) @SpringBootTest @EnableTransactionManagement public class JpaMultipleDBIntegrationTest { @Autowired private UserRepository userRepository; @Autowired private ProductRepository productRepository; @Test @Transactional(\u0026#34;userTransactionManager\u0026#34;) public void whenCreatingUser_thenCreated() { User user = new User(); user.setName(\u0026#34;John\u0026#34;); user.setEmail(\u0026#34;john@test.com\u0026#34;); user.setAge(20); user = userRepository.save(user); assertNotNull(userRepository.findOne(user.getId())); } @Test @Transactional(\u0026#34;userTransactionManager\u0026#34;) public void whenCreatingUsersWithSameEmail_thenRollback() { User user1 = new User(); user1.setName(\u0026#34;John\u0026#34;); user1.setEmail(\u0026#34;john@test.com\u0026#34;); user1.setAge(20); user1 = userRepository.save(user1); assertNotNull(userRepository.findOne(user1.getId())); User user2 = new User(); user2.setName(\u0026#34;Tom\u0026#34;); user2.setEmail(\u0026#34;john@test.com\u0026#34;); user2.setAge(10); try { user2 = userRepository.save(user2); } catch (DataIntegrityViolationException e) { } assertNull(userRepository.findOne(user2.getId())); } @Test @Transactional(\u0026#34;productTransactionManager\u0026#34;) public void whenCreatingProduct_thenCreated() { Product product = new Product(); product.setName(\u0026#34;Book\u0026#34;); product.setId(2); product.setPrice(20); product = productRepository.save(product); assertNotNull(productRepository.findOne(product.getId())); } } 6. Spring Boot 中的多个数据库 Spring Boot 可以简化上面的配置。 默认情况下，Spring Boot 将使用前缀为*spring.datasource.**的配置属性实例化其默认*DataSource*： spring.datasource.jdbcUrl = [url] spring.datasource.username = [username] spring.datasource.password = [password] 我们现在想继续使用相同的方式来配置第二个*DataSource*，但使用不同的属性命名空间： spring.second-datasource.jdbcUrl = [url] spring.second-datasource.username = [username] spring.second-datasource.password = [password] 因为我们希望 Spring Boot 自动配置能够获取这些不同的属性（并实例化两个不同的DataSources），所以我们将定义两个类似于前面部分的配置类： @Configuration @PropertySource({\u0026#34;classpath:persistence-multiple-db-boot.properties\u0026#34;}) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.user\u0026#34;, entityManagerFactoryRef = \u0026#34;userEntityManager\u0026#34;, transactionManagerRef = \u0026#34;userTransactionManager\u0026#34;) public class PersistenceUserAutoConfiguration { @Primary @Bean @ConfigurationProperties(prefix=\u0026#34;spring.datasource\u0026#34;) public DataSource userDataSource() { return DataSourceBuilder.create().build(); } // userEntityManager bean  // userTransactionManager bean } @Configuration @PropertySource({\u0026#34;classpath:persistence-multiple-db-boot.properties\u0026#34;}) @EnableJpaRepositories( basePackages = \u0026#34;com.codingman.multipledb.dao.product\u0026#34;, entityManagerFactoryRef = \u0026#34;productEntityManager\u0026#34;, transactionManagerRef = \u0026#34;productTransactionManager\u0026#34;) public class PersistenceProductAutoConfiguration { @Bean @ConfigurationProperties(prefix=\u0026#34;spring.second-datasource\u0026#34;) public DataSource productDataSource() { return DataSourceBuilder.create().build(); } // productEntityManager bean  // productTransactionManager bean } 现在我们已经根据 Boot 自动配置约定在persistence-multiple-db-boot.properties中定义了数据源属性。 有趣的部分是使用***@ConfigurationProperties*****注释数据源 bean 创建方法****。我们只需要指定相应的配置前缀。在这个方法中，我们使用了一个DataSourceBuilder，Spring Boot 会自动处理剩下的事情。 但是如何将配置的属性注入到DataSource配置中呢？ 在DataSourceBuilder上调用*build()方法时，它会调用其私有的bind()*方法： public T build() { Class\u0026lt;? extends DataSource\u0026gt; type = getType(); DataSource result = BeanUtils.instantiateClass(type); maybeGetDriverClassName(); bind(result); return (T) result; } 这个私有方法执行了很多自动配置魔法，将解析的配置绑定到实际的DataSource实例： private void bind(DataSource result) { ConfigurationPropertySource source = new MapConfigurationPropertySource(this.properties); ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases(); aliases.addAliases(\u0026#34;url\u0026#34;, \u0026#34;jdbc-url\u0026#34;); aliases.addAliases(\u0026#34;username\u0026#34;, \u0026#34;user\u0026#34;); Binder binder = new Binder(source.withAliases(aliases)); binder.bind(ConfigurationPropertyName.EMPTY, Bindable.ofInstance(result)); } 尽管我们自己不必接触任何这些代码，但了解 Spring Boot 自动配置背后发生的事情仍然很有用。 除此之外，事务管理器和实体管理器 bean 配置与标准 Spring 应用程序相同。 7. 结论 本文是关于如何配置我们的 Spring Data JPA 项目以使用多个数据库的实用概述。 完整的实现可以在GitHub 项目中找到。这是一个基于 Maven 的项目，因此它应该很容易导入和运行。 ","permalink":"http://itcodingman.github.io/spring-data-jpa-multiple-databases/","tags":null,"title":""},{"categories":null,"contents":"Spring Data MongoDB 教程 这是 Spring Data MongoDB 的指南——从快速介绍如何在 Spring 项目中开始运行，到更复杂和有用的用例和库的特性。 Spring Data MongoDB 基础知识  *Spring Data MongoDB 简介* *Spring Data MongoDB 中的查询指南*  Spring Data MongoDB 高级  *Spring Data MongoDB——索引、注释和转换器* *Spring Data MongoDB 中的自定义级联* *Spring Data MongoDB 中的 GridFS* *使用 MongoDB 和 Spring Boot 上传和检索文件* *使用 Spring Boot 为 MongoDB 自动生成的字段* *ZonedDateTime 与 Spring Data MongoDB* *Spring Data MongoDB 事务* *Spring Data Reactive Repositories with MongoDB* *Spring Data MongoDB：投影和聚合* *使用嵌入式 MongoDB 进行 Spring Boot 集成测试*  ","permalink":"http://itcodingman.github.io/spring-data-mongodb-guide/","tags":null,"title":""},{"categories":null,"contents":"Spring 异常教程 *Spring 异常* 教程通过 示例讨论了 Spring 中一些最常见的异常——它们发生的原因以及如何快速解决它们。 Spring Beans 异常  *Spring BeanDefinitionStoreException* *Spring BeanCreationException* *Spring NoSuchBeanDefinitionException* *Spring中不满足的依赖* *Spring Boot 中的 BeanDefinitionOverrideException* *Spring Boot 错误 ApplicationContextException*  Spring 数据异常  *Spring DataIntegrityViolationException* *Spring NonTransientDataAccessException 指南*  Spring MVC 异常  *春季响应状态异常* *春季 MaxUploadSizeExceededException*  Spring 安全异常  *没有定义名为“springSecurityFilterChain”的 bean*  其他 Spring 教程  *Spring教程* *REST 与 Spring教程* *Spring 安全教程*  ","permalink":"http://itcodingman.github.io/spring-exceptions/","tags":null,"title":""},{"categories":null,"contents":"了解 Spring 中的 getBean() 一、简介 在本教程中，我们将介绍*BeanFactory.getBean()*方法的不同变体。 简单地说，正如该方法的名称所暗示的，它 负责从 Spring 容器中检索一个 bean 实例。 2. Spring Beans 设置 首先，让我们定义一些用于测试的 Spring bean。我们可以通过多种方式为 Spring 容器提供 bean 定义，但在我们的示例中，我们将使用基于注解的 Java 配置： @Configuration class AnnotationConfig { @Bean(name = {\u0026#34;tiger\u0026#34;, \u0026#34;kitty\u0026#34;}) @Scope(value = \u0026#34;prototype\u0026#34;) Tiger getTiger(String name) { return new Tiger(name); } @Bean(name = \u0026#34;lion\u0026#34;) Lion getLion() { return new Lion(\u0026#34;Hardcoded lion name\u0026#34;); } interface Animal {} } 我们已经创建了两个 bean。Lion具有默认的单例范围。Tiger被明确设置为原型范围。此外，请注意，我们为每个 bean 定义了名称，我们将在进一步的请求中使用这些名称。 3. getBean() API BeanFactory提供了五种不同的*getBean()*方法签名，我们将在下面的小节中进行研究。 3.1。按名称检索 Bean 让我们看看如何使用名称检索Lion bean 实例： Object lion = context.getBean(\u0026#34;lion\u0026#34;); assertEquals(Lion.class, lion.getClass()); 在这个变体中，我们提供了一个名称，作为回报，如果具有给定名称的 bean 存在于应用程序上下文中，我们将获得一个*Object 类的实例。*否则，如果 bean 查找失败，此实现和所有其他实现都会抛出NoSuchBeanDefinitionException 。 主要缺点是**在检索 bean 后，我们必须将其转换为所需的类型。****如果返回的 bean 的类型与我们预期的不同，**这可能会产生另一个异常。 假设我们尝试使用名称*“狮子”来获得老虎。* 当我们将结果转换为Tiger时，它会抛出ClassCastException： assertThrows(ClassCastException.class, () -\u0026gt; { Tiger tiger = (Tiger) context.getBean(\u0026#34;lion\u0026#34;); }); 3.2. 按名称和类型检索 Bean 在这里，我们需要指定请求的 bean 的名称和类型： Lion lion = context.getBean(\u0026#34;lion\u0026#34;, Lion.class); 与前一种方法相比，这种方法更安全，因为我们可以立即获得有关类型不匹配的信息： assertThrows(BeanNotOfRequiredTypeException.class, () -\u0026gt; context.getBean(\u0026#34;lion\u0026#34;, Tiger.class)); } 3.3. 按类型检索 Bean *使用getBean()*的第三个变体， 只指定 bean 类型就足够了： Lion lion = context.getBean(Lion.class); 在这种情况下，我们需要特别注意潜在的模棱两可的结果： assertThrows(NoUniqueBeanDefinitionException.class, () -\u0026gt; context.getBean(Animal.class)); } 在上面的示例中，由于Lion和Tiger都实现了Animal接口，因此仅指定类型不足以明确确定结果。因此，我们得到一个NoUniqueBeanDefinitionException。 3.4. 使用构造函数参数按名称检索 Bean 除了bean名称，我们还可以传递构造函数参数： Tiger tiger = (Tiger) context.getBean(\u0026#34;tiger\u0026#34;, \u0026#34;Siberian\u0026#34;); 这个方法有点不同，因为它只适用于具有原型作用域的 bean。 在单例的情况下，我们将得到一个*BeanDefinitionStoreException。* 因为原型 bean 每次从应用程序容器请求时都会返回一个新创建的实例，所以我们可以在调用 getBean()时即时提供构造函数参数： Tiger tiger = (Tiger) context.getBean(\u0026#34;tiger\u0026#34;, \u0026#34;Siberian\u0026#34;); Tiger secondTiger = (Tiger) context.getBean(\u0026#34;tiger\u0026#34;, \u0026#34;Striped\u0026#34;); assertEquals(\u0026#34;Siberian\u0026#34;, tiger.getName()); assertEquals(\u0026#34;Striped\u0026#34;, secondTiger.getName()); 正如我们所见，根据我们在请求 bean 时指定的第二个参数，每个Tiger都会获得不同的名称。 3.5. 使用构造函数参数按类型检索 Bean 这个方法类似于最后一个，但我们需要传递类型而不是名称作为第一个参数： Tiger tiger = context.getBean(Tiger.class, \u0026#34;Shere Khan\u0026#34;); assertEquals(\u0026#34;Shere Khan\u0026#34;, tiger.getName()); 与使用构造函数参数按名称检索 bean 类似，此方法仅适用于具有原型作用域的 bean。 4. 使用注意事项 尽管在BeanFactory接口中定义，*getBean()方法最常通过ApplicationContext 访问。*通常，我们不想在程序中直接使用*getBean()*方法。 bean 应该由容器管理。如果我们想使用其中之一，我们应该依赖依赖注入而不是直接调用ApplicationContext.getBean() *。*这样，我们就可以避免将应用程序逻辑与框架相关的细节混在一起。 5. 结论 在这个快速教程中，我们介绍了BeanFactory接口中**getBean() 方法的所有实现，并描述了每种方法的优缺点。 此处显示的所有代码示例都可以在 GitHub 上找到。 ","permalink":"http://itcodingman.github.io/spring-getbean/","tags":null,"title":""},{"categories":null,"contents":"弹簧 JDBC 一、概述 在本教程中，我们将介绍 Spring JDBC 模块的实际用例。 Spring JDBC 中的所有类都分为四个独立的包：   core* — JDBC 的核心功能。该包下的一些重要类包括JdbcTemplate*、 SimpleJdbcInsert、 SimpleJdbcCall和NamedParameterJdbcTemplate。   *datasource* — 用于访问数据源的实用程序类。它还具有用于在 Jakarta EE 容器之外测试 JDBC 代码的各种数据源实现。   *object* — 以面向对象的方式访问数据库。它允许运行查询并将结果作为业务对象返回。它还映射业务对象的列和属性之间的查询结果。   support — 支持核心 和 对象 包下的类，例如，提供 SQLException 转换功能 进一步阅读： Spring Security：探索 JDBC 身份验证 探索 Spring 提供的使用现有 DataSource 配置执行 JDBC 身份验证的功能。 阅读更多→ Spring Data JPA 简介 Spring 4 的 Spring Data JPA 简介 - Spring 配置、DAO、手动和生成的查询以及事务管理。 阅读更多→   2.配置 让我们从数据源的一些简单配置开始。 我们将使用 MySQL 数据库： @Configuration @ComponentScan(\u0026#34;com.baeldung.jdbc\u0026#34;) public class SpringJdbcConfig { @Bean public DataSource mysqlDataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:mysql://localhost:3306/springjdbc\u0026#34;); dataSource.setUsername(\u0026#34;guest_user\u0026#34;); dataSource.setPassword(\u0026#34;guest_password\u0026#34;); return dataSource; } } 或者，我们也可以充分利用嵌入式数据库进行开发或测试。 这是一个创建 H2 嵌入式数据库实例并使用简单 SQL 脚本预填充它的快速配置： @Bean public DataSource dataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript(\u0026#34;classpath:jdbc/schema.sql\u0026#34;) .addScript(\u0026#34;classpath:jdbc/test-data.sql\u0026#34;).build(); } 最后，同样可以使用 XML 配置数据源来完成： \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/springjdbc\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;guest_user\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;guest_password\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 3. *JdbcTemplate*和运行查询 3.1。基本查询 JDBC 模板是主要的 API，我们将通过它访问我们感兴趣的大部分功能：  创建和关闭连接 运行语句和存储过程调用 遍历ResultSet并返回结果  首先，我们从一个简单的例子开始，看看JdbcTemplate能做什么： int result = jdbcTemplate.queryForObject( \u0026#34;SELECT COUNT(*) FROM EMPLOYEE\u0026#34;, Integer.class); 这是一个简单的插入： public int addEmplyee(int id) { return jdbcTemplate.update( \u0026#34;INSERT INTO EMPLOYEE VALUES (?, ?, ?, ?)\u0026#34;, id, \u0026#34;Bill\u0026#34;, \u0026#34;Gates\u0026#34;, \u0026#34;USA\u0026#34;); } *注意使用?*提供参数的标准语法 特点。 接下来，让我们看一下这种语法的替代方法。 3.2. 带有命名参数的查询 为了获得对命名参数的支持，我们将使用框架提供的另一个 JDBC 模板 — NamedParameterJdbcTemplate。 此外，它包装了JbdcTemplate并使用 ? 提供了传统语法的替代方案。指定参数。 在幕后，它将命名参数替换为 JDBC ? 占位符并委托给包装的JDCTemplate以运行查询： SqlParameterSource namedParameters = new MapSqlParameterSource().addValue(\u0026#34;id\u0026#34;, 1); return namedParameterJdbcTemplate.queryForObject( \u0026#34;SELECT FIRST_NAME FROM EMPLOYEE WHERE ID = :id\u0026#34;, namedParameters, String.class); 请注意我们如何使用MapSqlParameterSource为命名参数提供值。 让我们看看使用 bean 的属性来确定命名参数： Employee employee = new Employee(); employee.setFirstName(\u0026#34;James\u0026#34;); String SELECT_BY_ID = \u0026#34;SELECT COUNT(*) FROM EMPLOYEE WHERE FIRST_NAME = :firstName\u0026#34;; SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(employee); return namedParameterJdbcTemplate.queryForObject( SELECT_BY_ID, namedParameters, Integer.class); 请注意我们现在如何使用BeanPropertySqlParameterSource实现，而不是像以前那样手动指定命名参数。 3.3. 将查询结果映射到 Java 对象 另一个非常有用的特性是能够通过实现RowMapper接口将查询结果映射到 Java 对象。 例如，对于查询返回的每一行，Spring 使用行映射器来填充 java bean： public class EmployeeRowMapper implements RowMapper\u0026lt;Employee\u0026gt; { @Override public Employee mapRow(ResultSet rs, int rowNum) throws SQLException { Employee employee = new Employee(); employee.setId(rs.getInt(\u0026#34;ID\u0026#34;)); employee.setFirstName(rs.getString(\u0026#34;FIRST_NAME\u0026#34;)); employee.setLastName(rs.getString(\u0026#34;LAST_NAME\u0026#34;)); employee.setAddress(rs.getString(\u0026#34;ADDRESS\u0026#34;)); return employee; } } 随后，我们现在可以将行映射器传递给查询 API 并获得完全填充的 Java 对象： String query = \u0026#34;SELECT * FROM EMPLOYEE WHERE ID = ?\u0026#34;; Employee employee = jdbcTemplate.queryForObject( query, new Object[] { id }, new EmployeeRowMapper()); 4.异常翻译 Spring 自带开箱即用的数据异常层次结构——以DataAccessException作为根异常——并将所有底层原始异常转换为它。 因此，我们通过不处理低级持久性异常来保持理智。我们还受益于 Spring 将低级异常包装在DataAccessException或其子类之一中。 这也使异常处理机制独立于我们正在使用的底层数据库。 除了默认的SQLErrorCodeSQLExceptionTranslator之外，我们还可以提供自己的SQLExceptionTranslator实现。 下面是一个自定义实现的快速示例——在存在重复键违规时自定义错误消息，这在使用 H2 时会导致错误代码 23505 ： public class CustomSQLErrorCodeTranslator extends SQLErrorCodeSQLExceptionTranslator { @Override protected DataAccessException customTranslate(String task, String sql, SQLException sqlException) { if (sqlException.getErrorCode() == 23505) { return new DuplicateKeyException( \u0026#34;Custom Exception translator - Integrity constraint violation.\u0026#34;, sqlException); } return null; } } 要使用这个自定义异常转换器，我们需要通过调用setExceptionTranslator()方法将其传递给JdbcTemplate ： CustomSQLErrorCodeTranslator customSQLErrorCodeTranslator = new CustomSQLErrorCodeTranslator(); jdbcTemplate.setExceptionTranslator(customSQLErrorCodeTranslator); 5. 使用 SimpleJdbc 类的 JDBC 操作 SimpleJdbc类提供了一种简单的方法来配置和运行 SQL 语句。这些类使用数据库元数据来构建基本查询。因此，SimpleJdbcInsert和SimpleJdbcCall类提供了一种更简单的方法来运行插入和存储过程调用。 5.1。*SimpleJdbcInsert* 让我们看一下以最少的配置运行简单的插入语句。 **INSERT 语句是根据*SimpleJdbcInsert*的配置生成的。**我们只需要提供表名、列名和值。 首先，让我们创建一个 SimpleJdbcInsert： SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(dataSource).withTableName(\u0026#34;EMPLOYEE\u0026#34;); 接下来，让我们提供列名称和值，然后运行操作： public int addEmplyee(Employee emp) { Map\u0026lt;String, Object\u0026gt; parameters = new HashMap\u0026lt;String, Object\u0026gt;(); parameters.put(\u0026#34;ID\u0026#34;, emp.getId()); parameters.put(\u0026#34;FIRST_NAME\u0026#34;, emp.getFirstName()); parameters.put(\u0026#34;LAST_NAME\u0026#34;, emp.getLastName()); parameters.put(\u0026#34;ADDRESS\u0026#34;, emp.getAddress()); return simpleJdbcInsert.execute(parameters); } 此外，我们可以使用executeAndReturnKey() API 来允许数据库生成主键。我们还需要配置实际的自动生成列： SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(dataSource) .withTableName(\u0026#34;EMPLOYEE\u0026#34;) .usingGeneratedKeyColumns(\u0026#34;ID\u0026#34;); Number id = simpleJdbcInsert.executeAndReturnKey(parameters); System.out.println(\u0026#34;Generated id - \u0026#34; + id.longValue()); 最后，我们还可以使用BeanPropertySqlParameterSource和MapSqlParameterSource传入这些数据。 5.2. *使用SimpleJdbcCall 的*存储过程 让我们也看看正在运行的存储过程。 我们将使用SimpleJdbcCall抽象： SimpleJdbcCall simpleJdbcCall = new SimpleJdbcCall(dataSource) .withProcedureName(\u0026#34;READ_EMPLOYEE\u0026#34;); public Employee getEmployeeUsingSimpleJdbcCall(int id) { SqlParameterSource in = new MapSqlParameterSource().addValue(\u0026#34;in_id\u0026#34;, id); Map\u0026lt;String, Object\u0026gt; out = simpleJdbcCall.execute(in); Employee emp = new Employee(); emp.setFirstName((String) out.get(\u0026#34;FIRST_NAME\u0026#34;)); emp.setLastName((String) out.get(\u0026#34;LAST_NAME\u0026#34;)); return emp; } 6. 批量操作 另一个简单的用例是将多个操作批处理在一起。 6.1。*使用JdbcTemplate 的*基本批处理操作 使用JdbcTemplate，可以通过batchUpdate() API运行批处理操作。 这里有趣的部分是简洁但非常有用的BatchPreparedStatementSetter实现： public int[] batchUpdateUsingJdbcTemplate(List\u0026lt;Employee\u0026gt; employees) { return jdbcTemplate.batchUpdate(\u0026#34;INSERT INTO EMPLOYEE VALUES (?, ?, ?, ?)\u0026#34;, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { ps.setInt(1, employees.get(i).getId()); ps.setString(2, employees.get(i).getFirstName()); ps.setString(3, employees.get(i).getLastName()); ps.setString(4, employees.get(i).getAddress(); } @Override public int getBatchSize() { return 50; } }); } 6.2. *使用NamedParameterJdbcTemplate 进行*批量操作 我们还可以选择使用NamedParameterJdbcTemplate – batchUpdate() API 进行批处理操作。 此 API 比上一个 API 更简单。因此，不需要实现任何额外的接口来设置参数，因为它有一个内部准备好的语句设置器来设置参数值。 相反，参数值可以作为SqlParameterSource数组传递给*batchUpdate()*方法。 SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(employees.toArray()); int[] updateCounts = namedParameterJdbcTemplate.batchUpdate( \u0026#34;INSERT INTO EMPLOYEE VALUES (:id, :firstName, :lastName, :address)\u0026#34;, batch); return updateCounts; 7. Spring JDBC 与 Spring Boot Spring Boot 提供了一个启动器spring-boot-starter-jdbc用于将 JDBC 与关系数据库一起使用。 与每个 Spring Boot 启动器一样，这个启动器可以帮助我们快速启动和运行我们的应用程序。 7.1。Maven 依赖 我们需要 spring-boot-starter-jdbc依赖项作为主要依赖项。我们还需要我们将使用的数据库的依赖项。在我们的例子中，这是MySQL： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 7.2. 配置 Spring Boot 会自动为我们配置数据源。我们只需要在属性文件中提供属性： spring.datasource.url=jdbc:mysql://localhost:3306/springjdbc spring.datasource.username=guest_user spring.datasource.password=guest_password 就是这样。只需执行这些配置，我们的应用程序就可以启动并运行。我们现在可以将它用于其他数据库操作。 我们在上一节中看到的标准 Spring 应用程序的显式配置现在包含在 Spring Boot 自动配置中。 8. 结论 在本文中，我们研究了 Spring Framework 中的 JDBC 抽象。我们通过实际示例介绍了 Spring JDBC 提供的各种功能。 我们还研究了如何使用 Spring Boot JDBC 启动器快速开始使用 Spring JDBC。 ","permalink":"http://itcodingman.github.io/spring-jdbc-jdbctemplate/","tags":null,"title":""},{"categories":null,"contents":"Spring Maven 存储库 一、概述 本文将展示在项目中使用 Spring 工件时要使用的 Maven 存储库 - 请参阅Spring wiki上存储库的完整列表。以前的 SpringSource 工件管理基础设施是maven.springframework.org - 现在已被弃用，取而代之的是更强大的repo.spring.io。 2. Maven 发布 所有 GA/Release 工件都发布到 Maven Central，因此如果只需要发布，则无需在pom中添加任何新的 repo 。但是，如果由于某种原因 Central 不可用，也有一个可用于 Spring 版本的自定义、可浏览的 Maven 存储库： \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;repository.spring.release\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring GA Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.spring.io/release\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; Spring 工件版本控制规则在项目 wiki 上进行了说明。 里程碑和快照不会直接发布到 Maven Central，因此它们有自己特定的存储库。 3. Maven 里程碑和候选版本 对于里程碑和 RC，需要将以下 repo 添加到pom中： \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;repository.spring.milestone\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestone Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; 已经定义了一个这个存储库，项目可以开始使用 Spring里程碑依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.2.0.RC3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4. Maven 快照 与里程碑类似，Spring 快照托管在自定义存储库中： \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;repository.spring.snapshot\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Snapshot Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.spring.io/snapshot\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; 在 pom 中启用存储库后，项目可以开始使用 Spring 快照： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.2.5.BUILD-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 乃至： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0.BUILD-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 现在还可以浏览快照存储库。 5. Spring OSGI 的 Maven 存储库 OSGI 兼容的 Spring 工件在 SpringSource Enterprise Bundle Repository中维护- 简而言之，EBR。这些存储库包含整个 Spring Framework 的有效 OSGI 包和库，以及这些库的完整依赖项集。对于捆绑： \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;com.springsource.repository.bundles.release\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;SpringSource Enterprise Bundle Repository - SpringSource Bundle Releases\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repository.springsource.com/maven/bundles/release\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;com.springsource.repository.bundles.external\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;SpringSource Enterprise Bundle Repository - External Bundle Releases\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repository.springsource.com/maven/bundles/external\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; 对于 OSGI 兼容库： \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;com.springsource.repository.libraries.release\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;SpringSource Enterprise Bundle Repository - SpringSource Library Releases\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repository.springsource.com/maven/libraries/release\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;com.springsource.repository.libraries.external\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;SpringSource Enterprise Bundle Repository - External Library Releases\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repository.springsource.com/maven/libraries/external\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; 注意：SpringSource EBR 现在是只读的，不再发布 Spring Framework 3.2.x 版本。 六，结论 本文描述了有关在pom中设置 Spring 特定的 Maven 存储库的实用信息——以便使用候选版本、里程碑和快照。 ","permalink":"http://itcodingman.github.io/spring-maven-repository/","tags":null,"title":""},{"categories":null,"contents":"Spring MVC 和 @ModelAttribute 注解 一、概述 最重要的Spring MVC注释之一是@ModelAttribute注释。 @ModelAttribute是一个注解，它将方法参数或方法返回值绑定到命名模型属性，然后将其公开给 Web 视图。 在本教程中，我们将通过一个通用概念（公司员工提交的表单）来演示此注释的可用性和功能。 进一步阅读： Spring MVC 中的 Model、ModelMap 和 ModelAndView 了解Spring MVC 提供的接口Model **、ModelMap和ModelAndView 。 阅读更多→ Spring @RequestParam 注解 Spring 的 @RequestParam 注解的详细指南 阅读更多→ 2.深入*了解@ModelAttribute* 正如介绍性段落所揭示的，我们可以将*@ModelAttribute*用作方法参数或在方法级别使用。 2.1。在方法级别 当我们在方法级别使用注解时，它表明方法的目的是添加一个或多个模型属性。此类方法支持与@RequestMapping方法相同的参数类型，但它们不能直接映射到请求。 让我们看一个简单的例子来了解它是如何工作的： @ModelAttribute public void addAttributes(Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;Welcome to the Netherlands!\u0026#34;); } 在上面的例子中，我们看到了一个方法，它为控制器类中定义的所有模型添加了一个名为**msg的属性。 当然，我们将在本文后面看到这一点。 一般来说，Spring MVC 在调用任何请求处理程序方法之前总是会先调用该方法。基本上，**@ModelAttribute方法在调用带有*@RequestMapping*注释的控制器方法之前被调用。**这是因为必须在控制器方法内部开始任何处理之前创建模型对象。 将相应的类注释为@ControllerAdvice也很重要。因此，我们可以在Model中添加将被标识为全局的值。这实际上意味着对于每个请求，响应中的每个方法都存在一个默认值。 2.2. 作为方法论据 当我们使用注解作为方法参数时，它表示从模型中检索参数。当注释不存在时，它应该首先被实例化，然后添加到模型中。一旦出现在模型中，参数字段应该从具有匹配名称的所有请求参数中填充。 在以下代码片段中，我们将使用提交到addEmployee端点的表单中的数据填充*员工模型属性。*Spring MVC 在调用提交方法之前在后台执行此操作： @RequestMapping(value = \u0026#34;/addEmployee\u0026#34;, method = RequestMethod.POST) public String submit(@ModelAttribute(\u0026#34;employee\u0026#34;) Employee employee) { // Code that uses the employee object return \u0026#34;employeeView\u0026#34;; } 在本文后面，我们将看到一个完整的示例，说明如何使用员工对象来填充employeeView模板。 它将表单数据与 bean 绑定。***使用@RequestMapping***注释的控制器可以具有使用*@ModelAttribute*注释的自定义类参数。 在 Spring MVC 中，我们将其称为数据绑定，这是一种通用机制，可以让我们不必单独解析每个表单字段。 3.表格示例 在本节中，我们将查看概述部分中概述的示例，这是一个非常基本的表单，提示用户（特别是公司员工）输入一些个人信息（特别是姓名和*ID）。*在提交完成并且没有任何错误之后，用户希望看到之前提交的数据显示在另一个屏幕上。 3.1。风景 让我们首先创建一个带有 id 和 name 字段的简单表单： \u0026lt;form:form method=\u0026#34;POST\u0026#34; action=\u0026#34;/spring-mvc-basics/addEmployee\u0026#34; modelAttribute=\u0026#34;employee\u0026#34;\u0026gt; \u0026lt;form:label path=\u0026#34;name\u0026#34;\u0026gt;Name\u0026lt;/form:label\u0026gt; \u0026lt;form:input path=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;form:label path=\u0026#34;id\u0026#34;\u0026gt;Id\u0026lt;/form:label\u0026gt; \u0026lt;form:input path=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; /\u0026gt; \u0026lt;/form:form\u0026gt; 3.2. 控制器 这是控制器类，我们将在其中实现上述视图的逻辑： @Controller @ControllerAdvice public class EmployeeController { private Map\u0026lt;Long, Employee\u0026gt; employeeMap = new HashMap\u0026lt;\u0026gt;(); @RequestMapping(value = \u0026#34;/addEmployee\u0026#34;, method = RequestMethod.POST) public String submit( @ModelAttribute(\u0026#34;employee\u0026#34;) Employee employee, BindingResult result, ModelMap model) { if (result.hasErrors()) { return \u0026#34;error\u0026#34;; } model.addAttribute(\u0026#34;name\u0026#34;, employee.getName()); model.addAttribute(\u0026#34;id\u0026#34;, employee.getId()); employeeMap.put(employee.getId(), employee); return \u0026#34;employeeView\u0026#34;; } @ModelAttribute public void addAttributes(Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;Welcome to the Netherlands!\u0026#34;); } } 在submit()方法中，我们有一个绑定到View的**Employee对象。我们可以像这样简单地将表单字段映射到对象模型。在该方法中，我们从表单中获取值并将它们设置为*ModelMap*。 最后，我们返回*employeeView*，这意味着我们将各自的 JSP 文件称为*View*代表。 此外，还有一个addAttributes()方法。其目的是在模型中添加将被全局识别的值。也就是说，对每个控制器方法的每个请求都将返回一个默认值作为响应。我们还必须将特定类注释为*@ControllerAdvice。* 3.3. 该模型 如前所述，模型对象非常简单，包含“前端”属性所需的所有内容。现在让我们看一个例子： @XmlRootElement public class Employee { private long id; private String name; public Employee(long id, String name) { this.id = id; this.name = name; } // standard getters and setters removed } 3.4. 包起来 @ControllerAdvice协助控制器，特别是适用于所有*@RequestMapping方法的**@ModelAttribute方法。当然，我们的addAttributes()方法将是第一个运行的，在其余的@RequestMapping*方法之前。 记住这一点，在submit()和addAttributes()都运行之后，我们可以在从**Controller类返回的View中引用它们，方法是在美元化的花括号中提及它们的给定名称，例如*${name}*。 3.5. 结果视图 现在让我们打印我们从表单中收到的内容： \u0026lt;h3\u0026gt;${msg}\u0026lt;/h3\u0026gt; Name : ${name} ID : ${id} 4。结论 在本文中，我们研究了在方法参数和方法级用例中使用*@ModelAttribute注释**。* ","permalink":"http://itcodingman.github.io/spring-mvc-and-the-modelattribute-annotation/","tags":null,"title":""},{"categories":null,"contents":"Spring Web 注释 一、概述 在本教程中，我们将探索org.springframework.web.bind.annotation包中的 Spring Web 注释。 2. @RequestMapping 简单地说， @ RequestMapping 标记了@Controller类内部的请求处理方法；可以使用以下方式进行配置：  路径或其别名、名称和*值：*方法映射到哪个 URL *方法：*兼容的 HTTP 方法 *params：*根据 HTTP 参数的存在、不存在或值过滤请求 *标头：*根据 HTTP 标头的存在、不存在或值过滤请求 *消费：*该方法可以在 HTTP 请求正文中消费哪些媒体类型 *产生：*该方法可以在 HTTP 响应正文中产生哪些媒体类型  这是一个简单的示例： @Controller class VehicleController { @RequestMapping(value = \u0026#34;/vehicles/home\u0026#34;, method = RequestMethod.GET) String home() { return \u0026#34;home\u0026#34;; } } 如果我们在类级别应用此注解，我们可以为***@Controller*****类中的所有处理程序方法提供默认设置。唯一的例外是 Spring 不会**用方法级别设置覆盖但附加两个路径部分的 URL。 例如，下面的配置和上面的效果是一样的： @Controller @RequestMapping(value = \u0026#34;/vehicles\u0026#34;, method = RequestMethod.GET) class VehicleController { @RequestMapping(\u0026#34;/home\u0026#34;) String home() { return \u0026#34;home\u0026#34;; } } 此外，@GetMapping、@PostMapping、@PutMapping、 @ DeleteMapping和*@PatchMapping是@RequestMapping*的不同变体， HTTP 方法已分别设置为 GET、POST、PUT、DELETE 和 PATCH。 这些从 Spring 4.3 版本开始可用。 3. @RequestBody 让我们继续看@RequestBody——它将HTTP 请求的主体映射到一个对象： @PostMapping(\u0026#34;/save\u0026#34;) void saveVehicle(@RequestBody Vehicle vehicle) { // ... } 反序列化是自动的，取决于请求的内容类型。 4. @PathVariable 接下来，让我们谈谈*@PathVariable*。 此注释指示方法参数绑定到 URI 模板变量。我们可以使用*@RequestMapping注释指定 URI 模板，并使用**@PathVariable*将方法参数绑定到模板部分之一。 我们可以使用名称或其别名、值参数来实现这一点： @RequestMapping(\u0026#34;/{id}\u0026#34;) Vehicle getVehicle(@PathVariable(\u0026#34;id\u0026#34;) long id) { // ... } 如果模板中部分的名称与方法参数的名称匹配，我们不必在注解中指定： @RequestMapping(\u0026#34;/{id}\u0026#34;) Vehicle getVehicle(@PathVariable long id) { // ... } 此外，我们可以通过将所需的参数设置为 false来将路径变量标记为可选： @RequestMapping(\u0026#34;/{id}\u0026#34;) Vehicle getVehicle(@PathVariable(required = false) long id) { // ... } 5. @RequestParam 我们使用*@RequestParam*来访问 HTTP 请求参数： @RequestMapping Vehicle getVehicleByParam(@RequestParam(\u0026#34;id\u0026#34;) long id) { // ... } 它具有与@PathVariable注释相同的配置选项。 除了这些设置之外，当 Spring 在请求中发现没有值或空值时，我们可以使用*@RequestParam指定注入值。为此，我们必须设置defaultValue*参数。 提供默认值隐式地将required设置为false： @RequestMapping(\u0026#34;/buy\u0026#34;) Car buyCar(@RequestParam(defaultValue = \u0026#34;5\u0026#34;) int seatCount) { // ... } 除了参数，我们还可以访问其他 HTTP 请求部分：cookies 和 headers。我们可以分别使用注解***@CookieValue*和*@RequestHeader***来访问它们。 我们可以像@RequestParam一样配置它们。 6. 响应处理注解 在接下来的部分中，我们将看到在 Spring MVC 中操作 HTTP 响应的最常见的注解。 6.1。@ResponseBody 如果我们使用@ResponseBody 标记请求处理程序方法*，*Spring 将方法的结果视为响应本身： @ResponseBody @RequestMapping(\u0026#34;/hello\u0026#34;) String hello() { return \u0026#34;Hello World!\u0026#34;; } 如果我们用这个注解来注解一个*@Controller*类，所有的请求处理方法都会使用它。 6.2. @ExceptionHandler 有了这个注解，我们可以声明一个自定义的错误处理方法。当请求处理程序方法抛出任何指定的异常时，Spring 调用此方法。 捕获的异常可以作为参数传递给方法： @ExceptionHandler(IllegalArgumentException.class) void onIllegalArgumentException(IllegalArgumentException exception) { // ... } 6.3. @ResponseStatus 如果我们使用此注释注释请求处理程序方法，我们可以指定**响应的所需 HTTP 状态。**我们可以使用code参数或它的别名value参数来声明状态代码。 此外，我们可以使用reason参数提供原因。 我们也可以将它与*@ExceptionHandler*一起使用： @ExceptionHandler(IllegalArgumentException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) void onIllegalArgumentException(IllegalArgumentException exception) { // ... } 有关 HTTP 响应状态的更多信息，请访问本文。 7. 其他网页注解 一些注释不直接管理 HTTP 请求或响应。在接下来的部分中，我们将介绍最常见的部分。 7.1。@控制器 我们可以使用@Controller定义一个 Spring MVC 控制器。有关更多信息，请访问我们关于 Spring Bean Annotations 的文章。 7.2. @RestController @RestController结合 了*@Controller*和*@ResponseBody*。 因此，以下声明是等价的： @Controller @ResponseBody class VehicleRestController { // ... } @RestController class VehicleRestController { // ... } 7.3. @ModelAttribute 使用这个注解，我们可以通过提供模型键来访问已经存在于MVC @Controller模型中的元素： @PostMapping(\u0026#34;/assemble\u0026#34;) void assembleVehicle(@ModelAttribute(\u0026#34;vehicle\u0026#34;) Vehicle vehicleInModel) { // ... } 与*@PathVariable和@RequestParam*一样，如果参数具有相同的名称，我们不必指定模型键： @PostMapping(\u0026#34;/assemble\u0026#34;) void assembleVehicle(@ModelAttribute Vehicle vehicle) { // ... } 此外，@ModelAttribute还有一个用途：如果我们用它来注解一个方法，Spring 会自动将该方法的返回值添加到模型中： @ModelAttribute(\u0026#34;vehicle\u0026#34;) Vehicle getVehicle() { // ... } 和以前一样，我们不必指定模型键，Spring 默认使用方法的名称： @ModelAttribute Vehicle vehicle() { // ... } 在 Spring 调用请求处理程序方法之前，它会调用类中所有*@ModelAttribute*注释的方法。 有关*@ModelAttribute*的更多信息，请参阅本文。 7.4. @CrossOrigin @CrossOrigin 为带注释的请求处理程序方法启用跨域通信： @CrossOrigin @RequestMapping(\u0026#34;/hello\u0026#34;) String hello() { return \u0026#34;Hello World!\u0026#34;; } 如果我们用它标记一个类，它适用于其中的所有请求处理程序方法。 我们可以使用此注释的参数微调 CORS 行为。 有关更多详细信息，请访问本文。 8. 结论 在本文中，我们了解了如何使用 Spring MVC 处理 HTTP 请求和响应。 ","permalink":"http://itcodingman.github.io/spring-mvc-annotations/","tags":null,"title":""},{"categories":null,"contents":"Spring MVC 中的表单入门 一、概述 在本文中，我们将讨论 Spring 表单和与控制器的数据绑定。此外，我们将看看Spring MVC中的主要注释之一，即***@ModelAttribute***。 当然，Spring MVC 是一个复杂的主题，您需要了解很多东西才能充分发挥它的潜力，所以一定要在这里更深入地研究这个框架。 进一步阅读： 探索 SpringMVC 的表单标签库 关于 Spring MVC 提供的用于帮助我们创建和验证表单的各种标签的快速且中肯的教程。 阅读更多→ 在 Spring MVC 中使用 FreeMarker 简介 FreeMarker 是来自 Apache Software Foundation 的基于 Java 的模板引擎。本教程说明了如何配置 FreeMarker 以在 Spring MVC 中使用。 阅读更多→ 在 Spring 中使用 Thymeleaf 简介 Thymeleaf 是一种与 Spring 完美集成的模板语言。本文介绍了在 Spring MVC 应用程序中使用 Thymeleaf。 阅读更多→ 2. 模型 首先——让我们定义一个简单的实体，我们将显示并绑定到表单： public class Employee { private String name; private long id; private String contactNumber; // standard getters and setters } 这将是我们的表单支持对象。 3. 观点 接下来——让我们定义实际的表单，当然还有包含它的 HTML 文件。我们将使用一个创建/注册新员工的页面： \u0026lt;%@ taglib prefix=\u0026#34;form\u0026#34; uri=\u0026#34;http://www.springframework.org/tags/form\u0026#34;%\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;Welcome, Enter The Employee Details\u0026lt;/h3\u0026gt; \u0026lt;form:form method=\u0026#34;POST\u0026#34; action=\u0026#34;/spring-mvc-xml/addEmployee\u0026#34; modelAttribute=\u0026#34;employee\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;form:label path=\u0026#34;name\u0026#34;\u0026gt;Name\u0026lt;/form:label\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;form:input path=\u0026#34;name\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;form:label path=\u0026#34;id\u0026#34;\u0026gt;Id\u0026lt;/form:label\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;form:input path=\u0026#34;id\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;form:label path=\u0026#34;contactNumber\u0026#34;\u0026gt; Contact Number\u0026lt;/form:label\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;form:input path=\u0026#34;contactNumber\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 首先——请注意，我们在 JSP 页面中包含了一个标签库——表单标签库——以帮助定义我们的表单。 Next – *form:form*标签在这里扮演着重要的角色；它与常规的 HTLM 标记非常相似，但modelAttribute属性是指定支持此表单的模型对象名称的键： \u0026lt;form:form method=\u0026#34;POST\u0026#34; action=\u0026#34;/SpringMVCFormExample/addEmployee\u0026#34; modelAttribute=\u0026#34;employee\u0026#34;\u0026gt; 这将对应于稍后在控制器中的*@ModelAttribute 。* 接下来 – 每个输入字段都使用 Spring Form taglib 中的另一个有用标签 – form: prefix。这些字段中的每一个都指定了一个*路径*属性——这必须对应于模型属性的 getter/setter（在本例中为 Employee 类）。加载页面时，输入字段由 Spring 填充，它调用绑定到输入字段的每个字段的 getter。提交表单时，会调用 setter 将表单的值保存到对象中。 最后——当表单提交时，控制器中的 POST 处理程序被调用，表单自动绑定到我们传入的员工参数。  4. 控制器 现在，让我们看看将处理后端的 Controller ： @Controller public class EmployeeController { @RequestMapping(value = \u0026#34;/employee\u0026#34;, method = RequestMethod.GET) public ModelAndView showForm() { return new ModelAndView(\u0026#34;employeeHome\u0026#34;, \u0026#34;employee\u0026#34;, new Employee()); } @RequestMapping(value = \u0026#34;/addEmployee\u0026#34;, method = RequestMethod.POST) public String submit(@Valid @ModelAttribute(\u0026#34;employee\u0026#34;)Employee employee, BindingResult result, ModelMap model) { if (result.hasErrors()) { return \u0026#34;error\u0026#34;; } model.addAttribute(\u0026#34;name\u0026#34;, employee.getName()); model.addAttribute(\u0026#34;contactNumber\u0026#34;, employee.getContactNumber()); model.addAttribute(\u0026#34;id\u0026#34;, employee.getId()); return \u0026#34;employeeView\u0026#34;; } } 控制器定义了两个简单的操作——GET 用于在表单中显示数据，POST 用于创建操作，通过表单的提交。 还要注意，如果没有将名为“employee”的对象添加到模型中，当我们尝试访问 JSP 时，Spring 会报错，因为 JSP 将被设置为将表单绑定到“employee”模型属性： java.lang.IllegalStateException: Neither BindingResult nor plain target object for bean name \u0026#39;employee\u0026#39; available as request attribute at o.s.w.s.s.BindStatus.\u0026lt;init\u0026gt;(BindStatus.java:141) 要访问我们的表单支持对象，我们需要通过*@ModelAttribute*注释注入它。 方法参数上的一个\u0026lt;em\u0026gt;@ModelAttribute \u0026lt;/em\u0026gt;表示将从模型中检索该参数。如果模型中不存在，则参数将首先实例化，然后添加到模型中。 5. 处理绑定错误 默认情况下，Spring MVC 在请求绑定过程中发生错误时会抛出异常。这通常不是我们想要的，相反，我们应该将这些错误呈现给用户。我们将通过向控制器方法添加一个作为参数来使用BindingResult ： public String submit( @Valid @ModelAttribute(\u0026#34;employee\u0026#34;) Employee employee, BindingResult result, ModelMap model) BindingResult参数需要放置在我们的表单支持对象之后——这是方法参数的顺序很重要的罕见情况之一。否则，我们将遇到以下异常： java.lang.IllegalStateException: Errors/BindingResult argument declared without preceding model attribute. Check your handler method signature! 现在——不再抛出异常；相反，错误将在传递给submit方法的*BindingResult上注册。*此时，我们可以通过多种方式处理这些错误——例如，可以取消操作： @RequestMapping(value = \u0026#34;/addEmployee\u0026#34;, method = RequestMethod.POST) public String submit(@Valid @ModelAttribute(\u0026#34;employee\u0026#34;)Employee employee, BindingResult result, ModelMap model) { if (result.hasErrors()) { return \u0026#34;error\u0026#34;; } //Do Something  return \u0026#34;employeeView\u0026#34;; } 请注意，如果结果包含错误，我们如何将另一个视图返回给用户，以便正确显示这些错误。让我们看一下那个视图*——error.jsp*： \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;Please enter the correct details\u0026lt;/h3\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;employee\u0026#34;\u0026gt;Retry\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 6. 显示员工 最后，除了创建一个新员工之外，我们还可以简单地显示一个——这是它的快速查看代码： \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;Submitted Employee Information\u0026lt;/h2\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Name :\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${name}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;ID :\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${id}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Contact Number :\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${contactNumber}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; JSP 页面只是使用 EL 表达式来显示模型中 Employee 对象的属性值。 7. 测试应用程序 可以部署简单的应用程序（例如在 Tomcat 服务器中）并在本地访问： http://localhost:8080/spring-mvc-xml/employee 这是包含主表单的视图——在提交操作之前：  Spring MVC 表单示例——提交 提交后显示数据：  Spring MVC 表单示例 – 查看 就是这样——一个使用 Spring MVC 的简单表单的工作示例，带有验证。 这个 Spring MVC 教程的实现可以在GitHub 项目中找到——这是一个基于 Maven 的项目，所以它应该很容易导入和运行。 最后，正如我在文章开头所说的那样，您绝对应该深入研究 Spring MVC。 ","permalink":"http://itcodingman.github.io/spring-mvc-form-tutorial/","tags":null,"title":""},{"categories":null,"contents":"Spring MVC 中的 Model、ModelMap 和 ModelAndView 一、概述 在本文中，我们将了解Spring MVC 提供的核心org.springframework.ui.Model **、org.springframework.ui.ModelMap和org.springframework.web.servlet.ModelAndView的使用。 2.Maven依赖 让我们从pom.xml文件中的spring-context依赖项开始： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以在此处找到最新版本的 spring-context 依赖项。 对于ModelAndView，需要spring-web依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以在此处找到最新版本的 spring-web 依赖项。 而且，如果我们使用 Thymeleaf 作为我们的视图，我们应该将此依赖项添加到 pom.xml： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以在[这里](https://search.maven.org/search?q=a:thymeleaf-spring5 AND g:org.thymeleaf)找到最新版本的 Thymeleaf 依赖项。 3.*型号* 让我们从这里最基本的概念开始——模型。 简单地说，模型可以提供用于渲染视图的属性。 要为视图提供可用数据，我们只需将此数据添加到其模型对象中。此外，具有属性的地图可以与模型实例合并： @GetMapping(\u0026#34;/showViewPage\u0026#34;) public String passParametersWithModel(Model model) { Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;spring\u0026#34;, \u0026#34;mvc\u0026#34;); model.addAttribute(\u0026#34;message\u0026#34;, \u0026#34;Baeldung\u0026#34;); model.mergeAttributes(map); return \u0026#34;viewPage\u0026#34;; } 4.*模型图* 就像上面的Model接口一样，ModelMap也用于传递值来渲染视图。 ModelMap的优势在于它使我们能够传递值的集合并将这些值视为在Map中： @GetMapping(\u0026#34;/printViewPage\u0026#34;) public String passParametersWithModelMap(ModelMap map) { map.addAttribute(\u0026#34;welcomeMessage\u0026#34;, \u0026#34;welcome\u0026#34;); map.addAttribute(\u0026#34;message\u0026#34;, \u0026#34;Baeldung\u0026#34;); return \u0026#34;viewPage\u0026#34;; } 5.*模型与视图* 将值传递给视图的最终接口是ModelAndView。 这个接口允许我们一次返回传递 Spring MVC 所需的所有信息： @GetMapping(\u0026#34;/goToViewPage\u0026#34;) public ModelAndView passParametersWithModelAndView() { ModelAndView modelAndView = new ModelAndView(\u0026#34;viewPage\u0026#34;); modelAndView.addObject(\u0026#34;message\u0026#34;, \u0026#34;Baeldung\u0026#34;); return modelAndView; } 6. 观点 我们放置在这些模型中的所有数据都被一个视图使用——通常是一个模板化的视图来呈现网页。 如果我们有一个 Thymeleaf 模板文件，我们的控制器方法将其作为他们的视图。可以从 thymeleaf HTML 代码中访问通过模型传递的参数： \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;Web Application. Passed parameter : th:text=\u0026#34;${message}\u0026#34;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 此处传递的参数通过语法*${message}*使用，称为占位符。Thymeleaf 模板引擎将用通过模型传递的同名属性的实际值替换此占位符。 7. 结论 在这个快速教程中，我们讨论了 Spring MVC 中的三个核心概念*——Model*、ModelMap和ModelAndView。我们还查看了视图如何使用这些值的示例。 ","permalink":"http://itcodingman.github.io/spring-mvc-model-model-map-model-view/","tags":null,"title":""},{"categories":null,"contents":"Spring MVC 教程 一、概述 这是一个简单的Spring MVC 教程，展示了如何使用基于 Java 的配置以及 XML 配置来设置 Spring MVC 项目。 Spring MVC 项目的 Maven 依赖项在Spring MVC 依赖项文章中有详细描述。 2.什么是Spring MVC？ 顾名思义，**它是 Spring 框架的一个模块，处理 Model-View-Controller 或 MVC 模式。**它结合了 MVC 模式的所有优点和 Spring 的便利性。 Spring使用其DispatcherServlet以前端控制器模式实现 MVC 。 简而言之，DispatcherServlet充当主控制器，将请求路由到其预期目的地。模型只不过是我们应用程序的数据，视图由各种模板引擎中的任何一个表示。 稍后我们将在示例中查看 JSP。 3. Spring MVC 使用 Java 配置 要通过 Java 配置类启用 Spring MVC 支持，我们只需添加*@EnableWebMvc*注解： @EnableWebMvc @Configuration public class WebConfig { /// ... } 这将为 MVC 项目设置我们所需的基本支持，例如注册控制器和映射、类型转换器、验证支持、消息转换器和异常处理。 如果我们想自定义这个配置，我们需要实现*WebMvcConfigurer*接口： @EnableWebMvc @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); } @Bean public ViewResolver viewResolver() { InternalResourceViewResolver bean = new InternalResourceViewResolver(); bean.setViewClass(JstlView.class); bean.setPrefix(\u0026#34;/WEB-INF/view/\u0026#34;); bean.setSuffix(\u0026#34;.jsp\u0026#34;); return bean; } } 在这个例子中，我们注册了一个ViewResolver bean，它将从*/WEB-INF/view目录返回.jsp视图。* 这里非常重要的是，我们可以注册视图控制器， 使用ViewControllerRegistry在 URL 和视图名称之间创建直接映射。这样，两者之间就不需要任何控制器了。 如果我们还想定义和扫描控制器类，我们可以在包含控制器的包中添加*@ComponentScan注释：* @EnableWebMvc @Configuration @ComponentScan(basePackages = { \u0026#34;com.baeldung.web.controller\u0026#34; }) public class WebConfig implements WebMvcConfigurer { // ... } 要引导加载此配置的应用程序，我们还需要一个初始化程序类： public class MainWebAppInitializer implements WebApplicationInitializer { @Override public void onStartup(final ServletContext sc) throws ServletException { AnnotationConfigWebApplicationContext root = new AnnotationConfigWebApplicationContext(); root.scan(\u0026#34;com.baeldung\u0026#34;); sc.addListener(new ContextLoaderListener(root)); ServletRegistration.Dynamic appServlet = sc.addServlet(\u0026#34;mvc\u0026#34;, new DispatcherServlet(new GenericWebApplicationContext())); appServlet.setLoadOnStartup(1); appServlet.addMapping(\u0026#34;/\u0026#34;); } } 请注意，对于 Spring 5 之前的版本，我们必须使用WebMvcConfigurerAdapter类而不是接口。 4. Spring MVC 使用 XML 配置 除了上面的 Java 配置，我们还可以使用纯 XML 配置： \u0026lt;context:component-scan base-package=\u0026#34;com.baeldung.web.controller\u0026#34; /\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;bean id=\u0026#34;viewResolver\u0026#34; class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/view/\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;mvc:view-controller path=\u0026#34;/\u0026#34; view-name=\u0026#34;index\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 如果我们想使用纯 XML 配置，我们还需要添加一个web.xml文件来引导应用程序。有关此方法的更多详细信息，请查看我们之前的文章。 5.控制器和视图 让我们看一个基本控制器的示例： @Controller public class SampleController { @GetMapping(\u0026#34;/sample\u0026#34;) public String showForm() { return \u0026#34;sample\u0026#34;; } } 而对应的JSP资源就是sample.jsp文件： \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;This is the body of the sample view\u0026lt;/h1\u0026gt;\t\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 基于 JSP 的视图文件位于项目的 / WEB-INF文件夹下，因此它们只能由 Spring 基础架构访问，而不能通过直接 URL 访问。 6. 带引导的 Spring MVC Spring Boot 是对 Spring 平台的一个补充，它使得上手和创建独立的生产级应用程序变得非常容易。*Boot*并不是为了取代 Spring，而是为了让使用它变得更快、更容易。 6.1。Spring Boot 启动器 新框架提供了方便的启动依赖项，这些依赖项描述符可以为特定功能引入所有必要的技术。 它们的优点是我们不再需要为每个依赖项指定一个版本，而是允许启动器为我们管理依赖项。 最快的入门方法是添加spring-boot-starter-parent pom.xml： \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; 这将负责依赖管理。 6.2. Spring Boot 入口点 使用Spring Boot构建的每个应用程序只需要定义主入口点。 这通常是一个带有main方法的 Java 类，用*@SpringBootApplication*注解： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 此注解添加了以下其他注解：  @Configuration将类标记为 bean 定义的来源。 @EnableAutoConfiguration告诉框架根据类路径上的依赖项自动添加 bean。 @ComponentScan扫描与**Application类或以下相同包中的其他配置和 bean 。  使用 Spring Boot，我们可以使用 Thymeleaf 或 JSP 设置前端，而无需使用第 3 节中定义的 ViewResolver。通过向我们的 pom.xml 添加spring-boot-starter-thymeleaf依赖项，Thymeleaf 被启用，并且不需要额外的配置。 Boot 应用程序的源代码一如既往地在 GitHub 上提供。 最后，如果您想开始使用 Spring Boot，请在此处查看我们的参考介绍。 7. 结论 在本文中，我们使用 Java 配置配置了一个简单而实用的 Spring MVC 项目。 ","permalink":"http://itcodingman.github.io/spring-mvc-tutorial/","tags":null,"title":""},{"categories":null,"contents":"Spring MVC 中的 ViewResolver 指南 一、概述 所有 MVC 框架都提供了一种处理视图的方法。 Spring 通过视图解析器做到这一点，这使您能够在浏览器中呈现模型，而无需将实现绑定到特定的视图技术。 ViewResolver将视图名称映射到实际视图。 Spring 框架附带了很多视图解析器，例如InternalResourceViewResolver、BeanNameViewResolver和其他一些。 这是一个简单的教程，展示了如何设置最常见的视图解析器以及如何在同一配置中使用多个*ViewResolver*。 2. Spring Web 配置 让我们从 web 配置开始；我们将使用*@EnableWebMvc*、@Configuration和*@ComponentScan*对其进行注释： @EnableWebMvc @Configuration @ComponentScan(\u0026#34;com.baeldung.web\u0026#34;) public class WebConfig implements WebMvcConfigurer { // All web configuration will go here } 在这里，我们将在配置中设置我们的视图解析器。 3.添加一个*InternalResourceViewResolver* 这个ViewResolver允许我们为视图名称设置前缀或后缀等属性，以生成最终的视图页面 URL： @Bean public ViewResolver internalResourceViewResolver() { InternalResourceViewResolver bean = new InternalResourceViewResolver(); bean.setViewClass(JstlView.class); bean.setPrefix(\u0026#34;/WEB-INF/view/\u0026#34;); bean.setSuffix(\u0026#34;.jsp\u0026#34;); return bean; } 为了示例的 简单性，我们不需要控制器来处理请求。 我们只需要一个简单的jsp页面，放在配置中定义的*/WEB-INF/view*文件夹中： \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;This is the body of the sample view\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.添加一个*BeanNameViewResolver* 这是 ViewResovler 的实现，它将视图名称解释为当前应用程序上下文中的 bean 名称。每个此类View都可以定义为 XML 或 Java 配置中的 bean。 首先，我们将BeanNameViewResolver添加到之前的配置中： @Bean public BeanNameViewResolver beanNameViewResolver(){ return new BeanNameViewResolver(); } 一旦定义了 ViewResolver，我们需要定义View类型的 beans，以便**DispatcherServlet 可以执行它来呈现视图： @Bean public View sample() { return new JstlView(\u0026#34;/WEB-INF/view/sample.jsp\u0026#34;); } 这是控制器类中相应的处理程序方法： @GetMapping(\u0026#34;/sample\u0026#34;) public String showForm() { return \u0026#34;sample\u0026#34;; } 从控制器方法中，视图名称作为“ *sample”*返回，这意味着来自此处理程序方法的视图解析为带有/WEB-INF/view/sample.jspURL 的 JstlView 类。 5. 链接*ViewResolver*并定义订单优先级 Spring MVC 还支持多个视图解析器。 这允许您在某些情况下覆盖特定视图。我们可以通过在配置中添加多个解析器来简单地链接视图解析器。 完成后，我们需要为这些解析器定义一个顺序。*order*属性用于定义链中调用的顺序。order 属性（最大订单号）越高，视图解析器在链中的位置就越晚。 要定义顺序，我们可以将以下代码行添加到我们的视图解析器的配置中： bean.setOrder(0); 请注意顺序优先级，因为InternalResourceViewResolver应该具有更高的顺序 - 因为它旨在表示非常明确的映射。如果其他解析器具有更高的顺序，则可能永远不会调用InternalResourceViewResolver 。 6. 使用 Spring Boot 使用 Spring Boot 时，WebMvcAutoConfiguration 会在我们的应用程序上下文中自动配置InternalResourceViewResolver 和*BeanNameViewResolver* bean 。 此外，为模板引擎添加相应的启动器会消除我们必须执行的大部分手动配置。 例如，通过将spring-boot-starter-thymeleaf依赖添加到我们的 pom.xml 中，Thymeleaf 被启用，并且不需要额外的配置： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot-starter-thymeleaf.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 此启动器依赖项在我们的应用程序上下文中使用名称thymeleafViewResolver配置**ThymeleafViewResolver bean。**我们可以通过提供一个同名的 bean 来覆盖自动配置的 ThymeleafViewResolver。 Thymeleaf 视图解析器通过用前缀和后缀包围视图名称来工作。prefix 和 suffix 的默认值分别是 \u0026lsquo;classpath:/templates/\u0026rsquo; 和 \u0026lsquo;.html\u0026rsquo;。 spring.thymeleaf.prefixSpring Boot 还提供了一个选项来分别通过设置和spring.thymeleaf.suffix属性来改变前缀和后缀的默认值。 同样，我们有groovy-templates、freemarker和mustache模板引擎的启动器依赖项，我们可以使用它们来使用 Spring Boot 自动配置相应的视图解析器。 DispatcherServlet使用它在应用程序上下文中找到的所有视图解析器，并尝试每一个，直到得到结果，因此如果我们计划添加自己的视图解析器，这些视图解析器的顺序变得非常重要。 7. 结论 在本教程中，我们使用 Java 配置配置了一系列视图解析器。通过使用顺序优先级，我们可以设置它们的调用顺序。 ","permalink":"http://itcodingman.github.io/spring-mvc-view-resolver-tutorial/","tags":null,"title":""},{"categories":null,"contents":"弹簧型材 一、概述 在本教程中，我们将重点介绍 Spring 中的 Profiles。 配置文件是框架的核心特性——允许我们将 bean 映射到不同的配置文件——例如dev、test和prod。 然后，我们可以在不同的环境中激活不同的配置文件以仅引导我们需要的 bean。 进一步阅读： 为测试配置单独的 Spring DataSource 关于如何配置单独的数据源以在 Spring 应用程序中进行测试的快速实用教程。 阅读更多→ Spring 和 Spring Boot 的属性 关于如何在 Spring 中使用属性文件和属性值的教程。 阅读更多→ 2.在 Bean 上使用*@Profile* 让我们从简单的开始，看看我们如何让一个 bean 属于一个特定的配置文件。我们使用*@Profile*注释——我们将 bean 映射到那个特定的配置文件；注释仅采用一个（或多个）配置文件的名称。 考虑一个基本场景：我们有一个 bean，它应该只在开发期间处于活动状态，而不是在生产中部署。 我们使用开发配置文件注释该 bean ，它只会在开发期间出现在容器中。在生产中，开发人员根本不会处于活动状态： @Component @Profile(\u0026#34;dev\u0026#34;) public class DevDatasourceConfig 作为一个快速的旁注，配置文件名称也可以使用 NOT 运算符作为前缀，例如*!dev*，以将它们从配置文件中排除。 在示例中，仅当dev 配置文件未激活时才会激活组件： @Component @Profile(\u0026#34;!dev\u0026#34;) public class DevDatasourceConfig 3. 在 XML 中声明配置文件 配置文件也可以在 XML 中配置。\u0026lt; beans\u0026gt;标签有一个profile属性，它采用逗号分隔的适用配置文件的值： \u0026lt;beans profile=\u0026#34;dev\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;devDatasourceConfig\u0026#34; class=\u0026#34;org.baeldung.profiles.DevDatasourceConfig\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 4.设置配置文件 下一步是激活和设置配置文件，以便在容器中注册相应的 bean。 这可以通过多种方式完成，我们将在以下部分中进行探讨。 4.1。*通过WebApplicationInitializer*接口以编程方式 在 Web 应用程序中，WebApplicationInitializer可用于以编程方式配置ServletContext。 它也是以编程方式设置我们的活动配置文件的非常方便的位置： @Configuration public class MyWebApplicationInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext servletContext) throws ServletException { servletContext.setInitParameter( \u0026#34;spring.profiles.active\u0026#34;, \u0026#34;dev\u0026#34;); } } 4.2. *通过ConfigurableEnvironment*以编程方式 我们还可以直接在环境中设置配置文件： @Autowired private ConfigurableEnvironment env; ... env.setActiveProfiles(\u0026#34;someProfile\u0026#34;); 4.3. *web.xml*中的上下文参数 同样，我们可以使用上下文参数在 Web 应用程序的web.xml文件中定义活动配置文件： \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;/WEB-INF/app-config.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;spring.profiles.active\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;dev\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; 4.4. JVM 系统参数 配置文件名称也可以通过 JVM 系统参数传入。这些配置文件将在应用程序启动期间激活： -Dspring.profiles.active=dev 4.5. 环境变量 在 Unix 环境中，配置文件也可以通过环境变量激活： export spring_profiles_active=dev 4.6. Maven 简介 Spring 配置文件也可以通过 Maven 配置文件激活，通过指定*spring.profiles.active* 配置属性。 在每个 Maven 配置文件中，我们可以设置一个spring.profiles.active属性： \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;spring.profiles.active\u0026gt;dev\u0026lt;/spring.profiles.active\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;prod\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;spring.profiles.active\u0026gt;prod\u0026lt;/spring.profiles.active\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; 它的值将用于替换 application.properties 中的*@* *spring.profiles.active @* 占位符： spring.profiles.active=@spring.profiles.active@ 现在我们需要在pom.xml中启用资源过滤： \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; ... \u0026lt;/build\u0026gt; 并附加一个*-P*参数来切换将应用哪个 Maven 配置文件： mvn clean package -Pprod 此命令将为prod配置文件打包应用程序。它还 在此应用程序运行时应用spring.profiles.active 值prod 。 4.7. 测试中的*@ActiveProfile* 测试可以很容易地使用*@ActiveProfile*注释指定哪些配置文件处于活动状态以启用特定配置文件： @ActiveProfiles(\u0026#34;dev\u0026#34;) 到目前为止，我们已经研究了多种激活配置文件的方法。现在让我们看看哪个优先级高于另一个，如果我们使用多个优先级会发生什么，从最高到最低优先级：  web.xml中的上下文参数 WebApplicationInitializer JVM 系统参数 环境变量 Maven 简介  5. 默认配置文件 任何未指定配置文件的 bean 都属于默认 配置文件。 Spring 还提供了一种在没有其他配置文件处于活动状态时设置默认配置文件的方法——通过使用spring.profiles.default 属性。 6. 获取活跃的个人资料 Spring 的活动配置文件驱动*@Profile*注释的行为以启用/禁用 bean。但是，我们也可能希望以编程方式访问活动配置文件列表。 我们有两种方法可以做到这一点，使用*Environment*或spring.active.profile**。** 6.1。使用环境 我们可以通过注入Environment对象来访问活动配置文件： public class ProfileManager { @Autowired private Environment environment; public void getActiveProfiles() { for (String profileName : environment.getActiveProfiles()) { System.out.println(\u0026#34;Currently active profile - \u0026#34; + profileName); } } } 6.2. 使用spring.active.profile 或者，我们可以通过注入属性 spring.profiles.active来访问配置文件： @Value(\u0026#34;${spring.profiles.active}\u0026#34;) private String activeProfile; 在这里，我们的activeProfile 变量**将包含当前活动的配置文件的名称，**如果有多个，它将包含用逗号分隔的名称。 但是，我们应该**考虑如果根本没有活动配置文件会发生什么。**使用我们上面的代码，缺少活动配置文件会阻止创建应用程序上下文。由于缺少用于注入变量的占位符，这将导致IllegalArgumentException 。 为了避免这种情况，我们可以定义一个默认值： @Value(\u0026#34;${spring.profiles.active:}\u0026#34;) private String activeProfile; 现在，如果没有激活的配置文件，我们的activeProfile将只包含一个空字符串。 如果我们想像前面的例子一样访问它们的列表，我们可以通过拆分activeProfile变量来实现： public class ProfileManager { @Value(\u0026#34;${spring.profiles.active:}\u0026#34;) private String activeProfiles; public String getActiveProfiles() { for (String profileName : activeProfiles.split(\u0026#34;,\u0026#34;)) { System.out.println(\u0026#34;Currently active profile - \u0026#34; + profileName); } } } 7. 示例：使用配置文件分离数据源配置 既然基础知识已经结束，让我们看一个真实的例子。 考虑一个场景，我们必须为开发和生产环境维护数据源配置。 让我们创建一个需要由两个数据源实现实现的通用接口DatasourceConfig ： public interface DatasourceConfig { public void setup(); } 下面是开发环境的配置： @Component @Profile(\u0026#34;dev\u0026#34;) public class DevDatasourceConfig implements DatasourceConfig { @Override public void setup() { System.out.println(\u0026#34;Setting up datasource for DEV environment. \u0026#34;); } } 以及生产环境的配置： @Component @Profile(\u0026#34;production\u0026#34;) public class ProductionDatasourceConfig implements DatasourceConfig { @Override public void setup() { System.out.println(\u0026#34;Setting up datasource for PRODUCTION environment. \u0026#34;); } } 现在让我们创建一个测试并注入我们的 DatasourceConfig 接口；根据活动配置文件，Spring 将注入DevDatasourceConfig或ProductionDatasourceConfig bean： public class SpringProfilesWithMavenPropertiesIntegrationTest { @Autowired DatasourceConfig datasourceConfig; public void setupDatasource() { datasourceConfig.setup(); } } 当dev 配置文件处于活动状态时，Spring 注入DevDatasourceConfig对象，然后调用*setup()*方法时，输出如下： Setting up datasource for DEV environment. 8. Spring Boot 中的配置文件 Spring Boot 支持到目前为止列出的所有配置文件配置，并具有一些附加功能。 8.1。激活或设置配置文件 第 4 节中介绍的初始化参数spring.profiles.active也可以设置为 Spring Boot 中的属性，以定义当前活动的配置文件。这是 Spring Boot 将自动获取的标准属性： spring.profiles.active=dev 但是，从 Spring Boot 2.4 开始，此属性不能与spring.config.activate.on-profile结合使用，因为这可能会引发ConfigDataException （ 即InvalidConfigDataPropertyException或InactiveConfigDataAccessException ）。 要以编程方式设置配置文件，我们还可以使用SpringApplication类： SpringApplication.setAdditionalProfiles(\u0026#34;dev\u0026#34;); 要在 Spring Boot 中使用 Maven 设置配置文件，我们可以 在pom.xm l中**的 spring-boot-maven-plugin下指定配置文件名称： \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt;dev\u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; 并执行 Spring Boot 特定的 Maven 目标： mvn spring-boot:run 8.2. 配置文件特定的属性文件 但是，Spring Boot 带来的最重要的配置文件相关功能是**配置文件特定的属性文件。**这些必须以application-{profile}.properties格式命名。 Spring Boot 将自动为所有配置文件加载application.properties文件中的属性，并且仅为指定配置文件加载特定于配置文件的*.properties文件中的属性。* 例如，我们可以使用名为application-dev.properties和application-production.properties的两个文件为开发和生产配置文件配置不同的数据源： 在application-production.properties文件中，我们可以设置一个MySql数据源： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db spring.datasource.username=root spring.datasource.password=root 然后我们可以在application-dev.properties文件中为**dev配置文件配置相同的属性，以使用内存H2数据库： spring.datasource.driver-class-name=org.h2.Driver spring.datasource.url=jdbc:h2:mem:db;DB_CLOSE_DELAY=-1 spring.datasource.username=sa spring.datasource.password=sa 这样，我们就可以轻松地为不同的环境提供不同的配置。 在 Spring Boot 2.4 之前，可以从特定于配置文件的文档中激活配置文件。但情况已不再如此；对于更高版本， 在这些情况下，框架将再次抛出InvalidConfigDataPropertyException或 InactiveConfigDataAccessException 。 8.3. 多文档文件 为了进一步简化为不同环境定义属性，我们甚至可以将所有属性合并到同一个文件中，并使用分隔符来指示配置文件。 从 2.4 版本开始，除了之前支持的YAML之外，Spring Boot 还扩展了对属性文件的多文档文件的支持。所以现在，**我们可以在同一个*application.properties中指定**dev*和*production***属性： my.prop=used-always-in-all-profiles #--- spring.config.activate.on-profile=dev spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db spring.datasource.username=root spring.datasource.password=root #--- spring.config.activate.on-profile=production spring.datasource.driver-class-name=org.h2.Driver spring.datasource.url=jdbc:h2:mem:db;DB_CLOSE_DELAY=-1 spring.datasource.username=sa spring.datasource.password=sa 此文件由 Spring Boot 按从上到下的顺序读取。也就是说，如果某个属性，比如my.prop，在上述示例的末尾再次出现，则将考虑最后的值。 8.4. 配置文件组 Boot 2.4 中添加的另一个功能是配置文件组。顾名思义，它允许我们将相似的配置文件组合在一起。 让我们考虑一个用例，其中我们有多个用于生产环境的配置文件。比如说，一个用于数据库的proddb和一个用于**生产环境中调度程序的prodquartz 。 要通过我们的application.properties文件一次性启用这些配置文件，我们可以指定： spring.profiles.group.production=proddb,prodquartz 因此，激活生产配置文件也将激活proddb和prodquartz。 9. 结论 在本文中，我们讨论了如何在 bean 上定义配置文件，以及如何在我们的应用程序中启用正确的配置文件。 最后，我们通过一个简单但真实的示例验证了我们对配置文件的理解。 ","permalink":"http://itcodingman.github.io/spring-profiles/","tags":null,"title":""},{"categories":null,"contents":"Spring @Qualifier 注解 一、概述 在本教程中，我们将探讨**@Qualifier*注解*可以帮助我们**解决哪些问题，以及如何使用它。 进一步阅读： Spring @Primary 注解 学习如何使用 Spring 的 @Primary 注解在自动装配时优先考虑 bean 阅读更多→ Spring 中的接线：@Autowired、@Resource 和 @Inject 本文将对比和对比依赖注入相关注解的使用，即@Resource、@Inject、@Autowired注解。 阅读更多→ Spring 中的 @Lookup 注解 了解如何在 Spring 中有效地使用 @Lookup 注解进行过程注入。 阅读更多→ 我们还将解释它与*@Primary*注释以及按名称自动装配的不同之处。 2. Autowire 需要消歧义 @Autowired注解是一种在 Spring 中显式注入依赖项的好方法。尽管它很有用，但在某些用例中，仅此注解不足以让 Spring 了解要注入哪个 bean。 默认情况下，Spring 按类型解析自动装配的条目。 如果容器中有多个相同类型的 bean 可用，框架将抛出* NoUniqueBeanDefinitionException*， 表明有多个 bean 可用于自动装配。 让我们想象这样一种情况，其中 Spring 存在两个可能的候选对象，以便在给定实例中作为 bean 协作者注入： @Component(\u0026#34;fooFormatter\u0026#34;) public class FooFormatter implements Formatter { public String format() { return \u0026#34;foo\u0026#34;; } } @Component(\u0026#34;barFormatter\u0026#34;) public class BarFormatter implements Formatter { public String format() { return \u0026#34;bar\u0026#34;; } } @Component public class FooService { @Autowired private Formatter formatter; } 如果我们尝试将FooService加载到我们的上下文中，Spring 框架将抛出* NoUniqueBeanDefinitionException*。这是因为Spring 不知道要注入哪个 bean。为了避免这个问题，有几种解决方案；@Qualifier注释就是其中之一。 3. @Qualifier注解 通过使用*@Qualifier*注解，我们可以消除需要注入哪个 bean 的问题。 让我们重新回顾之前的示例，看看我们如何通过包含*@Qualifier*注释来指示我们要使用哪个 bean 来解决问题： public class FooService { @Autowired @Qualifier(\u0026#34;fooFormatter\u0026#34;) private Formatter formatter; } 通过包含*@Qualifier注解，以及我们要使用的具体实现的名称，在这个例子中Foo，*我们可以避免当 Spring 找到多个相同类型的 bean 时产生歧义。 我们需要考虑到要使用的限定符名称是*@Component*注解中声明的名称。 请注意，我们也可以在Formatter实现类上使用*@Qualifier注释，而不是在它们的@Component*注释中指定名称，以获得相同的效果： @Component @Qualifier(\u0026#34;fooFormatter\u0026#34;) public class FooFormatter implements Formatter { //... } @Component @Qualifier(\u0026#34;barFormatter\u0026#34;) public class BarFormatter implements Formatter { //... } 4. @Qualifier与*@Primary* 还有另一个名为@Primary的注解 ，当依赖注入存在歧义时，我们可以使用它来决定注入哪个 bean。 **当存在多个相同类型的 bean 时，*此注释定义了一个首选项。除非另有说明，否则将使用与@Primary*注释关联的 bean 。 让我们看一个例子： @Configuration public class Config { @Bean public Employee johnEmployee() { return new Employee(\u0026#34;John\u0026#34;); } @Bean @Primary public Employee tonyEmployee() { return new Employee(\u0026#34;Tony\u0026#34;); } } 在此示例中，两种方法都返回相同的Employee类型。Spring 将注入的 bean 是方法tonyEmployee返回的 bean 。这是因为它包含*@Primary*注释。当我们要指定默认注入某种类型的 bean时，此注解很有用。 如果我们在某个注入点需要另一个 bean，我们需要特别指出它。我们可以通过*@Qualifier注解做到这一点。例如，我们可以通过使用@Qualifier注释来指定我们想要使用johnEmployee*方法返回的 bean。 值得注意的是，**如果*@Qualifier*和*@Primary*注释都存在，那么*@Qualifier*注释将具有优先权。*基本上，@Primary定义了一个默认值，而@Qualifier*非常具体。 让我们看一下使用*@Primary*注解的另一种方式，这次使用初始示例： @Component @Primary public class FooFormatter implements Formatter { //... } @Component public class BarFormatter implements Formatter { //... } **在这种情况下，*@Primary*注释被放置在实现类之一中，**并将消除场景的歧义。 5. @Qualifier与按名称自动装配 自动装配时在多个 bean 之间做出决定的另一种方法是使用要注入的字段的名称。这是默认设置，以防 Spring 没有其他提示。让我们看一些基于我们最初示例的代码： public class FooService { @Autowired private Formatter fooFormatter; } 在这种情况下，Spring 将确定要注入的 bean 是FooFormatter的，因为字段名称与我们在**@Component注释中为该 bean使用的值匹配。 六，结论 在本文中，我们描述了需要明确注入哪些 bean 的场景。特别是，我们检查了*@Qualifier*注解，并将其与确定需要使用哪些 bean 的其他类似方法进行了比较。 ","permalink":"http://itcodingman.github.io/spring-qualifier-annotation/","tags":null,"title":""},{"categories":null,"contents":"Spring @RequestParam 注解 一、概述 在这个快速教程中，我们将探索 Spring 的*@RequestParam*注解及其属性。 简单来说，我们可以使用*@RequestParam*从请求中提取查询参数、表单参数，甚至是文件。 进一步阅读： Spring @RequestMapping 新的快捷方式注解 在本文中，我们介绍了使用传统 Spring MVC 框架进行快速 Web 开发的不同类型的 @RequestMapping 快捷方式。 阅读更多→ Spring @Controller 和 @RestController 注解 了解 Spring MVC 中 @Controller 和 @RestController 注解的区别。 阅读更多→ 2. 一个简单的映射 假设我们有一个端点*/api/foos*接受一个名为 id的查询参数： @GetMapping(\u0026#34;/api/foos\u0026#34;) @ResponseBody public String getFoos(@RequestParam String id) { return \u0026#34;ID: \u0026#34; + id; } 在此示例中，我们使用*@RequestParam来提取id*查询参数。 一个简单的 GET 请求会调用getFoos： http://localhost:8080/spring-mvc-basics/api/foos?id=abc ---- ID: abc 接下来，让我们看一下注解的属性：*name*、 *value*、*required*和*defaultValue*。 3. 指定请求参数名称 在前面的例子中，变量名和参数名都是一样的。 **不过，有时我们希望这些有所不同。**或者，如果我们不使用 Spring Boot，我们可能需要进行特殊的编译时配置，否则参数名称实际上不会出现在字节码中。 幸运**的是，我们可以使用*name*属性配置*@RequestParam***名称： @PostMapping(\u0026#34;/api/foos\u0026#34;) @ResponseBody public String addFoo(@RequestParam(name = \u0026#34;id\u0026#34;) String fooId, @RequestParam String name) { return \u0026#34;ID: \u0026#34; + fooId + \u0026#34; Name: \u0026#34; + name; } 我们也可以使用 @RequestParam(value = “id”)或只是@RequestParam(“id”)。 4.可选请求参数 默认情况下需要使用*@RequestParam*注释的方法参数 。 这意味着如果请求中不存在参数，我们将收到错误： GET /api/foos HTTP/1.1 ----- 400 Bad Request Required String parameter \u0026#39;id\u0026#39; is not present 不过，我们可以使用*required* 属性将*@RequestParam*配置为可选的： @GetMapping(\u0026#34;/api/foos\u0026#34;) @ResponseBody public String getFoos(@RequestParam(required = false) String id) { return \u0026#34;ID: \u0026#34; + id; } 在这种情况下，两者： http://localhost:8080/spring-mvc-basics/api/foos?id=abc ---- ID: abc 和 http://localhost:8080/spring-mvc-basics/api/foos ---- ID: null 将正确调用该方法。 未指定参数时，方法参数绑定为*null*。 4.1。使用 Java 8可选 或者，我们可以将参数包装在 *Optional*中： @GetMapping(\u0026#34;/api/foos\u0026#34;) @ResponseBody public String getFoos(@RequestParam Optional\u0026lt;String\u0026gt; id){ return \u0026#34;ID: \u0026#34; + id.orElseGet(() -\u0026gt; \u0026#34;not provided\u0026#34;); } 在这种情况下，我们不需要指定*required*属性。 如果未提供请求参数，将使用默认值： http://localhost:8080/spring-mvc-basics/api/foos ---- ID: not provided 5.请求参数的默认值 我们还可以 使用defaultValue属性为*@RequestParam设置默认值：* @GetMapping(\u0026#34;/api/foos\u0026#34;) @ResponseBody public String getFoos(@RequestParam(defaultValue = \u0026#34;test\u0026#34;) String id) { return \u0026#34;ID: \u0026#34; + id; } 这就像*required=false，* 因为用户不再需要提供参数： http://localhost:8080/spring-mvc-basics/api/foos ---- ID: test 虽然，我们仍然可以提供它： http://localhost:8080/spring-mvc-basics/api/foos?id=abc ---- ID: abc 请注意，当我们设置 defaultValue 属性时， required确实设置为false。 6. 映射所有参数 我们也可以有多个参数，而无需定义它们的名称或数量，只需使用Map： @PostMapping(\u0026#34;/api/foos\u0026#34;) @ResponseBody public String updateFoos(@RequestParam Map\u0026lt;String,String\u0026gt; allParams) { return \u0026#34;Parameters are \u0026#34; + allParams.entrySet(); } 然后将反映发送的任何参数： curl -X POST -F \u0026#39;name=abc\u0026#39; -F \u0026#39;id=123\u0026#39; http://localhost:8080/spring-mvc-basics/api/foos ----- Parameters are {[name=abc], [id=123]} 7. 映射多值参数 单个*@RequestParam*可以有多个值： @GetMapping(\u0026#34;/api/foos\u0026#34;) @ResponseBody public String getFoos(@RequestParam List\u0026lt;String\u0026gt; id) { return \u0026#34;IDs are \u0026#34; + id; } Spring MVC 将映射一个逗号分隔的 *id* 参数： http://localhost:8080/spring-mvc-basics/api/foos?id=1,2,3 ---- IDs are [1,2,3] 或单独的*id*参数列表： http://localhost:8080/spring-mvc-basics/api/foos?id=1\u0026amp;id=2 ---- IDs are [1,2] 8. 结论 在本文中，我们学习了如何使用*@RequestParam。* ","permalink":"http://itcodingman.github.io/spring-request-param/","tags":null,"title":""},{"categories":null,"contents":"Spring 的 RequestBody 和 ResponseBody 注解 一、简介 在这个快速教程中，我们简要概述了 Spring @RequestBody和*@ResponseBody*注释。 进一步阅读： Spring 处理程序映射指南 本文解释了 HandlerMapping 实现如何将 URL 解析为特定的 Handler。 阅读更多→ Spring 控制器快速指南 Spring 控制器的快速实用指南 - 适用于典型的 MVC 应用程序和 REST API。 阅读更多→ Spring @Controller 和 @RestController 注解 了解 Spring MVC 中 @Controller 和 @RestController 注解的区别。 阅读更多→ 2. *@RequestBody* 简单地说，@ *RequestBody*注释将*HttpRequest*主体映射到传输或域对象，从而将入站HttpRequest主体自动反序列化到 Java 对象上。 首先，我们来看一个 Spring 控制器方法： @PostMapping(\u0026#34;/request\u0026#34;) public ResponseEntity postController( @RequestBody LoginForm loginForm) { exampleService.fakeAuthenticate(loginForm); return ResponseEntity.ok(HttpStatus.OK); } 假设指定了适当的类型，Spring 会自动将 JSON 反序列化为 Java 类型。 默认情况下，我们使用*@RequestBody*注解注解的类型必须对应于从我们的客户端控制器发送的 JSON： public class LoginForm { private String username; private String password; // ... } 在这里，我们用来表示HttpRequest主体的对象映射到我们的LoginForm对象。 让我们使用 CURL 进行测试： curl -i \\ -H \u0026#34;Accept: application/json\u0026#34; \\ -H \u0026#34;Content-Type:application/json\u0026#34; \\ -X POST --data \u0026#39;{\u0026#34;username\u0026#34;: \u0026#34;johnny\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;}\u0026#39; \u0026#34;https://localhost:8080/.../request\u0026#34; 这就是使用*@RequestBody*注解的 Spring REST API 和 Angular 客户端所需要的全部内容。 3. *@ResponseBody* @ResponseBody注解告诉控制器返回的对象自动序列化为 JSON 并传回HttpResponse对象。 假设我们有一个自定义的Response对象： public class ResponseTransfer { private String text; // standard getters/setters } 接下来，可以实现关联的控制器： @Controller @RequestMapping(\u0026#34;/post\u0026#34;) public class ExamplePostController { @Autowired ExampleService exampleService; @PostMapping(\u0026#34;/response\u0026#34;) @ResponseBody public ResponseTransfer postResponseController( @RequestBody LoginForm loginForm) { return new ResponseTransfer(\u0026#34;Thanks For Posting!!!\u0026#34;); } } 在我们浏览器的开发者控制台中或者使用 Postman 之类的工具，我们可以看到如下响应： {\u0026#34;text\u0026#34;:\u0026#34;Thanks For Posting!!!\u0026#34;} 请记住，我们不需要使用 @ResponseBody 注解来注解*@RestController-*注解的控制器，因为 Spring 默认会这样做。** 3.1。设置内容类型 当我们使用*@ResponseBody*注解时，我们仍然能够显式地设置我们的方法返回的内容类型。 为此，**我们可以使用*@RequestMapping*的 *生产*属性。**请注意，@PostMapping、@GetMapping等注释定义了该参数的别名。 现在让我们添加一个发送 JSON 响应的新端点： @PostMapping(value = \u0026#34;/content\u0026#34;, produces = MediaType.APPLICATION_JSON_VALUE) @ResponseBody public ResponseTransfer postResponseJsonContent( @RequestBody LoginForm loginForm) { return new ResponseTransfer(\u0026#34;JSON Content!\u0026#34;); } 在示例中，我们使用了MediaType.APPLICATION_JSON_VALUE常量。或者，我们可以直接使用application/json。 接下来，让我们实现一个新方法，映射到相同的*/content*路径，但返回 XML 内容： @PostMapping(value = \u0026#34;/content\u0026#34;, produces = MediaType.APPLICATION_XML_VALUE) @ResponseBody public ResponseTransfer postResponseXmlContent( @RequestBody LoginForm loginForm) { return new ResponseTransfer(\u0026#34;XML Content!\u0026#34;); } 现在，根据请求标头中发送的*Accept*参数的值，我们将得到不同的响应。 让我们看看它的实际效果： curl -i \\  -H \u0026#34;Accept: application/json\u0026#34; \\  -H \u0026#34;Content-Type:application/json\u0026#34; \\  -X POST --data \u0026#39;{\u0026#34;username\u0026#34;: \u0026#34;johnny\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;}\u0026#39; \u0026#34;https://localhost:8080/.../content\u0026#34; CURL 命令返回 JSON 响应： HTTP/1.1 200 Content-Type: application/json Transfer-Encoding: chunked Date: Thu, 20 Feb 2020 19:43:06 GMT {\u0026#34;text\u0026#34;:\u0026#34;JSON Content!\u0026#34;} 现在，让我们更改Accept参数： curl -i \\ -H \u0026#34;Accept: application/xml\u0026#34; \\ -H \u0026#34;Content-Type:application/json\u0026#34; \\ -X POST --data \u0026#39;{\u0026#34;username\u0026#34;: \u0026#34;johnny\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;}\u0026#39; \u0026#34;https://localhost:8080/.../content\u0026#34; 正如预期的那样，这次我们得到了一个 XML 内容： HTTP/1.1 200 Content-Type: application/xml Transfer-Encoding: chunked Date: Thu, 20 Feb 2020 19:43:19 GMT \u0026lt;ResponseTransfer\u0026gt;\u0026lt;text\u0026gt;XML Content!\u0026lt;/text\u0026gt;\u0026lt;/ResponseTransfer\u0026gt; 4。结论 我们为 Spring 应用构建了一个简单的 Angular 客户端，演示了如何使用*@RequestBody* 和*@ResponseBody*注释。 此外，我们展示了如何在使用*@ResponseBody*时设置内容类型。 ","permalink":"http://itcodingman.github.io/spring-request-response-body/","tags":null,"title":""},{"categories":null,"contents":"春季请求映射 一、概述 在本教程中，我们将关注Spring MVC 中的主要注解之一：*@RequestMapping。* 简单来说，注解就是用来将 web 请求映射到 Spring Controller 方法上的。 进一步阅读： 使用 Spring 提供静态资源 如何使用 Spring MVC 映射和处理静态资源 - 使用简单的配置，然后是更灵活的 3.1 配置，最后是新的 4.1 资源解析器。 阅读更多→ Spring MVC 中的表单入门 了解如何使用 Spring MVC 处理表单 - 映射基本实体、提交、显示错误。 阅读更多→ 使用 Spring 框架的 Http 消息转换器 如何使用 Spring 为 REST API 配置 HttpMessageConverters，以及如何将这些转换器与 RestTemplate 一起使用。 阅读更多→ 2.@ *RequestMapping*基础 让我们从一个简单的示例开始：使用一些基本标准将 HTTP 请求映射到方法。 2.1。*@RequestMapping* — 按路径 @RequestMapping(value = \u0026#34;/ex/foos\u0026#34;, method = RequestMethod.GET) @ResponseBody public String getFoosBySimplePath() { return \u0026#34;Get some Foos\u0026#34;; } 要使用简单的curl命令测试此映射，请运行： curl -i http://localhost:8080/spring-rest/ex/foos 2.2. *@RequestMapping* — HTTP 方法 HTTP方法参数**没有默认值。**因此，如果我们不指定值，它将映射到任何 HTTP 请求。 这是一个简单的示例，与上一个类似，但这次映射到 HTTP POST 请求： @RequestMapping(value = \u0026#34;/ex/foos\u0026#34;, method = POST) @ResponseBody public String postFoos() { return \u0026#34;Post some Foos\u0026#34;; } 通过curl命令测试 POST： curl -i -X POST http://localhost:8080/spring-rest/ex/foos 3. *RequestMapping*和 HTTP 标头 3.1。*@RequestMapping*带有*headers*属性 通过为请求指定标头，可以进一步缩小映射范围： @RequestMapping(value = \u0026#34;/ex/foos\u0026#34;, headers = \u0026#34;key=val\u0026#34;, method = GET) @ResponseBody public String getFoosWithHeader() { return \u0026#34;Get some Foos with Header\u0026#34;; } 为了测试操作，我们将使用curl标头支持： curl -i -H \u0026#34;key:val\u0026#34; http://localhost:8080/spring-rest/ex/foos 甚至通过*@RequestMapping的**headers*属性设置多个标头： @RequestMapping( value = \u0026#34;/ex/foos\u0026#34;, headers = { \u0026#34;key1=val1\u0026#34;, \u0026#34;key2=val2\u0026#34; }, method = GET) @ResponseBody public String getFoosWithHeaders() { return \u0026#34;Get some Foos with Header\u0026#34;; } 我们可以使用以下命令进行测试： curl -i -H \u0026#34;key1:val1\u0026#34; -H \u0026#34;key2:val2\u0026#34; http://localhost:8080/spring-rest/ex/foos 请注意，对于curl语法，冒号分隔标头键和标头值，与 HTTP 规范中相同，而在 Spring 中，使用等号。 3.2. *@RequestMapping*消费和生产 由控制器方法生成的映射媒体类型值得特别注意。 我们可以通过上面介绍的*@RequestMapping* headers属性根据其Accept标头映射请求： @RequestMapping( value = \u0026#34;/ex/foos\u0026#34;, method = GET, headers = \u0026#34;Accept=application/json\u0026#34;) @ResponseBody public String getFoosAsJsonFromBrowser() { return \u0026#34;Get some Foos with Header Old\u0026#34;; } 这种定义Accept标头的方式的匹配是灵活的——它使用 contains 而不是 equals，所以像下面这样的请求仍然可以正确映射： curl -H \u0026#34;Accept:application/json,text/html\u0026#34; http://localhost:8080/spring-rest/ex/foos 从 Spring 3.1 开始，*@RequestMapping*注解现在具有*生产*和*消费*属性，专门用于此目的： @RequestMapping( value = \u0026#34;/ex/foos\u0026#34;, method = RequestMethod.GET, produces = \u0026#34;application/json\u0026#34; ) @ResponseBody public String getFoosAsJsonFromREST() { return \u0026#34;Get some Foos with Header New\u0026#34;; } 此外，从 Spring 3.1 开始，带有headers属性的旧映射类型将自动转换为新的生产机制，因此结果将是相同的。 这是通过curl以相同的方式使用的： curl -H \u0026#34;Accept:application/json\u0026#34; http://localhost:8080/spring-rest/ex/foos 此外，produces 还支持多个值： @RequestMapping( value = \u0026#34;/ex/foos\u0026#34;, method = GET, produces = { \u0026#34;application/json\u0026#34;, \u0026#34;application/xml\u0026#34; } ) 请记住，这些（指定Accept标头的新旧方法）基本上是相同的映射，因此 Spring 不允许它们一起使用。 激活这两种方法将导致： Caused by: java.lang.IllegalStateException: Ambiguous mapping found. Cannot map \u0026#39;fooController\u0026#39; bean method java.lang.String org.baeldung.spring.web.controller .FooController.getFoosAsJsonFromREST() to { [/ex/foos], methods=[GET],params=[],headers=[], consumes=[],produces=[application/json],custom=[] }: There is already \u0026#39;fooController\u0026#39; bean method java.lang.String org.baeldung.spring.web.controller .FooController.getFoosAsJsonFromBrowser() mapped. 关于新生产和消费机制的最后一点说明，其行为与大多数其他注释不同：在类型级别指定时，方法级别注释不会补充而是覆盖类型级别信息。 当然，如果您想深入了解如何使用 Spring 构建 REST API，请查看新的 REST with Spring 课程。 4.带路径变量*的 RequestMapping* 映射 URI 的一部分可以通过*@PathVariable*注释绑定到变量。 4.1。单个*@PathVariable* 带有单个路径变量的简单示例： @RequestMapping(value = \u0026#34;/ex/foos/{id}\u0026#34;, method = GET) @ResponseBody public String getFoosBySimplePathWithPathVariable( @PathVariable(\u0026#34;id\u0026#34;) long id) { return \u0026#34;Get a specific Foo with id=\u0026#34; + id; } 这可以用curl测试： curl http://localhost:8080/spring-rest/ex/foos/1 如果方法参数的名称与路径变量的名称完全匹配，则可以**使用不带值的*@PathVariable***来简化： @RequestMapping(value = \u0026#34;/ex/foos/{id}\u0026#34;, method = GET) @ResponseBody public String getFoosBySimplePathWithPathVariable( @PathVariable String id) { return \u0026#34;Get a specific Foo with id=\u0026#34; + id; } 请注意，@PathVariable受益于自动类型转换，因此我们也可以将id声明为： @PathVariable long id 4.2. 多个*@PathVariable* 更复杂的 URI 可能需要将 URI 的多个部分映射到多个值： @RequestMapping(value = \u0026#34;/ex/foos/{fooid}/bar/{barid}\u0026#34;, method = GET) @ResponseBody public String getFoosBySimplePathWithPathVariables (@PathVariable long fooid, @PathVariable long barid) { return \u0026#34;Get a specific Bar with id=\u0026#34; + barid + \u0026#34; from a Foo with id=\u0026#34; + fooid; } 这很容易用curl以相同的方式进行测试： curl http://localhost:8080/spring-rest/ex/foos/1/bar/2 4.3. *@PathVariable*与正则表达式 映射@PathVariable时也可以使用正则表达式。 例如，我们将映射限制为只接受id的数值： @RequestMapping(value = \u0026#34;/ex/bars/{numericId:[\\\\d]+}\u0026#34;, method = GET) @ResponseBody public String getBarsBySimplePathWithPathVariable( @PathVariable long numericId) { return \u0026#34;Get a specific Bar with id=\u0026#34; + numericId; } 这意味着以下 URI 将匹配： http://localhost:8080/spring-rest/ex/bars/1 但这不会： http://localhost:8080/spring-rest/ex/bars/abc 5.请求参数*的RequestMapping* @RequestMapping 允许使用@RequestParam*****注释轻松映射 URL 参数*。*** *** 我们现在将请求映射到 URI： http://localhost:8080/spring-rest/ex/bars?id=100 @RequestMapping(value = \u0026#34;/ex/bars\u0026#34;, method = GET) @ResponseBody public String getBarBySimplePathWithRequestParam( @RequestParam(\u0026#34;id\u0026#34;) long id) { return \u0026#34;Get a specific Bar with id=\u0026#34; + id; } 然后，我们使用控制器方法签名中的*@RequestParam(“id”)注释来提取id*参数的值。 要发送带有id参数的请求，我们将使用curl中的参数支持： curl -i -d id=100 http://localhost:8080/spring-rest/ex/bars 在这个例子中，参数是直接绑定的，没有先声明。 对于更高级的场景，*@RequestMapping*可以选择将参数定义为缩小请求映射的另一种方式： @RequestMapping(value = \u0026#34;/ex/bars\u0026#34;, params = \u0026#34;id\u0026#34;, method = GET) @ResponseBody public String getBarBySimplePathWithExplicitRequestParam( @RequestParam(\u0026#34;id\u0026#34;) long id) { return \u0026#34;Get a specific Bar with id=\u0026#34; + id; } 允许更灵活的映射。可以设置多个参数值，而不是必须使用所有参数值： @RequestMapping( value = \u0026#34;/ex/bars\u0026#34;, params = { \u0026#34;id\u0026#34;, \u0026#34;second\u0026#34; }, method = GET) @ResponseBody public String getBarBySimplePathWithExplicitRequestParams( @RequestParam(\u0026#34;id\u0026#34;) long id) { return \u0026#34;Narrow Get a specific Bar with id=\u0026#34; + id; } 当然，还有对 URI 的请求，例如： http://localhost:8080/spring-rest/ex/bars?id=100\u0026amp;second=something 将始终映射到最佳匹配——这是更窄的匹配，它定义了id和第二个参数。 6. *RequestMapping*角落案例 6.1。*@RequestMapping* — 映射到同一个控制器方法的多个路径 尽管单个*@RequestMapping*路径值通常用于单个控制器方法（只是一种好的做法，而不是硬性规定），但在某些情况下可能需要将多个请求映射到同一个方法。 在这种情况下，***@RequestMapping***的*value*属性确实接受多个映射，而不仅仅是一个： @RequestMapping( value = { \u0026#34;/ex/advanced/bars\u0026#34;, \u0026#34;/ex/advanced/foos\u0026#34; }, method = GET) @ResponseBody public String getFoosOrBarsByPath() { return \u0026#34;Advanced - Get some Foos or Bars\u0026#34;; } 现在这两个curl命令都应该使用相同的方法： curl -i http://localhost:8080/spring-rest/ex/advanced/foos curl -i http://localhost:8080/spring-rest/ex/advanced/bars 6.2. *@RequestMapping* — 对同一个控制器方法的多个 HTTP 请求方法 使用不同 HTTP 动词的多个请求可以映射到同一个控制器方法： @RequestMapping( value = \u0026#34;/ex/foos/multiple\u0026#34;, method = { RequestMethod.PUT, RequestMethod.POST } ) @ResponseBody public String putAndPostFoos() { return \u0026#34;Advanced - PUT and POST within single method\u0026#34;; } 使用curl，这两个现在都将使用相同的方法： curl -i -X POST http://localhost:8080/spring-rest/ex/foos/multiple curl -i -X PUT http://localhost:8080/spring-rest/ex/foos/multiple 6.3. *@RequestMapping* — 所有请求的后备 要使用特定 HTTP 方法为所有请求实现简单的回退，例如，对于 GET： @RequestMapping(value = \u0026#34;*\u0026#34;, method = RequestMethod.GET) @ResponseBody public String getFallback() { return \u0026#34;Fallback for GET Requests\u0026#34;; } 甚至对于所有请求： @RequestMapping( value = \u0026#34;*\u0026#34;, method = { RequestMethod.GET, RequestMethod.POST ... }) @ResponseBody public String allFallback() { return \u0026#34;Fallback for All Requests\u0026#34;; } 6.4. 模棱两可的映射错误 当 Spring 评估两个或多个请求映射对于不同的控制器方法相同时，会发生不明确的映射错误。当请求映射具有相同的 HTTP 方法、URL、参数、标头和媒体类型时，它是相同的。 例如，这是一个模棱两可的映射： @GetMapping(value = \u0026#34;foos/duplicate\u0026#34; ) public String duplicate() { return \u0026#34;Duplicate\u0026#34;; } @GetMapping(value = \u0026#34;foos/duplicate\u0026#34; ) public String duplicateEx() { return \u0026#34;Duplicate\u0026#34;; } 抛出的异常通常确实包含以下错误消息： Caused by: java.lang.IllegalStateException: Ambiguous mapping. Cannot map \u0026#39;fooMappingExamplesController\u0026#39; method public java.lang.String org.baeldung.web.controller.FooMappingExamplesController.duplicateEx() to {[/ex/foos/duplicate],methods=[GET]}: There is already \u0026#39;fooMappingExamplesController\u0026#39; bean method public java.lang.String org.baeldung.web.controller.FooMappingExamplesController.duplicate() mapped. 仔细阅读错误消息会发现 Spring 无法映射方法 *org.baeldung.web.controller.FooMappingExamplesController.duplicateEx()，*因为它与已映射的 org.baeldung.web.controller的映射存在冲突.FooMappingExamplesController.duplicate()。 下面的代码片段不会导致不明确的映射错误，因为两种方法都返回不同的内容类型： @GetMapping(value = \u0026#34;foos/duplicate\u0026#34;, produces = MediaType.APPLICATION_XML_VALUE) public String duplicateXml() { return \u0026#34;\u0026lt;message\u0026gt;Duplicate\u0026lt;/message\u0026gt;\u0026#34;; } @GetMapping(value = \u0026#34;foos/duplicate\u0026#34;, produces = MediaType.APPLICATION_JSON_VALUE) public String duplicateJson() { return \u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;Duplicate\\\u0026#34;}\u0026#34;; } 这种区分允许我们的控制器根据请求中提供的Accepts标头返回正确的数据表示 。 解决此问题的另一种方法是更新分配给所涉及的两种方法中的任何一种的 URL。 7. 新的请求映射快捷方式 Spring Framework 4.3 引入了一些新的HTTP 映射注解，全部基于*@RequestMapping*：  @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping  这些新的注释可以提高可读性并减少代码的冗长。 让我们通过创建一个支持 CRUD 操作的 RESTful API 来看看这些新注释的实际应用： @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; getBazz(@PathVariable String id){ return new ResponseEntity\u0026lt;\u0026gt;(new Bazz(id, \u0026#34;Bazz\u0026#34;+id), HttpStatus.OK); } @PostMapping public ResponseEntity\u0026lt;?\u0026gt; newBazz(@RequestParam(\u0026#34;name\u0026#34;) String name){ return new ResponseEntity\u0026lt;\u0026gt;(new Bazz(\u0026#34;5\u0026#34;, name), HttpStatus.OK); } @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; updateBazz( @PathVariable String id, @RequestParam(\u0026#34;name\u0026#34;) String name) { return new ResponseEntity\u0026lt;\u0026gt;(new Bazz(id, name), HttpStatus.OK); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; deleteBazz(@PathVariable String id){ return new ResponseEntity\u0026lt;\u0026gt;(new Bazz(id), HttpStatus.OK); } 可以在这里找到对这些的深入了解。 8. 弹簧配置 考虑到我们的FooController定义在以下包中，Spring MVC 配置非常简单： package org.baeldung.spring.web.controller; @Controller public class FooController { ... } 我们只需要一个*@Configuration*类来启用完整的 MVC 支持并为控制器配置类路径扫描： @Configuration @EnableWebMvc @ComponentScan({ \u0026#34;org.baeldung.spring.web.controller\u0026#34; }) public class MvcConfig { // } 9. 结论 本文重点介绍Spring中的***@RequestMapping*注解，讨论一个简单的用例、HTTP 标头的映射、使用@PathVariable绑定部分 URI ，以及使用 URI 参数和@RequestParam注解。 如果您想了解如何在 Spring MVC 中使用另一个核心注解，可以在此处探索*@ModelAttribute*注解。 ","permalink":"http://itcodingman.github.io/spring-requestmapping/","tags":null,"title":""},{"categories":null,"contents":"Spring Security 认证教程 登录/认证  *表单登录* *登录 - 错误处理和本地化* *防止暴力验证尝试* *角色和特权（流行）* *记得我* *持久记住我* *登录后重定向到不同的页面* *登出*  生产级注册流程  *Spring Security 注册教程*  ","permalink":"http://itcodingman.github.io/spring-security-authentication-and-registration/","tags":null,"title":""},{"categories":null,"contents":"Spring Security 注册教程 为您的 Web 应用程序构建一个成熟的、可用于生产的注册不仅仅是将一个简单的注册页面放在一起。 有 很多问题 需要回答：  如何 验证新用户的电子邮件地址 ？ 如何正确安全地 存储用户凭据？ 如果用户 忘记了密码怎么办？ 用户更改自己的密码怎么 办？ 密码应该有多 强？如何在应用程序中强制执行一些合理的默认设置，以便我的用户拥有良好、强密码？ 如果我有不止一种类型的用户怎么办？我需要一种 存储角色和权限的好方法。 安全问题呢 ？我什至应该拥有它们吗？ 如何在良好的本地化支持下完成所有这些工作？涉及的消息很多。  注册流程基础  *注册过程* *通过电子邮件激活新帐户* *注册 - 密码编码* *注册 API 变为 RESTful* *重置你的密码* *密码强度和规则*  高级注册流程  *重新发送验证电子邮件* *更新您的密码* *通知用户从新设备或位置登录*  ","permalink":"http://itcodingman.github.io/spring-security-registration/","tags":null,"title":""},{"categories":null,"contents":"使用 Maven 的 Spring 安全性 一、概述 在本文中，我们将解释如何**使用 Maven 设置 Spring Security，**并介绍使用 Spring Security 依赖项的特定用例。您可以在 Maven Central 上找到最新的 Spring Security 版本。 这是上一篇 Spring with Maven 文章的后续，因此对于非安全 Spring 依赖项，这是开始的地方。 2. 使用 Maven 的 Spring Security 2.1。*弹簧安全核心* 核心 Spring Security 支持 - *spring-security-core* - 包含身份验证和访问控制功能。所有使用 Spring Security 的项目都必须包含此依赖项。 此外，***spring-security-core***支持独立（非 Web）应用程序、方法级安全性和 JDBC： \u0026lt;properties\u0026gt; \u0026lt;spring-security.version\u0026gt;5.3.4.RELEASE\u0026lt;/spring-security.version\u0026gt; \u0026lt;spring.version\u0026gt;5.2.8.RELEASE\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-security.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 请注意，Spring 和 Spring Security 的发布计划不同，因此版本号之间并不总是 1:1 匹配。 如果您使用的是旧版本的 Spring – 同样重要的是要了解一个事实，即**Spring Security 4.1.x 不依赖于 Spring 4.1.x 版本！**例如，当Spring Security 4.1.0发布时，Spring 核心框架已经是 4.2.x，因此包含该版本作为其编译依赖项。计划是在未来的版本中更紧密地调整这些依赖关系——有关更多详细信息，请参阅此 JIRA——但就目前而言，这具有实际意义，我们将在接下来研究。 2.2. *弹簧安全网络* 要为 Spring Security 添加Web 支持，我们需要spring-security-web依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-security.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这包含过滤器和相关的 Web 安全基础设施，可在 Servlet 环境中启用 URL 访问控制。 2.3. Spring Security 和旧的 Spring Core 依赖问题 这种新的依赖关系也表现出Maven 依赖关系图的问题。如上所述，Spring Security jars 不依赖于最新的 Spring core jars（而是依赖于之前的版本）。这可能会导致这些较旧的依赖项出现在类路径之上，而不是较新的 5.x Spring 工件。 要理解为什么会发生这种情况，我们需要看看Maven 如何解决冲突。在版本冲突的情况下，Maven 将选择最接近树根的 jar。例如，spring-core由spring-orm（5.0.0 .RELEASE版本）和spring-security-core（5.0.2.RELEASE版本）定义。所以在这两种情况下，spring-jdbc都定义在我们项目的根 pom 的深度为 1 处。因此，在我们自己的 pom.xml 中定义spring-orm和spring-security-core的顺序实际上很重要。第一个将优先，所以我们最终可能会在类路径中使用任一版本。 为了解决这个问题，我们必须在我们自己的 pom 中显式定义一些 Spring 依赖，而不是依赖隐式的 Maven 依赖解析机制。这样做会将特定依赖项置于我们的 pom 深度 0（因为它在 pom 本身中定义），因此它将优先。以下所有内容都属于同一类别，并且都需要直接明确定义，或者对于多模块项目，在父项的dependencyManagement元素中进行明确定义： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-tx\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-expression\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.4. *spring-security-config*和其他 要使用丰富的 Spring Security XML 命名空间和注释，我们需要spring-security-config依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-security.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 最后，LDAP、ACL、CAS、OAuth 和 OpenID 支持在 Spring Security 中都有自己的依赖项：spring-security-ldap、spring-security-acl、spring-security-cas 、 spring-security-oauth和spring-security-openid。 3. 使用 Spring Boot 使用 Spring Boot 时，spring-boot-starter-security启动器将自动包含所有依赖项，例如spring-security-core、spring-security-web和spring-security-config等： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 由于 Spring Boot 将自动为我们管理所有依赖项，这也将摆脱前面提到的 Spring 安全性和旧的核心依赖项问题。 4. 使用快照和里程碑 Spring Security里程碑和快照在 Spring 提供的自定义 Maven 存储库中可用。有关如何配置这些的更多详细信息，请参阅如何使用快照和里程碑。 5. 结论 在这个快速教程中，我们讨论了将Spring Security 与 Maven结合使用的实际细节。这里介绍的 Maven 依赖项当然是一些主要的依赖项，还有一些其他可能值得一提但尚未成功的依赖项。尽管如此，这应该是在启用 Maven 的项目中使用 Spring 的一个很好的起点。 ","permalink":"http://itcodingman.github.io/spring-security-with-maven/","tags":null,"title":""},{"categories":null,"contents":"Spring @Value 快速指南 一、概述 在这个快速教程中，我们将看一下*@Value* Spring 注释。 此注解可用于将值注入 Spring 管理的 bean 中的字段，并且可以在字段或构造函数/方法参数级别应用。 进一步阅读： 什么是 Spring Bean？ 关于 Spring Bean 是什么的快速实用的解释。 阅读更多→ 使用带有默认值的 Spring @Value 在 Spring 中使用 @Value 注释时设置默认值的快速实用指南。 阅读更多→ 2. 设置应用程序 为了描述这个注解的不同用途，我们需要配置一个简单的 Spring 应用程序配置类。 自然，我们需要一个属性文件来定义我们想要使用*@Value注释注入的值。因此，我们首先需要在我们的配置类中定义一个@PropertySource——使用属性文件名。* 让我们定义属性文件： value.from.file=Value got from the file priority=high listOfValues=A,B,C 3. 使用示例 作为一个基本且几乎无用的示例，我们只能将注释中的“字符串值”注入字段： @Value(\u0026#34;string value\u0026#34;) private String stringValue; 使用*@PropertySource注释允许我们使用带有@Value*注释的属性文件中的值。 在以下示例中，我们从 分配给该字段的文件中获取 Value ： @Value(\u0026#34;${value.from.file}\u0026#34;) private String valueFromFile; 我们还可以使用相同的语法从系统属性中设置值。 假设我们已经定义了一个名为systemValue的系统属性： @Value(\u0026#34;${systemValue}\u0026#34;) private String systemValue; 可以为可能未定义的属性提供默认值。在这里， 将注入一些默认值： @Value(\u0026#34;${unknown.param:some default}\u0026#34;) private String someDefault; 如果相同的属性被定义为系统属性并在属性文件中，则系统属性将被应用。 假设我们将属性优先级定义为系统属性，其值为System 属性，并在属性文件中定义为其他内容。该值将是系统属性： @Value(\u0026#34;${priority}\u0026#34;) private String prioritySystemProperty; 有时，我们需要注入一堆值。将它们定义为属性文件中单个属性的逗号分隔值或系统属性并注入数组会很方便。 在第一节中，我们在属性文件的listOfValues中定义了逗号分隔的值**，因此数组值将是[“A”, “B”, “C”]： @Value(\u0026#34;${listOfValues}\u0026#34;) private String[] valuesArray; 4. SpEL 的高级示例 我们还可以使用 SpEL 表达式来获取值。 如果我们有一个名为*priority 的系统属性，*那么它的值将应用于该字段： @Value(\u0026#34;#{systemProperties[\u0026#39;priority\u0026#39;]}\u0026#34;) private String spelValue; 如果我们没有定义系统属性，那么将分配空值。 为了防止这种情况，我们可以在 SpEL 表达式中提供一个默认值。如果未定义系统属性，我们将获得该字段的一些默认值： @Value(\u0026#34;#{systemProperties[\u0026#39;unknown\u0026#39;] ?: \u0026#39;some default\u0026#39;}\u0026#34;) private String spelSomeDefault; 此外，我们可以使用来自其他 bean 的字段值。假设我们有一个名为someBean的 bean ，其字段someValue等于10。然后，10将分配给该字段： @Value(\u0026#34;#{someBean.someValue}\u0026#34;) private Integer someBeanValue; 我们可以操作属性来获取值列表，这里是字符串值 A、B 和 C 的列表： @Value(\u0026#34;#{\u0026#39;${listOfValues}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) private List\u0026lt;String\u0026gt; valuesList; 5. 将*@Value与地图一起使用* 我们还可以使用*@Value注解来注入Map*属性。 首先，我们需要在属性文件的*{key: \u0026lsquo;value\u0026rsquo; }*表单中定义属性： valuesMap={key1: \u0026#39;1\u0026#39;, key2: \u0026#39;2\u0026#39;, key3: \u0026#39;3\u0026#39;} 请注意，*地图*中的值必须用单引号引起来。 现在我们可以将属性文件中的这个值作为Map注入： @Value(\u0026#34;#{${valuesMap}}\u0026#34;) private Map\u0026lt;String, Integer\u0026gt; valuesMap; 如果我们需要在Map中获取特定键的值，我们所要做的就是在表达式中添加键的名称： @Value(\u0026#34;#{${valuesMap}.key1}\u0026#34;) private Integer valuesMapKey1; 如果我们不确定Map是否包含某个键，我们应该选择一个更安全的表达式，它不会抛出异常，而是在找不到键时将值设置为*null ：* @Value(\u0026#34;#{${valuesMap}[\u0026#39;unknownKey\u0026#39;]}\u0026#34;) private Integer unknownMapKey; 我们还可以为可能不存在的属性或键设置默认值： @Value(\u0026#34;#{${unknownMap : {key1: \u0026#39;1\u0026#39;, key2: \u0026#39;2\u0026#39;}}}\u0026#34;) private Map\u0026lt;String, Integer\u0026gt; unknownMap; @Value(\u0026#34;#{${valuesMap}[\u0026#39;unknownKey\u0026#39;] ?: 5}\u0026#34;) private Integer unknownMapKeyWithDefaultValue; *映射*条目也可以在注入之前进行过滤。 假设我们只需要获取值大于 1 的条目： @Value(\u0026#34;#{${valuesMap}.?[value\u0026gt;\u0026#39;1\u0026#39;]}\u0026#34;) private Map\u0026lt;String, Integer\u0026gt; valuesMapFiltered; 我们还可以使用*@Value*注解注入所有当前系统属性： @Value(\u0026#34;#{systemProperties}\u0026#34;) private Map\u0026lt;String, String\u0026gt; systemPropertiesMap; 6. 将*@Value*与构造函数注入一起使用 当我们使用*@Value*注解时，我们并不局限于字段注入。我们也可以将它与构造函数注入一起使用。 让我们在实践中看看： @Component @PropertySource(\u0026#34;classpath:values.properties\u0026#34;) public class PriorityProvider { private String priority; @Autowired public PriorityProvider(@Value(\u0026#34;${priority:normal}\u0026#34;) String priority) { this.priority = priority; } // standard getter } 在上面的示例中，我们将优先级直接注入到PriorityProvider的构造函数中。 请注意，我们还提供默认值以防找不到该属性。 7. 使用*@Value*和 Setter 注入 类似于构造函数注入，我们也可以使用*@Value*和 setter 注入。 让我们来看看： @Component @PropertySource(\u0026#34;classpath:values.properties\u0026#34;) public class CollectionProvider { private List\u0026lt;String\u0026gt; values = new ArrayList\u0026lt;\u0026gt;(); @Autowired public void setValues(@Value(\u0026#34;#{\u0026#39;${listOfValues}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) List\u0026lt;String\u0026gt; values) { this.values.addAll(values); } // standard getter } 我们使用 SpEL 表达式将值列表注入到setValues方法中。 8. 结论 在本文中，我们研究了将*@Value*注释与文件中定义的简单属性、系统属性以及使用 SpEL 表达式计算的属性一起使用的各种可能性。 ","permalink":"http://itcodingman.github.io/spring-value-annotation/","tags":null,"title":""},{"categories":null,"contents":"使用带有默认值的 Spring @Value 一、概述 Spring 的*@Value*注解提供了一种将属性值注入组件的便捷方式。为可能不存在属性的情况提供合理的默认值也非常有用。 这就是我们将在本教程中关注的内容——如何为*@Value* Spring 注解指定默认值。 有关*@Value*的更详细的快速指南，请参阅此处的文章。 进一步阅读： Spring @Value 快速指南 学习使用 Spring @Value 注解从属性文件、系统属性等配置字段。 阅读更多→ Spring 和 Spring Boot 的属性 关于如何在 Spring 中使用属性文件和属性值的教程。 阅读更多→ Spring 表达式语言指南 本文探讨 Spring 表达式语言 (SpEL)，它是一种强大的表达式语言，支持在运行时查询和操作对象图。 阅读更多→ 2. 字符串默认值 让我们看一下为String属性设置默认值的基本语法： @Value(\u0026#34;${some.key:my default value}\u0026#34;) private String stringWithDefaultValue; 如果some.key无法解析，stringWithDefaultValue**将设置为我的 default value 的默认值。 同样，我们可以设置一个长度为零的字符串作为默认值： @Value(\u0026#34;${some.key:})\u0026#34; private String stringWithBlankDefaultValue; 3. 原语 要为boolean和int等基本类型设置默认值，我们使用文字值： @Value(\u0026#34;${some.key:true}\u0026#34;) private boolean booleanWithDefaultValue; @Value(\u0026#34;${some.key:42}\u0026#34;) private int intWithDefaultValue; 如果我们愿意，我们可以通过将类型更改为Boolean和Integer来使用原始包装器。 4. 数组 我们还可以将逗号分隔的值列表注入数组： @Value(\u0026#34;${some.key:one,two,three}\u0026#34;) private String[] stringArrayWithDefaults; @Value(\u0026#34;${some.key:1,2,3}\u0026#34;) private int[] intArrayWithDefaults; 在上面的第一个示例中，值one、two 和three作为默认值注入到stringArrayWithDefaults中。 在第二个示例中，值1、2 和3作为默认值注入到intArrayWithDefaults中。 5. 使用 SpEL 我们还可以使用 Spring 表达式语言 (SpEL) 来指定表达式和默认值。 在下面的示例中，我们希望将 some.system.key设置为系统属性，如果未设置，我们希望使用我的默认系统属性值 作为默认值： @Value(\u0026#34;#{systemProperties[\u0026#39;some.key\u0026#39;] ?: \u0026#39;my default system property value\u0026#39;}\u0026#34;) private String spelWithDefaultValue; 六，结论 在这篇快速文章中，我们了解了如何为希望使用 Spring 的*@Value*注释注入其值的属性设置默认值。 ","permalink":"http://itcodingman.github.io/spring-value-defaults/","tags":null,"title":""},{"categories":null,"contents":"为什么选择 Spring 作为您的 Java 框架？ 一、概述 在本文中，我们将介绍Spring作为最流行的 Java 框架之一的主要价值主张。 更重要的是，我们将尝试了解 Spring 成为我们选择框架的原因。Spring 及其组成部分的详细信息已在我们之前的教程中广泛介绍。因此，我们将跳过介绍性的“如何”部分，而主要关注“为什么”。 2. 为什么使用任何框架？ 在我们开始特别讨论 Spring 之前，让我们首先了解为什么我们首先需要使用任何框架。 像 Java 这样的通用编程语言能够支持各种各样的应用程序。更不用说 Java 每天都在积极地工作和改进。 此外，在这方面有无数的开源和专有库支持 Java。 那么我们到底为什么需要一个框架呢？老实说，使用框架来完成任务并不是绝对必要的。但是，出于以下几个原因，通常建议使用其中一种：  帮助我们专注于核心任务而不是与其相关的样板 以设计模式的形式汇集多年的智慧 帮助我们遵守行业和监管标准 降低应用程序的总拥有成本  我们只是在这里触及了表面，我们必须说这些好处是难以忽视的。但这不可能都是积极的，所以有什么问题：  迫使我们以特定的方式编写应用程序 绑定到特定版本的语言和库 增加应用程序的资源占用  坦率地说，软件开发中没有灵丹妙药，框架当然也不例外。因此，应该从上下文中驱动选择哪个框架或不选择哪个框架。 希望在本文结束时，我们能够更好地做出关于 Java 中的 Spring 的决定。 三、Spring生态系统简介 在我们开始对 Spring Framework 进行定性评估之前，让我们仔细看看 Spring 生态系统是什么样的。 **Spring 出现在 2003 年的某个地方，**当时 Java 企业版正在快速发展，开发企业应用程序令人兴奋但仍然乏味！ Spring 最初是作为Java 的控制反转 (IoC) 容器。我们仍然主要将 Spring 与它联系起来，事实上，它构成了框架的核心以及在它之上开发的其他项目。 3.1。春天框架 Spring 框架分为模块，这使得在任何应用程序中都可以很容易地挑选和选择部分：  核心：提供核心功能，如 DI（依赖注入）、国际化、验证和 AOP（面向方面的编程） 数据访问：支持通过 JTA（Java Transaction API）、JPA（Java Persistence API）和 JDBC（Java 数据库连接）进行数据访问 Web：同时支持 Servlet API ( Spring MVC ) 和最近的 Reactive API ( Spring WebFlux )，另外还支持 WebSockets、STOMP 和 WebClient 集成：支持通过 JMS（Java 消息服务）、JMX（Java 管理扩展）和 RMI（远程方法调用）集成到 Enterprise Java 测试：通过模拟对象、测试装置、上下文管理和缓存对单元和集成测试提供广泛支持  3.2. 春季项目 但是，让 Spring 更有价值的是一个强大的生态系统，多年来围绕它发展并继续积极发展。这些都是在 Spring 框架之上开发的Spring 项目。 虽然 Spring 项目的列表很长，而且还在不断变化，但有几个值得一提：  Boot：为我们提供了一套高度自以为是但可扩展的模板，几乎可以在短时间内创建各种基于 Spring 的项目。它使得使用嵌入式 Tomcat 或类似容器创建独立的 Spring 应用程序变得非常容易。 云：提供支持以轻松开发一些常见的分布式系统模式，如服务发现、断路器和 API 网关。它可以帮助我们减少在本地、远程甚至托管平台上部署此类样板模式的工作量。 安全性：提供强大的机制，以高度可定制的方式为基于 Spring 的项目开发身份验证和授权。通过最少的声明性支持，我们可以防止会话固定、点击劫持和跨站点请求伪造等常见攻击。 移动：提供检测设备并相应地调整应用程序行为的功能。此外，支持设备感知视图管理以获得最佳用户体验、站点偏好管理和站点切换器。 Batch：提供轻量级框架，用于为数据归档等企业系统开发批处理应用程序。对调度、重新启动、跳过、收集指标和日志记录具有直观的支持。此外，支持通过优化和分区扩展大容量作业。  不用说，这是对 Spring 所提供的内容的相当抽象的介绍。但它为我们提供了足够的关于 Spring 的组织和广度的基础来进一步讨论。 4. 春天在行动 习惯上添加一个 hello-world 程序来了解任何新技术。 让我们看看Spring 如何让编写一个不仅仅是 hello-world 的程序变得轻而易举。我们将创建一个应用程序，它将 CRUD 操作公开为 REST API，用于由内存数据库支持的域实体（如 Employee）。更重要的是，我们将使用基本身份验证保护我们的突变端点。最后，没有好的、旧的单元测试，任何应用程序都不可能真正完整。 4.1。项目设置 我们将使用Spring Initializr设置我们的 Spring Boot 项目，这是一个方便的在线工具，可以使用正确的依赖项引导项目。我们将添加 Web、JPA、H2 和 Security 作为项目依赖项，以正确设置 Maven 配置。 有关引导的更多详细信息，请参阅我们之前的一篇文章。 4.2. 领域模型和持久性 要做的事情很少，我们已经准备好定义我们的领域模型和持久性。 让我们首先将Employee定义为一个简单的 JPA 实体： @Entity public class Employee { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @NotNull private String firstName; @NotNull private String lastName; // Standard constructor, getters and setters } 请注意我们在实体定义中包含的自动生成的 ID。 现在我们必须为我们的实体定义一个 JPA 存储库。这是 Spring 让它变得非常简单的地方： public interface EmployeeRepository extends CrudRepository\u0026lt;Employee, Long\u0026gt; { List\u0026lt;Employee\u0026gt; findAll(); } 我们所要做的就是定义一个这样的接口，Spring JPA 将为我们提供一个包含默认和自定义操作的实现。相当整洁！在我们的其他文章中查找有关使用 Spring Data JPA的更多详细信息。 4.3. 控制器 现在我们必须定义一个 Web 控制器来路由和处理我们的传入请求： @RestController public class EmployeeController { @Autowired private EmployeeRepository repository; @GetMapping(\u0026#34;/employees\u0026#34;) public List\u0026lt;Employee\u0026gt; getEmployees() { return repository.findAll(); } // Other CRUD endpoints handlers } 实际上，我们所要做的就是注释类并定义路由元信息以及每个处理程序方法。 我们之前的文章详细介绍了使用Spring REST 控制器。 4.4. 安全 所以我们现在已经定义了一切，但是如何保护诸如创建或删除员工之类的操作呢？我们不希望未经身份验证的访问这些端点！ Spring Security 在这方面确实大放异彩： @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(HttpMethod.GET, \u0026#34;/employees\u0026#34;, \u0026#34;/employees/**\u0026#34;) .permitAll() .anyRequest() .authenticated() .and() .httpBasic(); } // other necessary beans and definitions } 这里有更多细节需要注意理解，但最重要的一点是我们只允许不受限制的 GET 操作的声明方式。 4.5. 测试 现在我们已经完成了所有工作，但是等等，我们如何测试呢？ 让我们看看 Spring 是否可以轻松地为 REST 控制器编写单元测试： @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) @AutoConfigureMockMvc public class EmployeeControllerTests { @Autowired private MockMvc mvc; @Test @WithMockUser() public void givenNoEmployee_whenCreateEmployee_thenEmployeeCreated() throws Exception { mvc.perform(post(\u0026#34;/employees\u0026#34;).content( new ObjectMapper().writeValueAsString(new Employee(\u0026#34;First\u0026#34;, \u0026#34;Last\u0026#34;)) .with(csrf())) .contentType(MediaType.APPLICATION_JSON) .accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status() .isCreated()) .andExpect(jsonPath(\u0026#34;$.firstName\u0026#34;, is(\u0026#34;First\u0026#34;))) .andExpect(jsonPath(\u0026#34;$.lastName\u0026#34;, is(\u0026#34;Last\u0026#34;))); } // other tests as necessary } 正如我们所见，Spring 为我们提供了编写简单单元和集成测试所需的基础设施，否则这些测试依赖于 Spring 上下文进行初始化和配置。 4.6. 运行应用程序 最后，我们如何运行这个应用程序？这是 Spring Boot 的另一个有趣的方面。尽管我们可以将其打包为常规应用程序并传统上部署在 Servlet 容器上。 但是这哪有什么好玩的！Spring Boot 带有一个嵌入式 Tomcat 服务器： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 这是一个作为引导程序的一部分预先创建的类，具有使用嵌入式服务器启动此应用程序的所有必要细节。 此外，这是高度可定制的。 5. Spring 的替代品 虽然选择使用框架相对容易，但在框架之间进行选择通常会因我们的选择而令人生畏。但为此，我们必须至少对 Spring 必须提供的功能有哪些替代方案有一个粗略的了解。 正如我们之前所讨论的，Spring 框架及其项目为企业开发人员提供了广泛的选择。如果我们对当代 Java 框架进行快速评估，它们甚至还没有接近 Spring 为我们提供的生态系统。 但是，对于特定领域，它们确实形成了一个令人信服的论据来选择替代方案：  Guice：为 Java 应用程序提供强大的 IoC 容器 Play：非常适合作为具有响应式支持的 Web 框架 Hibernate : 已建立的支持 JPA 的数据访问框架  除了这些之外，还有一些最近添加的内容提供了比特定域更广泛的支持，但仍然没有涵盖 Spring 必须提供的所有内容：  Micronaut：针对云原生微服务量身定制的基于 JVM 的框架 Quarkus：一个新时代的 Java 堆栈，承诺提供更快的启动时间和更小的占用空间  显然，完全迭代列表既没有必要也不可行，但我们确实在这里得到了大致的想法。 6. 那么，为什么选择春天？ 最后，我们已经构建了所有必需的上下文来解决我们的中心问题，为什么是 Spring？我们了解框架可以帮助我们开发复杂的企业应用程序的方式。 此外，我们确实了解针对特定问题的选择，例如 Web、数据访问、框架集成，尤其是 Java。 现在，春天在所有这些中闪耀在哪里？让我们探索一下。 6.1。可用性 任何框架流行的关键方面之一是开发人员使用它的难易程度。Spring 通过多个配置选项和 Convention over Configuration 使开发人员能够非常轻松地开始并准确地配置他们需要的东西。 像Spring Boot 这样的项目使得引导一个复杂的 Spring 项目几乎是微不足道的。更不用说，它有优秀的文档和教程来帮助任何人上手。 6.2. 模块化 Spring 受欢迎的另一个关键方面是其高度模块化的特性。我们可以选择使用整个 Spring 框架或仅使用必要的模块。此外，我们可以根据需要选择包含一个或多个 Spring 项目。 更重要的是，我们还可以选择使用其他框架，如 Hibernate 或 Struts！ 6.3. 一致性 尽管 Spring不支持所有 Jakarta EE 规范，但它支持其所有技术，并且经常在必要时改进对标准规范的支持。例如，Spring 支持基于 JPA 的存储库，因此可以轻松切换提供程序。 此外，Spring 支持Spring Web Reactive 下的Reactive Stream和Spring HATEOAS 下的 HATEOAS 等行业规范。 6.4. 可测试性 采用任何框架很大程度上还取决于测试构建在它之上的应用程序的难易程度。Spring 的核心是倡导并支持测试驱动开发(TDD)。 Spring 应用程序主要由 POJO 组成，这自然使单元测试相对简单得多。但是，Spring 确实为 MVC 等单元测试变得复杂的场景提供了 Mock Objects。 6.5。到期 Spring 在创新、采用和标准化方面有着悠久的历史。多年来，它已经足够成熟，成为大型企业应用程序开发中面临的最常见问题的默认解决方案。 更令人兴奋的是它的开发和维护有多积极。每天都在开发对新语言功能和企业集成解决方案的支持。 6.6. 社区支持 最后但同样重要的是，任何框架甚至库都通过创新在行业中生存下来，没有比社区更好的创新场所了。Spring 是由 Pivotal Software 领导的开源项目，并得到了一个由组织和个人开发人员组成的大型联盟的支持。 这意味着它仍然是上下文相关的，而且往往是未来主义的，这一点从它旗下的项目数量就可以看出。 7.不使用 Spring 的原因 有各种各样的应用程序可以从不同级别的 Spring 使用中受益，并且随着 Spring 的增长而变化。 但是，我们必须了解 Spring 与任何其他框架一样有助于管理应用程序开发的复杂性。它可以帮助我们避免常见的陷阱，并随着时间的推移保持应用程序的可维护性。 这是以额外的资源占用和学习曲线为代价的，尽管这可能很小。如果真的有一个足够简单且不会变得复杂的应用程序，那么完全不使用任何框架可能会受益更多！ 8. 结论 在本文中，我们讨论了在应用程序开发中使用框架的好处。我们进一步简要讨论了特别是 Spring Framework。 在这个主题上，我们还研究了一些可用于 Java 的替代框架。 最后，我们讨论了促使我们选择 Spring 作为 Java 框架的原因。 不过，我们应该以一些建议来结束这篇文章。不管听起来多么引人注目，在软件开发中通常没有单一的、一刀切的解决方案。 ","permalink":"http://itcodingman.github.io/spring-why-to-choose/","tags":null,"title":""},{"categories":null,"contents":"Maven 的春天 一、概述 本教程说明了如何通过 Maven 设置Spring 依赖项。最新的 Spring 版本可以在 Maven Central上找到。 2. Maven 的基本 Spring 依赖 Spring 被设计成高度模块化的——使用 Spring 的一部分不应该也不需要另一部分。例如，基本的 Spring Context 可以没有 Persistence 或 MVC Spring 库。 让我们从一个基本的Maven 设置开始，它只使用spring *-context*依赖： \u0026lt;properties\u0026gt; \u0026lt;org.springframework.version\u0026gt;5.2.8.RELEASE\u0026lt;/org.springframework.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.springframework.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 这个依赖***——spring-context——定义了实际的 Spring Injection Container，并且有少量的依赖：spring-core、spring-expression、spring-aop和spring-beans。这些通过支持一些核心 Spring 技术*来增强容器：核心 Spring 实用程序、Spring 表达式语言(SpEL)、面向方面的编程支持和JavaBeans 机制。 请注意，我们在运行时*范围内定义依赖项——这将确保在任何 Spring 特定 API 上都没有编译时依赖项。对于更高级的用例，可能会从一些选定的 Spring 依赖项中删除运行时范围，但对于更简单的项目，*无需针对 Spring 进行编译以充分利用框架。 另请注意，JDK 8 是 Spring 5.2 所需的最低 Java 版本。它还支持 JDK 11 作为当前的 LTS 分支和 JDK 13 作为最新的 OpenJDK 版本。 3. Maven 的 Spring 持久性 现在让我们看看持久性 Spring 依赖项——主要是spring-orm： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-orm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.springframework.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这附带了 Hibernate 和 JPA 支持——例如HibernateTemplate和JpaTemplate——以及一些额外的与持久性相关的依赖项：spring-jdbc和spring-tx。 JDBC 数据访问库定义了Spring JDBC 支持以及JdbcTemplate，而spring-tx代表了极其灵活的事务管理抽象。 4. 使用 Maven 的 Spring MVC 要使用 Spring Web 和 Servlet 支持，除了上面的核心依赖项之外，还需要在pom中包含两个依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.springframework.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.springframework.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring-web依赖项包含用于 Servlet 和 Portlet 环境的常见 Web 特定实用程序，而spring *-webmvc*启用了对 Servlet 环境的 MVC 支持。 由于spring-webmvc具有spring-web作为依赖项，因此在使用spring-webmvc时不需要显式定义spring-web。 从 Spring 5.0 开始，对于响应式堆栈 Web 框架的支持，我们可以添加Spring WebFlux的依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webflux\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.springframework.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 5. Maven 的 Spring 安全性 安全性 Maven 依赖项在Spring Security with Maven文章中进行了深入讨论。 6. 使用 Maven 进行春季测试 Spring Test Framework 可以通过以下依赖项包含在项目中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 使用 Spring 5，我们也可以执行并发测试执行。 7. 使用里程碑 Spring 的发布版本托管在 Maven Central 上。但是，如果项目需要使用里程碑版本，则需要在 pom 中添加自定义 Spring 存储库： \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;repository.springframework.maven.milestone\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Framework Maven Milestone Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.spring.io/milestone/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; 一旦定义了这个存储库，项目就可以定义依赖项，例如： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0-M1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 8. 使用快照 与里程碑类似，快照托管在自定义存储库中： \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;repository.springframework.maven.snapshot\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Framework Maven Snapshot Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.spring.io/snapshot/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; 在 pom.xml 中启用 SNAPSHOT 存储库后，可以引用以下依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.3.BUILD-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 以及 - 对于 5.x： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 9. 结论 本文讨论了将Spring 与 Maven结合使用的实际细节。这里介绍的 Maven 依赖项当然是一些主要的，还有一些其他的可能值得一提，但还没有被淘汰。尽管如此，这应该是在项目中使用 Spring 的一个很好的起点。 ","permalink":"http://itcodingman.github.io/spring-with-maven/","tags":null,"title":""},{"categories":null,"contents":"Spring 中基于 XML 的注入 一、简介 在这个基础教程中，我们将学习如何使用 Spring Framework 进行简单的基于 XML 的 bean 配置。 2. 概述 让我们首先在pom.xml中添加 Spring 的库依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以在[此处](https://search.maven.org/classic/#search|ga|1|g%3A\u0026quot;org.springframework\u0026quot; AND a%3A\u0026quot;spring-context\u0026quot;)找到最新版本的 Spring 依赖项。 3. 依赖注入——概述 依赖注入是一种技术，其中对象的依赖关系由外部容器提供。 假设我们有一个依赖于实际处理业务逻辑的服务的应用程序类： public class IndexApp { private IService service; // standard constructors/getters/setters } 现在假设IService是一个接口： public interface IService { public String serve(); } 这个接口可以有多种实现。 让我们快速看一下一种可能的实现： public class IndexService implements IService { @Override public String serve() { return \u0026#34;Hello World\u0026#34;; } } 在这里，IndexApp是一个高级组件，它依赖于名为**IService的低级组件。 从本质上讲，我们将IndexApp与**IService的特定实现分离，该实现可能会因各种因素而异。 4. 依赖注入——在行动 让我们看看如何注入依赖项。 4.1。使用属性 让我们看看如何使用基于 XML 的配置将依赖项连接在一起： \u0026lt;bean id=\u0026#34;indexService\u0026#34; class=\u0026#34;com.baeldung.di.spring.IndexService\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;indexApp\u0026#34; class=\u0026#34;com.baeldung.di.spring.IndexApp\u0026#34; \u0026gt; \u0026lt;property name=\u0026#34;service\u0026#34; ref=\u0026#34;indexService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 可以看出，我们正在创建一个IndexService实例并为其分配一个 id。默认情况下，bean 是单例的。此外，我们正在创建一个IndexApp实例。 在这个 bean 中，我们使用 setter 方法注入另一个 bean。 4.2. 使用构造函数 我们可以使用构造函数注入依赖项，而不是通过 setter 方法注入 bean： \u0026lt;bean id=\u0026#34;indexApp\u0026#34; class=\u0026#34;com.baeldung.di.spring.IndexApp\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;indexService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 4.3. 使用静态工厂 我们还可以注入工厂返回的 bean。让我们创建一个简单的工厂，它根据提供的数字返回IService的实例： public class StaticServiceFactory { public static IService getNumber(int number) { // ...  } } 现在让我们看看如何使用上面的实现通过基于 XML 的配置将 bean 注入IndexApp ： \u0026lt;bean id=\u0026#34;messageService\u0026#34; class=\u0026#34;com.baeldung.di.spring.StaticServiceFactory\u0026#34; factory-method=\u0026#34;getService\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;indexApp\u0026#34; class=\u0026#34;com.baeldung.di.spring.IndexApp\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;service\u0026#34; ref=\u0026#34;messageService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 在上面的示例中，我们使用工厂方法调用静态**getService方法来创建一个 id为messageService的 bean ，我们将其注入IndexApp。 4.4. 使用工厂方法 让我们考虑一个实例工厂，它根据提供的数字返回一个*IService实例。*这一次，方法不是静态的： public class InstanceServiceFactory { public IService getNumber(int number) { // ...  } } 现在让我们看看如何使用上述实现通过 XML 配置将 bean 注入IndexApp ： \u0026lt;bean id=\u0026#34;indexServiceFactory\u0026#34; class=\u0026#34;com.baeldung.di.spring.InstanceServiceFactory\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;messageService\u0026#34; class=\u0026#34;com.baeldung.di.spring.InstanceServiceFactory\u0026#34; factory-method=\u0026#34;getService\u0026#34; factory-bean=\u0026#34;indexServiceFactory\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;indexApp\u0026#34; class=\u0026#34;com.baeldung.di.spring.IndexApp\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;service\u0026#34; ref=\u0026#34;messageService\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 在上面的示例中，我们使用工厂方法在InstanceServiceFactory 实例上调用getService方法，以创建一个 id 为messageService的 bean ，我们将其注入IndexApp。 5. 测试 这就是我们可以访问配置的 bean 的方式： @Test public void whenGetBeans_returnsBean() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;...\u0026#34;); IndexApp indexApp = applicationContext.getBean(\u0026#34;indexApp\u0026#34;, IndexApp.class); assertNotNull(indexApp); } 六，结论 在这个快速教程中，我们举例说明了如何使用 Spring Framework 使用基于 XML 的配置来注入依赖项。 ","permalink":"http://itcodingman.github.io/spring-xml-injection/","tags":null,"title":""},{"categories":null,"contents":"使用 Spring 的 JPA 指南 一、概述 本教程展示了如何使用 Hibernate 作为持久性提供者来使用JPA 设置 Spring 。 有关使用基于 Java 的配置和项目的基本 Maven pom 设置 Spring 上下文的分步介绍，请参阅本文。 我们将从在 Spring Boot 项目中设置 JPA 开始。然后，如果我们有一个标准的 Spring 项目，我们将研究我们需要的完整配置。 进一步阅读： 定义 JPA 实体 了解如何使用 Java Persistence API 定义实体并对其进行自定义。 阅读更多→ 带有休眠功能的 Spring Boot 一个快速实用的集成 Spring Boot 和 Hibernate/JPA 的介绍。 阅读更多→ 这是一个关于使用 Spring 4 设置 Hibernate 4 的视频（我们建议以完整的 1080p 观看）： 2. Spring Boot 中的 JPA Spring Boot 项目旨在使创建 Spring 应用程序更快、更容易。这是通过对各种 Spring 功能使用启动器和自动配置来完成的，其中包括 JPA。 2.1。Maven 依赖项 要在 Spring Boot 应用程序中启用 JPA，我们需要*[spring-boot-starter](https://search.maven.org/classic/#search|ga|1|a%3A\u0026quot;spring-boot-starter\u0026quot; AND g%3A\u0026quot;org.springframework.boot\u0026quot;)和spring-boot-starter-data-jpa*依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring-boot-starter包含 Spring JPA的必要自动配置。此外，spring-boot-starter-jpa项目引用了所有必要的依赖项，例如hibernate-core。 2.2. 配置 Spring Boot 将*Hibernate*配置为默认的 JPA 提供程序，因此不再需要定义entityManagerFactory bean，除非我们想要自定义它。 **Spring Boot 还可以根据我们使用的数据库自动配置*dataSource bean。***对于H2、HSQLDB 和Apache Derby类型的内存数据库，如果类路径上存在相应的数据库依赖项，则 Boot 会自动配置DataSource 。 例如，如果我们想在 Spring Boot JPA 应用程序中使用内存中的H2数据库，我们只需要在pom.xml文件中添加[h2](https://search.maven.org/classic/#search|ga|1|a%3A\u0026quot;h2\u0026quot; AND g%3A\u0026quot;com.h2database\u0026quot;)依赖项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这样，我们不需要定义dataSource bean，但如果我们想自定义它，我们可以。 如果我们想将 JPA 与MySQL数据库一起使用，我们需要mysql-connector-java依赖项。我们还需要定义DataSource配置。 我们可以在*@Configuration*类中或使用标准 Spring Boot 属性来执行此操作。 Java 配置看起来与标准 Spring 项目中的配置相同： @Bean public DataSource dataSource() { DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dataSource.setUsername(\u0026#34;mysqluser\u0026#34;); dataSource.setPassword(\u0026#34;mysqlpass\u0026#34;); dataSource.setUrl( \u0026#34;jdbc:mysql://localhost:3306/myDb?createDatabaseIfNotExist=true\u0026#34;); return dataSource; } **要使用属性文件配置数据源，我们必须设置以*spring.datasource***为前缀的属性： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=mysqluser spring.datasource.password=mysqlpass spring.datasource.url= jdbc:mysql://localhost:3306/myDb?createDatabaseIfNotExist=true Spring Boot 会根据这些属性自动配置一个数据源。 同样在 Spring Boot 1 中，默认连接池为Tomcat，但在 Spring Boot 2 中已更改为HikariCP。 我们在GitHub 项目中有更多在 Spring Boot 中配置 JPA 的示例。 正如我们所见，如果我们使用 Spring Boot，基本的 JPA 配置相当简单。 但是，**如果我们有一个标准的 Spring 项目，我们需要更明确的配置，使用 Java 或 XML。**这就是我们将在接下来的部分中关注的内容。 3. 非引导项目中使用 Java 的 JPA Spring 配置 要在 Spring 项目中使用 JPA，我们需要设置*EntityManager*。 这是配置的主要部分，我们可以通过 Spring 工厂 bean 来完成。这可以是更简单的LocalEntityManagerFactoryBean或更灵活的*LocalContainerEntityManagerFactoryBean*。 让我们看看如何使用后一个选项： @Configuration @EnableTransactionManagement public class PersistenceJPAConfig{ @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory() { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(dataSource()); em.setPackagesToScan(new String[] { \u0026#34;com.baeldung.persistence.model\u0026#34; }); JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter(); em.setJpaVendorAdapter(vendorAdapter); em.setJpaProperties(additionalProperties()); return em; } // ...  } 我们还需要显式定义我们上面使用的*DataSource* bean ： @Bean public DataSource dataSource(){ DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:mysql://localhost:3306/spring_jpa\u0026#34;); dataSource.setUsername( \u0026#34;tutorialuser\u0026#34; ); dataSource.setPassword( \u0026#34;tutorialmy5ql\u0026#34; ); return dataSource; } 配置的最后一部分是附加的 Hibernate 属性以及TransactionManager和exceptionTranslation bean： @Bean public PlatformTransactionManager transactionManager() { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(entityManagerFactory().getObject()); return transactionManager; } @Bean public PersistenceExceptionTranslationPostProcessor exceptionTranslation(){ return new PersistenceExceptionTranslationPostProcessor(); } Properties additionalProperties() { Properties properties = new Properties(); properties.setProperty(\u0026#34;hibernate.hbm2ddl.auto\u0026#34;, \u0026#34;create-drop\u0026#34;); properties.setProperty(\u0026#34;hibernate.dialect\u0026#34;, \u0026#34;org.hibernate.dialect.MySQL5Dialect\u0026#34;); return properties; } 4. JPA Spring 配置 XML 接下来，让我们看一下使用 XML 的相同 Spring 配置： \u0026lt;bean id=\u0026#34;myEmf\u0026#34; class=\u0026#34;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;packagesToScan\u0026#34; value=\u0026#34;com.baeldung.persistence.model\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;jpaVendorAdapter\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\u0026#34; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jpaProperties\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.hbm2ddl.auto\u0026#34;\u0026gt;create-drop\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;hibernate.dialect\u0026#34;\u0026gt;org.hibernate.dialect.MySQL5Dialect\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/spring_jpa\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;tutorialuser\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;tutorialmy5ql\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.orm.jpa.JpaTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;entityManagerFactory\u0026#34; ref=\u0026#34;myEmf\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;tx:annotation-driven /\u0026gt; \u0026lt;bean id=\u0026#34;persistenceExceptionTranslationPostProcessor\u0026#34; class= \u0026#34;org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\u0026#34; /\u0026gt; XML 和新的基于 Java 的配置之间存在相对较小的差异。也就是说，在 XML 中，对另一个 bean 的引用可以指向该 bean 或该 bean 的 bean 工厂。 但在 Java 中，由于类型不同，编译器不允许这样做，因此首先从其 bean 工厂中检索EntityManagerFactory ，然后将其传递给事务管理器： transactionManager.setEntityManagerFactory(entityManagerFactory().getObject()); 5. 完全无 XML 通常，JPA 通过META-INF/persistence.xml文件定义一个持久化单元。从 Spring 3.1 开始，*persistence.xml*不再需要。LocalContainerEntityManagerFactoryBean现在支持packagesToScan属性，其中可以指定要扫描@Entity类的包。 该文件是我们需要删除的最后一段 XML。我们现在可以在没有 XML 的情况下完全设置 JPA。 我们通常会在persistence.xml文件中指定 JPA 属性。 或者，我们可以将属性直接添加到实体管理器工厂 bean： factoryBean.setJpaProperties(this.additionalProperties()); 附带说明一下，如果 Hibernate 是持久性提供程序，那么这也是指定 Hibernate 特定属性的方法。 6. Maven 配置 除了 Spring Core 和持久性依赖项（在Spring with Maven 教程中有详细介绍）之外，我们还需要在项目中定义 JPA 和 Hibernate 以及 MySQL 连接器： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.17.Final\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.19\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 请注意，此处包含 MySQL 依赖项作为示例。我们需要一个驱动程序来配置数据源，但是任何支持 Hibernate 的数据库都可以。 7. 结论 本教程说明了如何在Spring Boot 和标准 Spring 应用程序中使用 Spring 中的Hibernate 配置 JPA 。 ","permalink":"http://itcodingman.github.io/the-persistence-layer-with-spring-and-jpa/","tags":null,"title":""},{"categories":null,"contents":"Spring Data JPA 简介 一、概述 本教程将重点**介绍将 Spring Data JPA 引入 Spring 项目，**并全面配置持久层。有关使用基于 Java 的配置和项目的基本 Maven pom 设置 Spring 上下文的分步介绍，请参阅本文。 进一步阅读： 使用 Spring 的 JPA 指南 使用 Spring 设置 JPA - 如何设置 EntityManager 工厂并使用原始 JPA API。 阅读更多→ Spring Data 中的 CrudRepository、JpaRepository 和 PagingAndSortingRepository 了解 Spring Data 提供的不同风格的存储库。 阅读更多→ 使用 Spring 和 Java 泛型简化 DAO 通过使用单个通用 DAO 来简化数据访问层，这将导致优雅的数据访问，没有不必要的混乱。 阅读更多→ 2. Spring Data Generated DAO – 不再有 DAO 实现 正如我们在之前的文章中所讨论的，DAO 层通常由许多可以而且应该被简化的样板代码组成。这种简化的优点有很多：减少了我们需要定义和维护的工件数量、数据访问模式的一致性以及配置的一致性。 Spring Data 将这种简化更进一步，使得完全删除 DAO 实现成为可能。DAO 的接口现在是我们需要明确定义的唯一工件。 为了开始利用 JPA 的 Spring Data 编程模型，DAO 接口需要扩展 JPA 特定的Repository接口JpaRepository。这将使 Spring Data 能够找到这个接口并自动为其创建一个实现。 通过扩展接口，我们获得了标准 DAO 中可用的标准数据访问最相关的 CRUD 方法。 3.自定义访问方法和查询 如前所述，通过实现*Repository*接口之一，DAO 将已经定义和实现了一些基本的 CRUD 方法（和查询）。 为了定义更具体的访问方法，Spring JPA 支持很多选项：  只需在接口中定义一个新方法 使用*@Query*注释提供实际的JPQL 查询 在 Spring Data 中使用更高级的Specification 和 Querydsl 支持 通过 JPA 命名查询定义自定义查询  第三个选项Specifications and Querydsl support 与 JPA Criteria 类似，但使用了更灵活方便的 API。这使得整个操作更具可读性和可重用性。当处理大量固定查询时，此 API 的优势将变得更加明显，因为我们可以通过较少数量的可重用块更简洁地表达这些。 最后一个选项的缺点是它要么涉及 XML，要么给域类增加了查询负担。 3.1。自动自定义查询 当 Spring Data 创建一个新的Repository实现时，它会分析接口定义的所有方法，并尝试从方法名称自动生成查询。虽然这有一些限制，但它是一种非常强大且优雅的方式，可以轻松定义新的自定义访问方法。 让我们看一个例子。如果实体有一个名称字段（以及 Java Bean 标准的getName和setName方法），**我们将在 DAO 接口中定义*findByName方法。***这将自动生成正确的查询： public interface IFooDAO extends JpaRepository\u0026lt;Foo, Long\u0026gt; { Foo findByName(String name); } 这是一个比较简单的例子。查询创建机制支持更大的关键字集。 如果解析器无法将属性与域对象字段匹配，我们将看到以下异常： java.lang.IllegalArgumentException: No property nam found for type class com.baeldung.spring.data.persistence.model.Foo 3.2. 手动自定义查询 现在让我们看一下我们将通过*@Query*注释定义的自定义查询： @Query(\u0026#34;SELECT f FROM Foo f WHERE LOWER(f.name) = LOWER(:name)\u0026#34;) Foo retrieveByName(@Param(\u0026#34;name\u0026#34;) String name); 要对查询的创建进行更细粒度的控制，例如使用命名参数或修改现有查询，参考是一个很好的起点。 4.交易配置 Spring 管理的 DAO 的实际实现确实是隐藏的，因为我们不直接使用它。但是，它是一个足够简单的实现，即*SimpleJpaRepository，*它使用 annotations 定义事务语义。 更明确地说，这在类级别使用只读*@Transactional*注释，然后为非只读方法覆盖该注释。其余的事务语义是默认的，但是这些可以很容易地被每个方法手动覆盖。 4.1。异常翻译很活跃 现在的问题变成了：由于 Spring Data JPA 不依赖于旧的 ORM 模板（JpaTemplate、HibernateTemplate），并且自 Spring 5 以来它们已被删除，我们是否仍将 JPA 异常转换为 Spring 的DataAccessException层次结构？ 答案是，当然，我们是。通过在 DAO 上使用@Repository*注释仍然可以启用异常翻译。此注解使 Spring bean 后处理器能够通知所有@Repository* bean 以及在容器中找到的所有PersistenceExceptionTranslator实例，并像以前一样提供异常翻译。 让我们通过集成测试来验证异常翻译： @Test(expected = DataIntegrityViolationException.class) public void givenFooHasNoName_whenInvalidEntityIsCreated_thenDataException() { service.create(new Foo()); } 请记住，**异常翻译是通过代理完成的。**为了让 Spring 能够围绕 DAO 类创建代理，这些代理不能被声明为final。 5. Spring Data JPA 存储库配置 要激活 Spring JPA 存储库支持，我们可以使用*@EnableJpaRepositories*注释并指定包含 DAO 接口的包： @EnableJpaRepositories(basePackages = \u0026#34;com.baeldung.spring.data.persistence.repository\u0026#34;) public class PersistenceConfig { ... } 我们可以对 XML 配置做同样的事情： \u0026lt;jpa:repositories base-package=\u0026#34;com.baeldung.spring.data.persistence.repository\u0026#34; /\u0026gt; 6. Java 或 XML 配置 我们已经在之前的文章中详细讨论了如何在 Spring 中配置 JPA 。Spring Data 还利用了 Spring 对 JPA @PersistenceContext注释的支持。它使用它将EntityManager连接到负责创建实际 DAO 实现JpaRepositoryFactoryBean的 Spring 工厂 bean 。 除了已经讨论过的配置，如果我们使用 XML，我们还需要包含 Spring Data XML 配置： @Configuration @EnableTransactionManagement @ImportResource(\u0026#34;classpath*:*springDataConfig.xml\u0026#34;) public class PersistenceJPAConfig { ... } 7. Maven依赖 除了 JPA 的 Maven 配置之外，就像在之前的文章中一样，我们将添加[spring -data-jpa依赖](https://search.maven.org/search?q=g:org.springframework.data a:spring-data-jpa)项： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 8. 使用 Spring Boot 我们还可以使用Spring Boot Starter Data JPA依赖项，它会自动为我们配置*DataSource*。 我们需要确保我们要使用的数据库存在于类路径中。在我们的示例中，我们添加了 H2 内存数据库： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 结果，只需执行这些依赖项，我们的应用程序就可以启动并运行，我们可以将其用于其他数据库操作。 标准 Spring 应用程序的显式配置现在包含在 Spring Boot 自动配置中。 当然，我们可以通过添加我们自定义的显式配置来修改自动配置。 Spring Boot 提供了一种使用application.properties文件中的属性的简单方法。让我们看一个更改连接 URL 和凭据的示例： spring.datasource.url=jdbc:h2:mem:db;DB_CLOSE_DELAY=-1 spring.datasource.username=sa spring.datasource.password=sa 9. Spring Data JPA 的有用工具 所有主要的 Java IDE 都支持 Spring Data JPA。让我们看看 Eclipse 和 IntelliJ IDEA 有哪些有用的工具。 **如果你使用 Eclipse 作为你的 IDE，你可以安装Dali Java Persistence Tools插件。**这提供了 JPA 实体的 ER 图、用于初始化模式的 DDL 生成以及基本的逆向工程功能。此外，您还可以使用 Eclipse Spring Tool Suite (STS)。它将有助于验证 Spring Data JPA 存储库中的查询方法名称。 如果您使用 IntelliJ IDEA，有两个选项。 IntelliJ IDEA Ultimate 支持 ER 图、用于测试 JPQL 语句的 JPA 控制台和有价值的检查。但是，这些功能在 Community Edition 中不可用。 **为了提高 IntelliJ 的生产力，您可以安装JPA Buddy插件，**它提供了许多功能，包括生成 JPA 实体、Spring Data JPA 存储库、DTO、初始化 DDL 脚本、Flyway 版本化迁移、Liquibase 更改日志等。此外，JPA Buddy 提供逆向工程的高级工具。 最后，JPA Buddy 插件适用于社区版和终极版。 10. 结论 在本文中，我们介绍了使用基于 XML 和 Java 的配置的 Spring 5、JPA 2 和 Spring Data JPA（Spring Data 伞形项目的一部分）的持久层的配置和实现。 我们讨论了定义更高级的自定义查询、事务语义以及使用新*jpa*命名空间的配置的方法。最终结果是使用 Spring 对数据访问进行了新的和优雅的处理，几乎没有实际的实现工作。 ","permalink":"http://itcodingman.github.io/the-persistence-layer-with-spring-data-jpa/","tags":null,"title":""},{"categories":null,"contents":"在 Spring 中使用 Thymeleaf 简介 一、概述 Thymeleaf是一个 Java 模板引擎，用于处理和创建 HTML、XML、JavaScript、CSS 和文本。 在本教程中，我们将讨论如何在 Spring MVC 应用程序的视图层中使用 Thymeleaf以及一些基本用例。 该库具有极强的可扩展性，其自然的模板功能确保我们可以在没有后端的情况下制作模板原型。与其他流行的模板引擎（例如 JSP）相比，这使得开发速度非常快。 2. 将 Thymeleaf 与 Spring 集成 首先，让我们看看与 Spring 集成所需的配置。集成需要thymeleaf -spring库。 我们将以下依赖项添加到我们的 Maven POM 文件中： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 请注意，对于 Spring 4 项目，我们必须使用thymeleaf-spring4库而不是thymeleaf-spring5。 SpringTemplateEngine类执行所有配置步骤。 我们可以在 Java 配置文件中将这个类配置为 bean： @Bean @Description(\u0026#34;Thymeleaf Template Resolver\u0026#34;) public ServletContextTemplateResolver templateResolver() { ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(); templateResolver.setPrefix(\u0026#34;/WEB-INF/views/\u0026#34;); templateResolver.setSuffix(\u0026#34;.html\u0026#34;); templateResolver.setTemplateMode(\u0026#34;HTML5\u0026#34;); return templateResolver; } @Bean @Description(\u0026#34;Thymeleaf Template Engine\u0026#34;) public SpringTemplateEngine templateEngine() { SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver()); templateEngine.setTemplateEngineMessageSource(messageSource()); return templateEngine; } templateResolver bean 属性前缀和后缀分别指示**webapp目录中视图页面的位置及其文件扩展名。 Spring MVC 中的ViewResolver接口将控制器返回的视图名称映射到实际的视图对象。ThymeleafViewResolver实现ViewResolver接口，它用于确定要呈现哪些 Thymeleaf 视图，给定视图名称。 集成的最后一步是将ThymeleafViewResolver添加为 bean： @Bean @Description(\u0026#34;Thymeleaf View Resolver\u0026#34;) public ThymeleafViewResolver viewResolver() { ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setTemplateEngine(templateEngine()); viewResolver.setOrder(1); return viewResolver; } 3. Spring Boot 中的 Thymeleaf Spring Boot通过添加spring-boot-starter-thymeleaf依赖项为Thymeleaf提供自动配置： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 无需显式配置。默认情况下，HTML 文件应放置在资源/模板 位置。 4. 显示来自消息源（属性文件）的值 我们可以使用*th:text=”#{key}”*标签属性来显示属性文件中的值。 为此，我们需要将属性文件配置为messageSource bean： @Bean @Description(\u0026#34;Spring Message Resolver\u0026#34;) public ResourceBundleMessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename(\u0026#34;messages\u0026#34;); return messageSource; } 这是 Thymeleaf HTML 代码，用于显示与键welcome.message关联的值： \u0026lt;span th:text=\u0026#34;#{welcome.message}\u0026#34; /\u0026gt; 5. 显示模型属性 5.1。简单属性 我们可以使用*th:text=”${attributename}”*标签属性来显示模型属性的值。 让我们在控制器类中添加一个名为serverTime的模型属性： model.addAttribute(\u0026#34;serverTime\u0026#34;, dateFormat.format(new Date())); 这是显示serverTime属性值的 HTML 代码： Current time is \u0026lt;span th:text=\u0026#34;${serverTime}\u0026#34; /\u0026gt; 5.2. 集合属性 如果模型属性是对象的集合，我们可以使用th:each标签属性对其进行迭代。 让我们定义一个包含两个字段id 和name的**Student模型类： public class Student implements Serializable { private Integer id; private String name; // standard getters and setters } 现在我们将在控制器类中添加一个学生列表作为模型属性： List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;Student\u0026gt;(); // logic to build student data model.addAttribute(\u0026#34;students\u0026#34;, students); 最后，我们可以使用 Thymeleaf 模板代码遍历学生列表并显示所有字段值： \u0026lt;tbody\u0026gt; \u0026lt;tr th:each=\u0026#34;student: ${students}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${student.id}\u0026#34; /\u0026gt; \u0026lt;td th:text=\u0026#34;${student.name}\u0026#34; /\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; 6.条件评估 6.1。*如果*和*除非* 如果满足条件，我们使用th:if=”${condition}”属性来显示视图的一部分。如果条件不满足，我们使用th:unless=\u0026quot;${condition}\u0026ldquo;属性来显示视图的一部分。 让我们在Student模型中添加一个性别字段： public class Student implements Serializable { private Integer id; private String name; private Character gender; // standard getters and setters } 假设该字段有两个可能的值（M 或 F）来指示学生的性别。 如果我们希望显示单词“Male”或“Female”而不是单个字符，我们可以使用以下 Thymeleaf 代码： \u0026lt;td\u0026gt; \u0026lt;span th:if=\u0026#34;${student.gender} == \u0026#39;M\u0026#39;\u0026#34; th:text=\u0026#34;Male\u0026#34; /\u0026gt; \u0026lt;span th:unless=\u0026#34;${student.gender} == \u0026#39;M\u0026#39;\u0026#34; th:text=\u0026#34;Female\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; 6.2. *开关*和*外壳* 我们使用th:switch和th:case属性来使用 switch 语句结构有条件地显示内容。 让我们使用th:switch和th:case属性重写前面的代码： \u0026lt;td th:switch=\u0026#34;${student.gender}\u0026#34;\u0026gt; \u0026lt;span th:case=\u0026#34;\u0026#39;M\u0026#39;\u0026#34; th:text=\u0026#34;Male\u0026#34; /\u0026gt; \u0026lt;span th:case=\u0026#34;\u0026#39;F\u0026#39;\u0026#34; th:text=\u0026#34;Female\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; 7. 处理用户输入 我们可以使用th:action=”@{url}”和th:object=”${object}”属性来处理表单输入。我们使用th:action 提供表单操作 URL，使用th:object指定提交的表单数据将绑定到的对象。 使用th:field=”*{name}”属性映射各个字段，其中名称是对象的匹配属性。 对于Student类，我们可以创建一个输入表单： \u0026lt;form action=\u0026#34;#\u0026#34; th:action=\u0026#34;@{/saveStudent}\u0026#34; th:object=\u0026#34;${student}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;label th:text=\u0026#34;#{msg.id}\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;number\u0026#34; th:field=\u0026#34;*{id}\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;label th:text=\u0026#34;#{msg.name}\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; th:field=\u0026#34;*{name}\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; 在上面的代码中，/saveStudent是表单操作 URL，student是保存提交的表单数据的对象。 StudentController类处理表单提交： @Controller public class StudentController { @RequestMapping(value = \u0026#34;/saveStudent\u0026#34;, method = RequestMethod.POST) public String saveStudent(@ModelAttribute Student student, BindingResult errors, Model model) { // logic to process input data  } } @RequestMapping注解将控制器方法映射到表单中提供的 URL。带注释的方法saveStudent()对提交的表单执行所需的处理。最后，@ModelAttribute注释将表单字段绑定到学生对象。 8. 显示验证错误 我们可以使用*#fields.hasErrors()函数来检查一个字段是否有任何验证错误。我们使用#fields.errors()*函数来显示特定字段的错误。字段名称是这两个函数的输入参数。 让我们看一下用于迭代并显示表单中每个字段的错误的 HTML 代码： \u0026lt;ul\u0026gt; \u0026lt;li th:each=\u0026#34;err : ${#fields.errors(\u0026#39;id\u0026#39;)}\u0026#34; th:text=\u0026#34;${err}\u0026#34; /\u0026gt; \u0026lt;li th:each=\u0026#34;err : ${#fields.errors(\u0026#39;name\u0026#39;)}\u0026#34; th:text=\u0026#34;${err}\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; 上述函数不接受字段名称，而是接受通配符或常量all来表示所有字段。我们使用th:each*属性来迭代每个字段可能存在的多个错误。 这是之前使用通配符***重写的 HTML 代码： \u0026lt;ul\u0026gt; \u0026lt;li th:each=\u0026#34;err : ${#fields.errors(\u0026#39;*\u0026#39;)}\u0026#34; th:text=\u0026#34;${err}\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; 在这里我们使用常量all： \u0026lt;ul\u0026gt; \u0026lt;li th:each=\u0026#34;err : ${#fields.errors(\u0026#39;all\u0026#39;)}\u0026#34; th:text=\u0026#34;${err}\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; 同样，我们可以使用全局常量在 Spring 中显示全局错误。 这是显示全局错误的 HTML 代码： \u0026lt;ul\u0026gt; \u0026lt;li th:each=\u0026#34;err : ${#fields.errors(\u0026#39;global\u0026#39;)}\u0026#34; th:text=\u0026#34;${err}\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; 此外，我们可以使用th:errors属性来显示错误消息。 之前在表单中显示错误的代码可以使用th:errors属性重写： \u0026lt;ul\u0026gt; \u0026lt;li th:errors=\u0026#34;*{id}\u0026#34; /\u0026gt; \u0026lt;li th:errors=\u0026#34;*{name}\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; 9. 使用转换 我们使用双括号语法*{{}}来格式化数据以供显示。这利用了为上下文文件的conversionService* bean 中的该类型字段配置的格式化程序。 让我们看看如何格式化Student类中的 name 字段： \u0026lt;tr th:each=\u0026#34;student: ${students}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${{student.name}}\u0026#34; /\u0026gt; \u0026lt;/tr\u0026gt; 上面的代码使用NameFormatter类，通过覆盖*WebMvcConfigurer接口的**addFormatters()*方法进行配置。 为此，我们的*@Configuration类覆盖了WebMvcConfigurerAdapter*类： @Configuration public class WebMVCConfig extends WebMvcConfigurerAdapter { // ...  @Override @Description(\u0026#34;Custom Conversion Service\u0026#34;) public void addFormatters(FormatterRegistry registry) { registry.addFormatter(new NameFormatter()); } } NameFormatter类实现了 Spring Formatter接口。 我们还可以使用*#conversions实用程序来转换对象以进行显示。实用程序函数的语法是#conversions.convert(Object, Class)，其中Object被转换为Class*类型。 以下是如何在删除小数部分的情况下显示学生对象百分比字段： \u0026lt;tr th:each=\u0026#34;student: ${students}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${#conversions.convert(student.percentage, \u0026#39;Integer\u0026#39;)}\u0026#34; /\u0026gt; \u0026lt;/tr\u0026gt; 10. 结论 在本文中，我们了解了如何在 Spring MVC 应用程序中集成和使用 Thymeleaf。 我们还看到了如何显示字段、接受输入、显示验证错误以及转换数据以供显示的示例。 ","permalink":"http://itcodingman.github.io/thymeleaf-in-spring-mvc/","tags":null,"title":""},{"categories":null,"contents":"与 Spring 和 JPA 的事务 一、概述 本教程将讨论配置 Spring Transactions 的正确方法、如何使用*@Transactional*注解以及常见的陷阱。 有关核心持久性配置的更深入讨论，请查看Spring with JPA 教程。 基本上，有两种不同的方式来配置事务、注解和 AOP，每一种方式都有自己的优势。我们将在这里讨论更常见的注释配置。 进一步阅读： 为测试配置单独的 Spring DataSource 关于如何配置单独的数据源以在 Spring 应用程序中进行测试的快速实用教程。 阅读更多→ 使用 Spring Boot 加载初始数据的快速指南 在 Spring Boot 中使用 data.sql 和 schema.sql 文件的快速实用示例。 阅读更多→ 显示来自 Spring Boot 的 Hibernate/JPA SQL 语句 了解如何在 Spring Boot 应用程序中配置生成的 SQL 语句的日志记录。 阅读更多→ 2.配置事务 Spring 3.1 引入了*@EnableTransactionManagement*注解，我们可以在*@Configuration*类中使用它来启用事务支持： @Configuration @EnableTransactionManagement public class PersistenceJPAConfig{ @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactoryBean(){ //...  } @Bean public PlatformTransactionManager transactionManager(){ JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory( entityManagerFactoryBean().getObject() ); return transactionManager; } } 但是，如果我们使用的是 Spring Boot 项目并且类路径上有 spring-data-* 或 spring-tx 依赖项，则默认情况下将启用事务管理。 3. 使用 XML 配置事务 对于 3.1 之前的版本，或者如果 Java 不是一个选项，这里是使用注释驱动和命名空间支持的 XML 配置： \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.orm.jpa.JpaTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;entityManagerFactory\u0026#34; ref=\u0026#34;myEmf\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;txManager\u0026#34; /\u0026gt; 4. *@Transactional*注解 配置事务后，我们现在可以在类或方法级别使用*@Transactional注释 bean：* @Service @Transactional public class FooService { //... } 注释还支持进一步的配置：  交易的传播类型 事务的隔离级别 事务包装的操作的超时 一个readOnly 标志——提示持久性提供者事务应该是只读的 事务的回滚规则  请注意，默认情况下，回滚仅发生在运行时，未经检查的异常。检查的异常不会触发事务的回滚。当然，我们可以使用rollbackFor和noRollbackFor注释参数来配置这种行为。 5. 潜在的陷阱 5.1。交易和代理 在高层次上， Spring 为所有使用***@Transactional***注释的类创建代理，无论是在类上还是在任何方法上。代理允许框架在运行方法之前和之后注入事务逻辑，主要用于启动和提交事务。 需要记住的重要一点是，如果事务 bean 正在实现一个接口，那么默认情况下代理将是一个 Java 动态代理。这意味着只有通过代理传入的外部方法调用才会被拦截。**任何自调用都不会启动任何事务，*即使该方法具有@Transactional*注释。 使用代理的另一个注意事项是**只有公共方法才应该使用*@Transactional 进行注释。***任何其他可见性的方法将简单地忽略注释，因为它们没有被代理。 5.2. 更改隔离级别 courseDao.createWithRuntimeException(course); 我们还可以更改事务隔离级别： @Transactional(isolation = Isolation.SERIALIZABLE) 请注意，这实际上已在 Spring 4.1中引入；如果我们在 Spring 4.1 之前运行上面的示例，它将导致：  org.springframework.transaction.InvalidIsolationLevelException：标准 JPA 不支持自定义隔离级别 -为您的 JPA 实现使用特殊的JpaDialect  5.3. 只读事务 readOnly标志通常会产生混淆，尤其是在使用 JPA 时。来自 Javadoc：  这只是作为实际事务子系统的提示；它不一定会导致写访问尝试失败。无法解释只读提示的事务管理器在请求只读事务时不会抛出异常。  事实是，当设置了***readOnly*****标志时，****我们不能确定不会发生插入或更新。**此行为取决于供应商，而 JPA 与供应商无关。 了解***readOnly*标志仅在事务内部相关也很重要。**如果操作发生在事务上下文之外，则简单地忽略该标志。一个简单的示例将调用一个带有以下注释的方法： @Transactional( propagation = Propagation.SUPPORTS,readOnly = true ) 在非事务性上下文中，不会创建事务并且readOnly标志将被忽略。 5.4. 事务记录 了解事务相关问题的一个有用方法是微调事务包中的日志记录。Spring中的相关包是“ org.springframework.transaction”，需要配置一个TRACE的日志级别。 5.5. 事务回滚 @Transactional注释是指定方法上事务的语义的元数据。我们有两种回滚事务的方法：声明式和编程式。 在声明式方法中，我们使用 @Transactional 注释对*方法*进行注释。@Transactional注释使用属性rollbackFor或rollbackForClassName来回滚事务，并使用属性noRollbackFor或noRollbackForClassName来避免对列出的异常进行回滚。 声明式方法中的默认回滚行为将在运行时异常时回滚。 让我们看一个使用声明性方法回滚事务以处理运行时异常或错误的简单示例： @Transactional public void createCourseDeclarativeWithRuntimeException(Course course) { courseDao.create(course); throw new DataIntegrityViolationException(\u0026#34;Throwing exception for demoing Rollback!!!\u0026#34;); } 接下来，我们将使用声明性方法为列出的检查异常回滚事务。我们示例中的回滚是在SQLException上： @Transactional(rollbackFor = { SQLException.class }) public void createCourseDeclarativeWithCheckedException(Course course) throws SQLException { courseDao.create(course); throw new SQLException(\u0026#34;Throwing exception for demoing rollback\u0026#34;); } 让我们看一下在声明性方法中对属性noRollbackFor的简单使用，以防止所列异常的事务回滚： @Transactional(noRollbackFor = { SQLException.class }) public void createCourseDeclarativeWithNoRollBack(Course course) throws SQLException { courseDao.create(course); throw new SQLException(\u0026#34;Throwing exception for demoing rollback\u0026#34;); } 在编程方法中，我们使用*TransactionAspectSupport*****回滚事务： public void createCourseDefaultRatingProgramatic(Course course) { try { courseDao.create(course); } catch (Exception e) { TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); } } 声明性回滚策略应该 优于程序化回滚策略。 六，结论 在本文中，我们介绍了使用 Java 和 XML 的事务语义的基本配置。我们还学习了如何使用*@Transactional，*以及事务策略的最佳实践。 ","permalink":"http://itcodingman.github.io/transaction-configuration-with-jpa-and-spring/","tags":null,"title":""},{"categories":null,"contents":"","permalink":"http://itcodingman.github.io/search/","tags":null,"title":"Search"}]